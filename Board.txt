//----- Variables -----------------------------------------------------------------------------------------------------

ABS PAWN DIFF (EVAL) = 0
activation value res = 9.7100000000006
add to full game debug temp = Avg. Q-Best Move Idx: 1.08
area counter black (eval) = 8
area counter white (eval) = 8
ArePseudoLegalMovesForOpposing? = 0
benchmark movegen NPS = 1531.024k
benchmark movegen speed start time = 9202.94826769676
benchmark movegen time elapsed = 1.2409998569638
benchmark time for 10k = 0.124s
best move (DELTA_CI notation) = 0
bestMoveDepth2temp = 5345
BestMoveIdxSum(Profiler) = 0
bestMovePiece = -100
bestMoveTaking = 
BestMoveTotal#(Profiler) = 0
bishop color (eval) = light
bishop colored pawns temp (eval) = 4
bishop on long diagonal (eval) = 0
bishop pawns malus temp (eval) = -4
BLACK BISHOP TYPE (EVAL) = dark
blackKingID(eval) = 5
BlackKingisAttacked (eval) = 0
BlackKingPawnlessFlank (eval) = 0
Black PSTs End (eval) = 92
Black PSTs Middle (eval) = -8
BlackQueenID(eval) = 4
blockingPieceColor = 
blockingPieceID = 
board file = 8
board piece ID = 0
board rank = 8
book finder depth idx = 9
book finder idx = 37
book finder maker idx = 22
captureMaterialDelta = -580
clear large info idx = 30
closest piece from square res = 320
colorForPiecesOfPseudoLegalMoves = w
color of piece = w
counter for creating board hash = 64
counter for evaluation = 64
counter for evaluation (outer) = 16
counter for NN activate = 129
counter to add attack table to snapshot = 65
counter to count chunk ID (massive list to verify checks) = 6
counter to find correct book move = 164
counter to find legal king moves = 8
counter to find legal moves for knight = 8
counter to find legal moves for pawns = 4
counter to find legal moves for sliding pieces 2 = 1
counter to get all legal moves = 20
counter to get all legal moves for target player piece = 20
counter to get all pseudo-legal moves = 64
counter to get distance to center = 64
counter to get distance to square 1 = 64
counter to get distance to square 2 = 64
counter to get hash bucket = 1
counter to init file & rank from square index = 10000
counter to initialize squares until end of board = 64
counter to init piece to NN input type = 2000
counter to init piece type to chunk (checks) = 1900
counter to limit book line length = 4
counter to load FEN = 60
counter to load FEN (Board Position ID) = 64
counter to make PGN file = 2
counter to map white pst to black pst = 64
counter to order moves = 20
counter to reset NN accumulator = 64
counter to reset repetition table = 0
countOfBlockingPieces = 0
countOfBlockingPiecesToKing = 0
cpu clock time left = 13.510000108508
currentBoardHash = -1179123665555862
current book finder book line idx = 1
current move (for PGN file making) = 1329
current move (pawn move gen) = 5640
current move target (pawn move gen) = 40
current moving piece (for PGN file making) = 
current piece (eval) = 100
current piece type (eval) = 500
current real position board hash (book finder) = -563071125793264
current reverting move = 1329
current val (board attacked snapshot prep) = 0111111011111111111111110000000000000000000000000000000000000000
current val 2 (board attacked snapshot prep) = 00010405040508000103040204050608020902111207140700000000000000000000000000000000000000000000000000000000000000000000000000000000
current val 3 (board attacked snapshot prep) = 00000000000000000000000305000000101110131413161500000000000000000000000000000000000000000000000000000000000000000000000000000000
current val to init 0 padding for move = 9999
currentValue(killer) = 3628
dataset extract with rule idx = 4000000
dir from square to square res = 5
distance from square to square = 4
distance to center temp1 = 3
distance to center temp2 = 3
distance to closest edge file = 0
distance to closest edge rank = 0
distance to king them (king passer proximity) = 2
distance to king us (king passer proximity) = 5
does piece discover check square res = 0
draw by material? (eval) = 0
dstBetweenKings = 2
Endgame Eval @ Search Start? = 0
end square for applying moves = 29
end square for finding legal moves = 32
end square for move ordering temp = 32
end square for reverting moves = 29
enpassant target square (move legality check) = 00
eval is draw (repetition) = 0
EVAL PHASE (eval) = 128
eval used HCE res = 1
fast psqt read res = 4
FEN Stage = 6
file from square idx background = 7
file has pawns res (eval) = 1
file has target piece res = 0
file of our king (KPK draw detection) = 3
file of their king (KPK draw detection) = 5
file of their pawn (KPK draw detection) = 5
file temp (for getting distance to square) = 8
first move not fully searched? (ID) = 1
first search move = 1329
flank attack black king counter (eval) = 0
flank attack white king counter (eval) = 0
FORCE HCE DURING SEARCH? (NN MODE) = 0
force HCE res (eval) = 0
force move on real board end = 0
force move on real board start = 0
force move on real board to WD temp res = 0
gen checks in q-search res = 1
generate checks in q-search? (move gen) = 
get all legal moves for piece end square = 46
get all legal moves for piece move = 6346
get all legal moves for piece start square = 63
get current applying move idx at depth = 1
hanging state idx (eval) = 0
hanging state our square id (eval) = 43
hash bucket = 1005993
hash move passed basic legality test res = 0
i = 27
idx of king (mop-up eval) = 45
idx of other king (mop-up eval) = 29
imbalance calc piece inner (eval) = 6
imbalance calc piece outer (eval) = 6
imbalance from perspective res (eval) = 13228
imbalance ours res (eval) = -6
imbalance temp during calc (eval) = 1852
imbalance theirs res (eval) = 0
IMBALANCE VALUE BONUS TOTAL (EVAL) = 0
index of current board hash in rep table = 0
index of other king (for legal moves) = 61
index of target king = 5
insufficient material draw res (search) = 0
is bad capture? (q-search) = 0
isEndgame? (for eval) = 0
isHighlightSquare? = 1
isIterativeDeepening? = 1
is KPK draw? (in search) = 0
isPawnBackwards (eval) = 0
isPawnIsolated (eval) = 0
isPawnOpposed? (eval) = 1
isPawnPassed (for eval)? = 0
isPawnPhalanx (eval) = 1
isPawnSupported (eval) = 0
isRearDoubledPawn? (for eval) = 0
isRookBehindPasser? (eval) = 0
is rook endgame? (eval) = 0
isSearching? = 1
isSimpleEndgame? (for eval) = 0
is square outpost res (eval) = 0
is upper case = 0
iterative deepening Idx = 7
killerIdx = 1
killerMoveIdxSub = 20
king attack area gen center idx temp (eval) = 53
king can pseudo-castle (eval) = 1
kingEndGameEval = 0
king id attacks square res (eval) = 1
king passer proximity total (eval) = 0
king pawn tropism current weight (eval) = 1
king pawn tropism dist to black (eval) = 88
king pawn tropism dist to white (eval) = 88
king pawn tropism total value (eval) = 0
king pawn tropism weights (eval) = 16
king protector eg (eval) = 0
king protector mg (eval) = 0
kings in opposition res (eval) = 0
king stuck block square (KPK draw detection) = 55
knight attacks queen (eval) = 0
knight attacks rook (eval) = 0
knight attacks their king ring (eval) = 0
knight attacks weak piece (eval) = 0
knight is king defender (eval) = 1
knight reachable outposts (eval) = 0
last sure best move (ID) = 1329
last sure best move eval (ID) = 0
length of current game code = 44
limited book line = 
line finder idx = 21
LMRreductionsNumRes = 2
loaded custom FEN? = 0
LOADING FEN = rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
lower (WD) = 20
mobility calc for piece stop (eval) = 0
mobility calc idx (eval) = 1
mobility check attacks major piece? (eval) = 0
mobility check attacks queen? (eval) = 0
mobility check attacks their king ring (eval) = 0
mobility check attacks weak piece? (eval) = 0
mobility check minor threat (eval) = 0
mobility check sees central squares (eval) = 0
mobility check sees own pawn promotion square (eval) = 0
mobility check sees their pawn promotion square (eval) = 0
mobility current square piece (eval) = 320
MOBILITY eg (eval) = 0
mobility end square piece id (eval) = 2
mobility in direction res = 1
MOBILITY mg (eval) = 0
mobility minor threat eg (eval) = 0
mobility minor threat mg (eval) = 0
mobility num pieces passed (eval) = 1
mobility passed through not queen piece? (eval) = 1
mobility piece type (eval) = 500
mobility rook threat eg (eval) = 0
mobility rook threat mg (eval) = 0
mobility slider on queen counter (eval) = 0
mobility stop pawn color (eval) = -1
MOBILITY TOTAL TAPERED (EVAL) = 0
most advanced black pawn file (eval) = 1
most advanced black pawn rank (eval) = 7
most advanced white pawn file (eval) = 1
most advanced white pawn rank (eval) = 2
movegen added move = 1329
movegen castling state = 11
movegen current piece = 500
movegen endsquare = 64
movegen endsquare legal? = 1
movegen endsquare piece = 330
movegen enpassant target = 
movegen inner idx = 0
movegen outer idx = 64
movegen tester var = 39
move ordering current move = 1632
move ordering endsquare piece = 
move ordering endsquare piece abs = 0
move ordering killer moves id = 0
move ordering score (var) = -750
move ordering start square piece = -100
move ordering start square piece abs = 100
moves for sliding pieces direction = 7
move type (for applying moves) = capture
mps counter = 819160
newPiece (for Applying Moves) = -900
new square temp moving pieces = 32
next ply board hash temp = -929291867054117
NN activate true input idx = 584
NO PAWN SHIELD PENALTY = -2.5
not passed cond. res (eval) = 1
NOT USED ANYMORE - OP KING ID (FROM UPDATED) = 61
NUM BLACK BISHOPS (EVAL) = 2
num black king attacks (eval) = 0
num black king knight defenders (eval) = 2
NUM BLACK KNIGHTS (EVAL) = 2
NUM BLACK MAJOR PIECES (EVAL) = 3
NUM BLACK MINOR PIECES (EVAL) = 4
num black outside passers (eval) = 0
num black passers (eval) = 0
NUM BLACK PAWNS (EVAL) = 8
NUM BLACK PIECES (NOT PAWNS) (EVAL) = 7
NUM BLACK QUEENS (EVAL) = 1
NUM BLACK ROOKS (EVAL) = 2
num dark pawns BLACK (eval) = 4
num dark pawns WHITE (eval) = 4
num fully blocked center pawns black (eval) = 0
num fully blocked center pawns white (eval) = 0
num futility pruned = 0
num light pawns BLACK (eval) = 4
num light pawns WHITE (eval) = 4
num our attacks on square res (eval) = 0
num safe checks finder idx (eval) = 0
num safe checks res (eval) = 0
num their attacks on square (eval) = 3
num their attacks on square res (eval) = 0
NUM TOTAL PAWNS (EVAL) = 16
num unsafe checks for piece (mobility) (eval) = 0
NUM WHITE BISHOPS (EVAL) = 2
num white king attacks (eval) = 0
num white king knight defenders (eval) = 2
NUM WHITE KNIGHTS (EVAL) = 2
NUM WHITE MAJOR PIECES (EVAL) = 3
NUM WHITE MINOR PIECES (EVAL) = 4
num white outside passers (eval) = 0
num white passers (eval) = 0
NUM WHITE PAWNS (EVAL) = 8
NUM WHITE PIECES (NOT PAWNS) (EVAL) = 7
NUM WHITE QUEENS (EVAL) = 1
NUM WHITE ROOKS (EVAL) = 2
OG king square for legal moves calc = 5
og piece on new square for reverting moves = 
opKingDistFromCenter = 0
opKingIndex (For Pseudo-Legal Move Gen) = 5
opponent king hanging res (move gen) = 0
our check square in safe check (eval) = 53
overwrite "SquaresToBeCovered" list? = 1
passed block attacked (eval) = 0
passed block attacked block (eval) = 0
passed block defended (eval) = 0
passed block defended block (eval) = 0
passed block rank (eval) = 1
passed block temp val (eval) = 35
passed block w attacked (eval) = 0
passed block weight (eval) = 7
passed file res (eval) = 0
pawn blocked black (eval) = 0
pawn blocked white (eval) = 0
pawn can push 1? (pawn move gen) = 1
pawn can safely promote (for eval) = 0
pawn file average (eval) = 4.5
pawn movement used enpassant = 0
pawn multiplier value (for eval) = 1
PAWN SHIELD BONUS = 40
pawn weight (king passer proximity) = 7
phase endgame limit (eval) = 1500
phase factor (eval) = 5800
piece attacked during mobility check (eval) = 
piece check square res (WD) = 0
piece in black king shield? = 0
piece in white king shield? = 0
piece is attacker? (eval) = 0
piece is pinned res (eval) = 0
piece mobility counter (eval) = 0
pieceMovingDirection(var) = 7
pieceMovingDirectionAlt(var) = 3
piece on square ID (for finding pseudo-legal moves) = 500
piece pin detection delta file = -1
piece pin detection delta rank = 0
piecePinnedDirection(var) = 
piecePosHash = 11443699514203
piece type (massive list to verify checks) = -900
piece type for gen fast psqt read = -99999
PIECE VALUE BONUS ENDGAME (EVAL) = 0
PIECE VALUE BONUS MIDDLEGAME (EVAL) = 0
pivot (WD) = 4500
possible to win finished (eval) = 0
possible to win only up exchange (eval) = 1
promotionBonus? = 0
promotionMove?(for legal moves) = 0
PST at End Square (move ordering) = 4
PST at Start Square (move ordering) = 2.5
PST_read_res = -5
pv collection search idx = 7
pv to uci format idx = 1
pv_total_read_at_root _idx = 2
pv_val_read_res = 1329
queen attacked threat idx (eval) = 0
queen threat square (eval) = 28
R (null move reduction) = 2
rank from square idx background = 3
rank of our king (KPK draw detection) = 4
rank of their king (KPK draw detection) = 2
rank of their pawn (KPK draw detection) = 7
rank temp (for getting distance to square) = 1
rep. detection in search idx = 1
searchExtension = 0
search starting depth = 1
SE extension res = 0
Shelter Pawns Kingside (eval) = 0
Shelter Pawns No Castle (eval) = 0
Shelter Pawns Queenside (eval) = 0
Shelter Val Kingside (eval) = 120
Shelter Val No Castle (eval) = 0
Shelter Val Queenside (eval) = 80
sigmoidFuncRes = 0.46833511743828
source of attack (discovery check verification) = 5
space total res (eval) = 0
space weight black (eval) = 13
space weight white (eval) = 13
specialNoLmrCond Res = 1
square idx from rank and file res = 63
square with delta rank and file res = 27
startsInCheck? (var) = 0
start square (massive list to verify checks) = 64
start square for applying moves = 13
start square for finding legal moves = 16
start square for move ordering temp = 16
start square for moving pieces = 16
start square for reverting move = 13
start square piece for reverting move = -100
start time for search = 9206.8707647685
str = ABCDEFGHIJKLMNOPqRSTUVWXYZ
supported characters = ABCDEFGHIJKLMNOPQRSTUVWXYZ
target square (massive list to verify checks) = 64
temp file for closest piece = 7
temp file for mob. calc (eval) = 7
temp rank for closest piece = 1
temp rank for mob. calc (eval) = 1
tempSwap (WD) = 4500
tempSwap2 = 1018
their distance from our prom square - poss. to win (eval) = 5
their king square (fast movegen) = 5
their least advanced blocker pawn (eval) = 7
time at start (mps tester) = 8866.00584832176
total knight movement x = 10
total knight movement y = 0
trapped rook multiplier (eval) = 1
TTcurrentAge = 0
TTentryUsed? = 0
TTprobeBestMoveRes = ???
TTprobeHorizonRes = -1
TTprobeNodeAgeRes = 106
TTprobeNodeBoardAttacked = 0102121011143211222233220010111001010111100000010000000000000000
TTprobeNodeBoardAttackedSource1 = 00010005130508000103130205050608020902110307140700001300130313000013002900290313130000000000000300000000000000000000000000000000
TTprobeNodeBoardAttackedSource2 = 00000013001300000000000306130000101110131313161500000000000000000000000000000000000000000000000000000000000000000000000000000000
TTprobeNodeDepth = 7
TTprobeNodeQSstartDepth = 6
TTprobeNodeScoreRes = 103
TTprobeNodeType = B
unsafe checks total black (eval) = 0
unsafe checks total white (eval) = 0
update board visual last move square = 0
updatedPinnedPiece? = 0
upper (WD) = 18
usedBook = ???
usedBookPick = 1
Used Mop-Up Eval? (evaluation) = 0
USED THIS MOVE (DEBUGGING OVERIDE) = 0
var to init knight movement table = 64
var to init pawn movement table = 64
WD_checkmated? = 0
WD_last_piece_moved(convert WD to UCI form.) = 0
WD_min_search_depth = 6
WD_NNUE_acc_update_idx = 257
WD_NNUE_acc_update_side = 2
WD_NNUE_acc_update_weightIdx = 74753
WD_NNUE_activation_derivative = 1
WD_NNUE_act_idx_pieceToNNtype = 10
WD_NNUE_Hidden_Size = 128
WD_NNUE_runtime_accUpdate_idx = 64
WD_NNUE_run_idx = 129
WD_NNUE_run_idxSub = 128
WD_NNUE_run_idxSub2 = 0
wd_timeman_no_increment? = 1
WHITE BISHOP TYPE (EVAL) = light
whiteKingID(eval) = 61
WhiteKingIsAttacked (eval) = 0
WhiteKingPawnlessFlank (eval) = 0
White PSTs End (eval) = -92
White PSTs Middle (eval) = 8
WhiteQueenID(eval) = 60
Will Attack King? (movegen) = 0
Will X-Ray King? (movegen) = 0


//----- Lists ---------------------------------------------------------------------------------------------------------

# Opposing Attacks Square = { }
# side to move attacking square (move gen) = { }
ALL LEGAL MOVES FOR CPU CALCS = { 
    0217
    0219
    0722
    0724
    0917
    0925
    1018
    1026
    1119
    1127
    1220
    1228
    1321
    1329
    1422
    1430
    1523
    1531
    1624
    1632
}
Alphas = { }
Alphas Temp = { }
Alternate Piece ID = { 
    100
    320
    330
    500
    900
    99999
    -100
    -320
    -330
    -500
    -900
    -99999
}
Apply Num Extensions At Depth = { }
Best Move = { }
BestMoveIndex = { }
BEST MOVES (LOG) = { }
BEST MOVES EVAL (LOG) = { }
Best Score Temp = { }
Betas = { }
Betas Temp = { }
Better for Black Opening Book = { 
    53371321504212285244112759502836
    53371321504212283728212859500722
    53371321504212285950071354380917
    63460722513511275244021958431321554706136255122859380090352821284436273646360418361910196051
    544613295843021953370627623512205244162463530440
    5446132958430219533706276235122052441624635304405547404843284855615205046062034862554855
    5337132152441228585207226346112755470219625506130092009062611026
    5337132152441228
    533713215438122852442837443704606160072262441018
    53371321543812283729112763460219
    5337132954382938
    533713295438293862531430373004406162122863464022
    4941122863461127534502195135283650340722342619255244364559451018
    53371329543829386253143037291220523602195938202936290460
    5337132954382938625314303729122029200620
    50421228595007225345033063461321
    554712286255132952440722634602190092162451352835443504606260032150420620
    584312285235
    584312285337283643531329534703216346142262261119263302173342172742212721
    533713216346122837282128624406200092071362610090
    533713215135122837282128523607226346063458430090
    533713215135122835282128372807226346222858430219
}
Better for White Opening Book = { 
    523613293629021963460413593814222922
    52361329362902196346041359381334385234135843192953370722462913295438
    523613293629021963460413593813343852345058430634575850414328
    523613293629021963461220292006205843
    52361329362912206346
    52361228513513293629283663460219585203304941
    52361228513513293629283560040504634602195843
}
black area counter (eval) = { }
Black Attacks (eval) = { }
Black Attacks Source (eval) = { }
Black Checks Source (eval) = { }
black king flank (eval) = { 
    0
    0
    1
    1
    1
    1
    0
    0
}
Black King Ring (eval) = { }
Black Passers on File (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
}
blackPawn(ForEval) = { 
    
    
    
    
    
    
    
    
    1
    1
    1
    1
    1
    1
    1
    1
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
Black Pawn Attacks Square (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    1
    2
    2
    2
    2
    2
    2
    1
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
BlackPawnMovementEquivalent = { 
    7
    6
    8
    7
}
Black Pawn Movement Table = { }
Black queen attacks on square (eval) = { 
    0
    0
    1
    0
    1
    0
    0
    0
    0
    0
    1
    1
    1
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
Black Queen Check Possible? (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
Black Queen Threat Squares (eval) = { }
Black Queen Threat Squares Source (eval) = { }
Black Rook Check Possible? (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
Black Rooks On File = { 
    1
    0
    0
    0
    0
    0
    0
    1
}
BoardAttackedBySideToMovePieceSnapshot = { }
BoardAttackedBySideToMovePieceSnapshot 2 = { }
BoardAttackedBySideToMoveSnapshot = { }
book finder current book = { }
Books Found = { }
Books Found Type = { }
Castling Rights (Load FEN) = { 
    K
    Q
    k
    q
}
Chebyshev Distance to Square = { }
ConnectedPawnBonus = { 
    
    3.5
    4
    6
    14.5
    24
    43
    
}
CurrentKillerMoves = { 
    
    
    
    
}
Depth 0 (save for others) = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
direction offsets for sliding pieces = { 
    1
    -7
    -8
    -9
    -1
    7
    8
    9
}
dir from square to square = { }
Distance To Center = { 
    6
    5
    4
    3
    3
    4
    5
    6
    5
    4
    3
    2
    2
    3
    4
    5
    4
    3
    2
    1
    1
    2
    3
    4
    3
    2
    1
    0
    0
    1
    2
    3
    3
    2
    1
    0
    0
    1
    2
    3
    4
    3
    2
    1
    1
    2
    3
    4
    5
    4
    3
    2
    2
    3
    4
    5
    6
    5
    4
    3
    3
    4
    5
    6
}
Distance To Each Edge (Check Detection) = { 
    0
    0
    7
    7
    7
    0
    0
    0
}
Distance To Each Edge (movegen) = { 
    0
    0
    7
    7
    7
    0
    0
    0
}
Exclude Move at Depth = { }
Fully Legal Move Gen? = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
FUTILITY PRUNING MARGIN = { 
    125
    250
}
Hash Move = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
ImbalancePieceCounts (eval) = { 
    1
    8
    2
    2
    2
    1
    1
    8
    2
    2
    2
    1
}
ImbalanceQuadraticOurs = { 
    0
    40
    38
    32
    255
    -62
    0
    104
    4
    0
    -26
    -2
    47
    105
    -208
    -189
    24
    117
    133
    -134
    -6
}
ImbalanceQuadraticTheirs = { 
    0
    36
    0
    9
    63
    0
    59
    65
    42
    0
    46
    39
    24
    -24
    0
    97
    100
    -42
    137
    268
    0
}
Is Futility Pruned? = { }
IsSlidingPiece? = { 
    
    
    
    
    2
    2
    2
    2
    2
    2
    2
    2
    2
    2
    2
    2
    2
    2
    2
    2
}
ITERATIVE IDX BEST MOVE IN POS = { }
ITERATIVE IDX EVAL AT POS = { }
KillerMoves = { }
Knight Movement Offsets (Addition/Subtraction) = { 
    -6
    -15
    -17
    -10
    6
    15
    17
    10
}
Knight Movement Table = { }
Knight Movement Table Endsquare = { }
Knight Movement X Offsets = { 
    2
    1
    -1
    -2
    -2
    -1
    1
    2
}
Knight Movement Y Offsets = { 
    1
    2
    2
    1
    -1
    -2
    -2
    -1
}
Large Positional in Static Eval at Depth = { }
Least Advanced Black Pawn = { 
    7
    7
    7
    7
    7
    7
    7
    7
}
Least Advanced White Pawn = { 
    2
    2
    2
    2
    2
    2
    2
    2
}
Manhattan Distance To Square = { }
MASSIVE LIST TO VERIFY CHECKS = { }
MaxEval = { }
MinEval = { }
Minmax Res Temp = { }
Mobility Area Black = { 
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    0
    0
    0
    0
    0
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    0
    0
    0
    0
    0
    0
    0
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
}
Mobility Area White = { 
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    0
    0
    0
    0
    0
    0
    0
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    1
    0
    0
    0
    0
    0
    0
    0
    0
    1
    1
    1
    0
    0
    1
    1
    1
}
Most Advanced Black Pawn = { 
    7
    7
    7
    7
    7
    7
    7
    7
}
Most Advanced White Pawn = { 
    2
    2
    2
    2
    2
    2
    2
    2
}
Moves Count = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
MovesDepth 1 = { }
MovesDepth 2 = { }
MovesDepth 3 = { }
MovesDepth 4 = { }
MovesDepth 5 = { }
MovesDepth 6 = { }
MovesDepth 7 = { }
MovesDepth 8 = { }
MovesDepth 9 = { }
MovesDepth 10 = { }
MovesDepth 11 = { }
MovesDepth 12 = { }
MovesDepth 13 = { }
MovesDepth 14 = { }
MovesDepth 15 = { }
MovesDepth 16 = { }
MovesDepth 17 = { }
MovesDepth 18 = { }
MovesDepth 19 = { }
MovesDepth 20 = { }
MovesDepth 21 = { }
MovesDepth 22 = { }
MovesDepth 23 = { }
MovesDepth 24 = { }
MovesDepth 25 = { }
MovesDepth 26 = { }
MovesDepth 27 = { }
MovesDepth 28 = { }
MovesDepth 29 = { }
MovesDepth 30 = { }
Moves for Ordering (Temp For Sorting) = { 
    1329
    0219
    0722
    0217
    0724
    1321
    1422
    1119
    1228
    1523
    1531
    1632
    1430
    1220
    1127
    0925
    0917
    1624
    1018
    1026
}
Moves Index = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
Moves Index Temp = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
Moves Played In Search = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
Moves Score Guess = { 
    -9999999
    -25000
    -24000
    -7500
    -5000
    -3750
    -500
    -250
    0
    500
    500
    750
    1000
    1250
    1250
    1750
    3000
    4250
    4500
    7000
}
Move Type (applying moves) = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
Neutral Opening Book = { 
    53371329634602196226072200922237523637202619121936292030600405045843040556481632
    5236072251351321634612285547063459523413625500900092111960510212
    53371321523612283729112751430219634604184941072450342736592415244336031257490807554707394952393762530925342618260092261853443736463618366261061544163627
    5337132152361228372911275143021963460418494107245034273634261925592415244336031258520103413306346244
    533713215236122837291127514302196346041849410724
    5337132152361228372821286346062051350722352720135945009062441018009218273627111949410925585225335759
    53371321523612283728212858430722
    5236122851352835533707223729222862350330
    53371321523612283729
    53371321523612283729031259451127
    533713215236122837291127514302196346
    5337132152361228372911275143041863460312
    533713215236122837291127634627364636021936191019
    53371321523612285843283743370312634612196244021259381222373106204629202938290713
    533713215236122858432837433703126346121937310620624416243137072237200420
    533713215236122858432837433703126346121937310212624416243137072260532237
    5236072251351321584312286346283553370634623522370092374350433420
    523607225135132155471228
    52361228513511196346072258431321593116243122042253450212625306130092009062610604
    52361228513511195843072263461321
    533712283728072252360428634603395135394660462846
    634607225135112752362736463613293626122835280627264300905547041853450339625339536053
    634607225236122851351119
    6346072251351127584302195547122852361321352821286255273646360627
    5135112763460722
    5135112758430219
    5135112758430219634613215547122835282128523627364636072262550627
    5135112758430219554715236255061563461220
    533713215236122837290312634611275143021962532736433607135843133000920917
    5337132152361228372903126346112736270627624407130092021959381323
    53371321523612283729031251431127
    53371321523612283729031258431127
    53371321523612283729031258521127
    523612285135283558430722533713296346293660360436463606273626021759381119262027203820032137292212
    523612285938112753452736453607226346
    52361228593811275143072263462736
    52361228593811275143273643360722
    533713296346021952362936
    533713296346021952362936463607223619101962441228372819280092061351352836626100905938
    53371329634602195236293646360627364227185843
    533713296346021952362936463606273619042260461219623522465546
    5337132963460219523629364636
    6346072251351127524402195843132155470613625512283528212844362736
    634607225135112752440219554712283528222862551329
    5337112763461321514312283728042852362736433628205843072259310613623502190092009049410604605319364636203662603618600418045760
    53371127634613215143122837280428523607225841021959452736412628122636
    533713215236122858521127634627364636072237282228554703126255021936191219009206136053009062600418
    533713215236122858521127634627364636072237292212524602196226062736191019261904181912031260520090009228364631162431370604
    533713215236122858521127634627363728042862352820009207225242021942361936463609176261061351430090
    52360722634612285135111958431321593116243122042253450212625306130092009062610604
    52361228634607225135111958431321593116243122042253450212625306130092009062610604
    5236122859380722634603305135132158432835534522286235
    523612285938072263461127
    53371321523612285843283743370312634612196244021200920722374706136261009051431018
    53371321523612285843283743370312634612196244021200920722374706136053194653461119
    53371321523612285843283743370312634612196244021200920722374306136261194660461119
    53371321523612285843283743370312634612196244021200920722374306136053194653461119
    523612285135111935281928584307225938021953450339634601035648394660461321
    5236122851351119352819285843072259380219
    5236122851351119352819286346
    533713216346122837282128523607225843062062440090009203395648393262611119
    5337132163461228372821285236072262440620009200906261033956483932593116243140021258521119
    53371321634612283729112751432836433627365547071362551323
    5337132163461228372911275143283643362736
    53371321634612283729112751432836
    533713216346122837291127
    513513215843112763460219554712283528212852362735625507220092061359310090
    513513215843112763460219554712283528212852362736463607226255062736422734593134435043009000921624312204226028224328260917262743226260
    51351321584307226346063460510090494134435143101853450310625322374351122852443731503428355135042257583146554602125950212935392213
    5135132158431228523607223528212859310613534500906244060563461119009203395648394660460212
    5135132158430634533707136346009052361228624411270092283544352736463602194941344350430917
    5337112762351321634607225843021935260411261911196053061300920090
    5337112762351321634607225843021935260411009206132619111960530090
    533711276235132163460722584302193526041152440613261911193729222843281928
    5337112762351321634602190092122837282128354207225236273542330620
    53371127623513216346122837282128352602190092061352360722
    5337112762351321634606135843021900921220523627364636072259450090
    5337132152361228372911275143021963460418625327364336071358411330415103120092061353440925
    5337132152361228372911275143021963460418625327364336071358431330
    5337132152361228372911275143021963460418625327364336071353441330443021300092
    53371321523612283729112751430219634604186253273643360713584103124151133000920103
    52361228513528356033021963460722584322284629281829190420332520195337132162530613009200905938132038451905
    5337132152361228584328374337031262440722372204226346162400920620626112194629202936292240
    533713215236122858432837433703126244072237220422634616240092062060530219514300906261
    5337132152361228584328374337031262440722
    523607225135132155471228634628356255063459523413
    523607225135132155471228634606345952341362550090
    6346122852360722593811275345021958520418362718505135033060595059575915236253
    534513295236293645361228
    533713216346122837282128523607225843062059311119
    5337132163461228372821285236072258430620
    5337132163461228372821285236072258430620
    634612285236132151352835534510264933111933261926504206345952345258520722423526356235
    63461228523613215135283553451026493311193326192650420722423526356235062000920090
    533713216346122837282128513528365244112762530219
    5337132152361228584328374337031263461219624402120092072237470613513519466046112736281229465329445344
    53371321523612285843283743370312634612196244021200920722374706135143009062610917
    53371127634613215236273646360722584302193619101937292228
    5337132163461228372821285135283652441127625302190092062046310713
    5135112758430219634613215547122835282128523607226255
    5337112763461321523627364636021958430722361910193729222843370411543811185135063461531430
    53371127634613215236273646360219584307226244021936191019
    53371321523612283729112751430219634604186253273643360713584113304151031200920103
    53371321523612283728212863460620513511195843072262442835443500900092033056480212
    5337122837280722523622286346112736270219513528344941042559520330625334516051305152251925503425425749515849504227505827123527
    533711276346132152362736463602195843072262443626122059382129
    5337132963460219623507225244
    533713296346021962350627009207225244
    533713296346021962350627514307225244
    5337132963460219623507224631122837281925352611192819101926531624314629374629
    533713296346021962350722463112283728
    533711195236122837290330634613216253021200921624
    5337111952361228372903306346132162531927594527364636071351350219603309175843283500930425
    53371119523612283729
    5337111952361228372919273627
    5337111952361228372919276346273646360219361910196244132100920713
    5337111952361228
    5337111952361228584328374337033037473023564016246346021240322316624416446044132159520722009306135958
    5337111952361228584328374337033037473023634602125640162440322316
    5337111952361228
    53371119
    533713296346021962260722524406275143009000921228
    533713296346021962260722524406275143009000921220
    53371329634602196226072252440627
    533712283728042858432825523607226346111962350330
    533712283728042858432825523607226235033954463912
    5337122837280428584328255236072262350339
    53371127634602195236273646360722584313293626122059310917264110263122152243282230624403210092212837281913
    5337112763461220523627364636072258430917593113215438041836420613
    53371329634602196226091726331026334219250092122052362936463603105952254236420722
    5337132963460219622609172633102633420722009203105244061358430090595212204328222842280403626113225143191328100310
    533713296346021962260917263310263342072200920627493301025143122052362718332518095648009059450605
    5337132963460219622609172633
    5337132963460219622609172619121900920339564816325244042258520713626113234436233848393239554739466046382136292229
    53371228372807226346222852361321513528225843112759452736463609176253041100920613
    533712283728072263462228523613215135282258431127625327366036061336041304
    53371228372807226346222852361321625311270092021951352822594527364636041158430613
    533712283728072263462228623503304640302340231623
    533712283728072263462228623503300092132158430613
    53371228372807226346
    523613215337
    5236132151351228
    533713216346122837282128523607225843062060532013
    53371321634612283728212852360722584306206053032146310413
    5236122851352835634607225345132162351127009209173627046062600627
    523612285135283563460722
    5337132963460219622609172633102633420722009206274933010233261726462919295236273660361220543829193644
    5337132963460219622609172633102633421925009212205236293646360310595225423642072242250403
    533713215236122858430634372911274941342550342736603905064326251863460219
    53371321523612285843063437291127494134255034273643262511
    533713215236122858430634
    5337132963460219622607220092223762613720
    533713296235072252440219
    533712283728072262260312263512395446390358430212
    53371228372807226226031226532228523613215135282263461127
    53371329634602196226091726331026334219250092122052362936463603105952254236420722422504036261061337292029612910285231111958432821
    53371329634602195843072262261936463629363729364329220422
    533713296346021958430722
    533713295843021963460722622619364636293637293643293646
    5337132958430219634607225236293646360634361910196244
    5337132958430219
    533711275143072237292228
    533711275143122837280428634607225236021959450339362728606160222862350091
    5337112751431228372804285236132163460722584102195945273641262804
}
Next Ply Board Hash = { }
num black attacks on square (eval) = { 
    0
    1
    1
    0
    1
    0
    1
    0
    1
    1
    1
    3
    3
    0
    1
    1
    2
    2
    3
    2
    2
    3
    2
    2
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
num white attacks on square (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    2
    2
    3
    2
    2
    3
    2
    2
    1
    1
    1
    3
    3
    0
    1
    1
    0
    1
    1
    0
    1
    0
    1
    0
}
Old Black Pawn Direction -> New = { 
    2
    3
    1
    4
}
Old White Pawn Direction -> New = { 
    3
    2
    1
    4
}
Open File? (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
}
Opening Book First Move = { 
    5337
    5236
    5135
    6346
}
op pawn attack square = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    1
    2
    2
    2
    2
    2
    2
    1
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
Performance Mode Depth = { 
    6
    8
    8
    8
    9
}
Performance Mode Think Time = { 
    2
    10
    20
    25
    60
}
Piece Color = { 
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
    b
}
Piece is Hanging? (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
PieceMovingAlternateDirection = { 
    5
    6
    7
    8
    1
    2
    3
    4
}
PieceMovingDirection = { 
    
    
    
    
    1
    4
    1
    4
    1
    4
    1
    4
    1
    4
    1
    4
    1
    4
    1
    4
}
PiecePinnedDirection = { }
PieceSquareMultiplier = { 
    1
    1
    1
    1
    1
    1
}
piece to NN Input type = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    11
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    10
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    9
    
    
    
    
    
    
    
    
    
    8
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    7
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    1
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    2
    
    
    
    
    
    
    
    
    
    3
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    4
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    5
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
PIECE TYPE TO CHECK CHUNK = { }
PIECE TYPE TO ID = { }
PosPieceHashLookup = { 
    -159860269792319
    275949361275432
    -132538896601602
    -81260721001902
    -18900444035270
    -278981534996594
    83509319233585
    208852950223334
    188307786598119
    257551605766856
    -197936385029988
    110817951045
    -17809630798624
    81971418673698
    17843800962268
    -31627376650303
    105102704190146
    248305963171294
    -196551563084529
    267439304583808
    132605933335912
    -102245583468054
    -14756327843819
    -117507125318249
    190941756668864
    117199132179830
    -177000682589100
    113589480700344
    -240596648538664
    223887670639582
    173090888203506
    -115102279579793
    159591274263195
    103732598561647
    11839606584012
    -120466961471974
    116424985186576
    -236494998025923
    -62414883364484
    -85825715158008
    -174019790839734
    45953062207919
    -65179096608030
    159192039781998
    223742516927586
    48310444395966
    -272226472309187
    -84502556608084
    -45715416268696
    -169010385256325
    -262023115756740
    60369565531169
    39839915759857
    -16604850785283
    33859938036413
    -193403929465303
    -231901410916041
    127045772052235
    -140199011168303
    167771502989234
    -182593311864244
    46997710540079
    193528433387423
    -81193207195619
    64713041782978
    -93631120910531
    -277881109966382
    137567259925773
    194594392065109
    100658047669488
    -192037761302523
    269454202082454
    32796394595512
    65502540377975
    -185008989669981
    239881597750137
    -167523390297934
    248699758276898
    -4707703830201
    -257503051344446
    65289671292721
    193079734856960
    -778180271575
    50890144559267
    196649721246153
    172478940879329
    -133585003541918
    -93152415174149
    242904557837111
    -237527887730500
    44844452394211
    54256853635706
    45584675358751
    -17750194918360
    -1928063802746
    -233969208155697
    281245973316158
    227829429540425
    117246411455274
    -168718839171892
    273954521091130
    -66303780442797
    -221456598819871
    105437208085035
    94450700855644
    -224526856908147
    79105584512399
    -276900519861838
    219377954241757
    -9045160700879
    -249717546466605
    156719980960439
    194282850202060
    -201223362998717
    -36654487318906
    139888424050037
    -89222138653977
    -79780178485104
    -99777367124909
    -16893687290449
    -202610919032979
    69162983749763
    211690036900822
    101416245180477
    175986527791301
    -233092411267426
    -111282633208432
    -215728989119061
    230434567417547
    97114267064474
    -224232567238347
    -240728847243966
    233083840624762
    107866982306679
    106312178511524
    275894135459129
    26735953582397
    155127757362383
    3082564867809
    -10244689040786
    259424887186380
    165277607533359
    -142100133395896
    -260207171631002
    70119210656080
    -59490535019270
    -81724461081694
    211797981910009
    134170216896159
    -200942898695184
    -11350196802848
    -163690100876948
    247209979070976
    -5284439133839
    223630854260225
    -178574424570116
    210648891051625
    -155483937625342
    175322387771195
    12899360486058
    146935296219363
    -47461725529399
    -112642302544004
    68393711884351
    94925251401791
    257663594425553
    129691026713695
    134946795171842
    239365031589985
    -123732499038644
    268648883495844
    -223713125509635
    86269738440622
    -201073215683702
    -220445196299850
    241214612568313
    -3030600402349
    163764173626127
    -256040398627605
    -233537985801565
    143735970858490
    -111675149215042
    220151729478730
    222665016192576
    117199437061479
    -52650915654809
    -243387287448591
    109168793218604
    73946250958066
    -271840889957281
    109848558622372
    98622788619439
    220342172617706
    -143835605109308
    157778718256968
    246019557892634
    93459663519333
    -90374562505249
    213484242849341
    216757223917910
    -228550771846930
    -22136827823620
    200094051469227
    20389159326879
    172393519086120
    -23710488044301
    188649152605665
    66608718073907
    -231368521602120
    1789325823379
    179222964233605
    -191047428654028
    -150005439703009
    209745385807543
    -166159680576992
    9724707599918
    219227433645424
    239505129659739
    -76985186477285
    -182826180595917
    99210044436657
    211977398292995
    239961005727739
    -219646099349907
    -271925857921895
    -41422714204467
    37296286346770
    -17419345649180
    210106928965740
    257460426911425
    180888182945594
    -61186824607198
    -242327580930251
    -99444253222266
    33642398161077
    106072500526400
    114871486985064
    -200303911394081
    -140300689105077
    -214896643246234
    -27970560012775
    -15071706050391
    186446266412636
    12339652969021
    123057718591811
    221530845565725
    21394698783594
    -248625497121638
    1963137612084
    180840695898382
    66702036579458
    -151136176917712
    -92465079808279
    153713971642709
    -89985015610267
    81715227501210
    8630611536513
    242835154708429
    -215125284965184
    252160416393774
    -150097574959707
    230753770662030
    -125047799689226
    -183436005514585
    256239938094900
    245401493843386
    -35846638881967
    10914452697363
    86917944380016
    -40614666445001
    167343134630317
    17161558510673
    44404182063001
    -170268936521142
    129061895556987
    253266670402067
    -149251022196644
    276348610977456
    66543698256924
    -273969160519192
    138652693338611
    60948347833900
    -272298367887103
    27806764169680
    -75580765331361
    34187494702615
    179658550044305
    -167366458119018
    -273803837655551
    -20740580032952
    -124731272811424
    79159104152997
    244741198303077
    105445868772675
    84237858101826
    131747900117431
    179629611557152
    265764360320916
    -179042688991183
    -1705661572354
    -76986882637329
    -33153636064663
    -143091528110053
    -227588348182011
    35374002465596
    -80779353829991
    -171018821459245
    -240586721354807
    49766303534409
    223292690976230
    71427307684087
    226346094329404
    -195105977315762
    -18442944458631
    126801051766673
    -267839074199127
    -42205313150975
    169898883873961
    -27414050106657
    -126470869880859
    -9501237105605
    154451653408402
    80689624285937
    -67742639132149
    194479683780812
    -152983747903649
    -102223328675962
    60670099975306
    -188185074080302
    209933802550689
    156473255063832
    55663481061863
    -10460651509887
    109477463235100
    60808839382605
    53374947469770
    -215307373784767
    -54705878912625
    189237982666265
    -63886375022929
    64367142299260
    -707964934027
    -100555607067138
    229954211408365
    -217445291841868
    -219605240464544
    -3189382397788
    -221919854531389
    279636033061176
    226265320350184
    -225204999459232
    -52221662410149
    -122776322575465
    -239654396904499
    281186720268444
    -213313379592685
    -81277912306634
    -250678162239396
    -257515812046696
    164592260543504
    -90762417400303
    -57745635576730
    183772985317107
    -212444204687238
    201650599697020
    140059184306624
    172577669112503
    21524964706603
    143751047263786
    42097984851949
    153876906774027
    34286176905458
    -191226077932858
    57738737709866
    244679412039431
    -94065144040863
    268206296934406
    127070371060307
    -48686194782540
    -279934639366240
    251008465578434
    -54435651345628
    -270491297803257
    197501740593831
    271858679112940
    151496106333055
    -278385536758512
    189468460886742
    165705684111768
    -52619492620414
    163959330512735
    -123856529080021
    151320575592565
    -65819509410931
    -258810254836450
    28466566314854
    261992363750253
    -199974726174974
    213430427225053
    -125206449601416
    248384155530708
    -98385561221601
    150526417111122
    18466085883947
    68037169093246
    -121963222109462
    -32085643606162
    -210603311927611
    151516419117876
    -267135229532709
    -153024855004775
    -156394857678902
    147787123978365
    129727356776116
    -152307240149210
    2740927721521
    -22675829765636
    -251828765208551
    -45670395297719
    9210214072349
    218126494001418
    -173396732636460
    -49886063160684
    -217786901983354
    -269459574799584
    -122111468772527
    32958221109686
    23964729574604
    106711731044258
    39070154530295
    -169854274501693
    -18061086999322
    -41448906901882
    38690981011375
    -200401439587573
    20010134240434
    80853634125325
    149247156030814
    -51886891862414
    28145736341474
    112556284711163
    -167165492698491
    -278074402439648
    -218196875749302
    -79174549451026
    204761062741138
    116773866169899
    -272005151711765
    -87883694658153
    -91676544063683
    169197804641022
    -237171277926744
    -240377321123202
    -255155010947280
    -263782055735427
    -81051244077234
    242587922725906
    278273836711536
    40443258273387
    -14095003295264
    -178712732163602
    -146559758378876
    28442053327063
    66009834637262
    214480328691056
    -101925131868031
    -215531412567940
    -51432089511746
    -189939334315715
    103354088754679
    -228587311641128
    -50040873732919
    -101735754220766
    152444494889842
    -249513869993788
    -224207841049869
    -213413298322044
    12909900242188
    -14666247314082
    -197229941156475
    125312106995609
    182964352058127
    94100032591357
    168176538487915
    -247493167738050
    78257819115884
    130583789178666
    -176095255301884
    -168486288511026
    114826800199529
    -28759237921038
    101482924075181
    9401169751872
    169105539340507
    -280398128777785
    -164607441831516
    94533345776948
    -98317988902901
    81677618663028
    -66280096869115
    -85886420108676
    -272821273291732
    90158138360869
    172696567964124
    -48220869651303
    78425702059499
    193027112563308
    -138378731982822
    -95719536282349
    -136980577682392
    205965209210946
    -225744819710331
    94668118479229
    -35203641337274
    159594545514697
    208643637526028
    -193355384782449
    86659643633478
    -250744048841534
    -156242818789712
    264050616591293
    -100999875539928
    -48883051851207
    -207535362989074
    86410107045530
    -149408105928600
    100668075019190
    -196413503987805
    106541846653332
    -46872119883289
    1190870473250
    206430638434537
    2574085388888
    -76258821629465
    158890441368327
    -93192418347307
    14368820255998
    -133315612780203
    -220169092193958
    200061288573872
    -84281445393427
    137581307566824
    137626546251194
    -1427506367919
    -148588286539338
    -146261655606158
    -281141042687945
    63702997305445
    -40853933992612
    275396930224050
    -164986293667021
    40705173823157
    52909450056251
    144084864606617
    1710527690603
    276717209014984
    10041363400671
    -195557956430997
    -32410707492555
    -29553660297982
    -46850683571484
    -241463461396845
    -237594676965110
    23274665623701
    118776192142093
    3631444443162
    -196136790545244
    221070440251146
    25261204887533
    199731663119179
    -254082590216361
    -21804231767056
    91811960751294
    206197555217501
    127660709127473
    22499963926020
    30150925850316
    -123566594912608
    -183381621240800
    26564164912293
    42266786716897
    243062463173408
    185516257948033
    -204648675742712
    -37557234474411
    107183525259180
    167227375056600
    198175673197092
    272425945653239
    87619582595526
    -238945250199566
    -143068612657556
    215312803903620
    -263270500042741
    72056282917834
    12928266111405
    -225032245461351
    184323709757011
    -259117742471126
    225846509776071
    -90449076740708
    161159217189472
    123671311984905
    -33272238789663
    -106093105869947
    219818564494949
    16929161877100
    161108496490123
    -103899076180966
    117938873993576
    -184086406323594
    123708622939878
    -130425686925150
    240783521627639
    -18609095500420
    83029049269179
    176601204006116
    -91999263876004
    407956432686
    -130561732863582
    206252322133438
    12835517297151
    73764585234248
    -92307742694435
    -188003881042266
    -40499054098475
    243665618823646
    71185468232155
    -41621310795783
    -257842806273075
    -204233327364421
    225814469459386
    116226542348997
    39712928667488
    196925525418544
    236810915596652
    45800903916268
    -135815372637456
    -90302190712874
    -221317839920715
    120755678792984
    -270259162272646
    44912818942646
    -77717916126199
    49029962153253
    -136432351159370
    88446630500451
    43544423695288
    -215100139541857
    -46239087563289
    270095296762892
    203320483479434
    223743016986286
    190333820149097
    84331319373524
    232021823936951
    102903180443865
    183579356219602
    138256122232759
    176897270437797
    226302130986571
    -207257868606859
    -165856070931810
    156582684499300
    -203455364631023
    -213899975863792
    168206082176718
    174175427219302
    168572017935552
    33230400127406
    -187570321089489
    41841518618478
    -170771755332738
    -79326906486775
    276474935381453
    -39527403926534
    -70017768072069
    -21570435122793
    72363200462982
    -263039442294050
    166029502982362
    -220812332117875
    -85334119112918
    -167529129059419
    108583877214341
    55314958145641
    227615537306281
    99868178592246
    -44777776798931
    -198504000665130
    -42476076606220
    -4851420136282
    -145341681618868
    -120356523893055
    -14047559499567
    -209146917883846
    -20276259652500
    -134196180588314
    141803643799607
    -227665304095121
    148276102669988
    187038111919803
    162528130641211
    81590329636605
    -69170532396988
    69906857553378
    53305000456947
    -279758061649545
    220085766831562
    -234145313366858
    -258803388940711
    -245366444358472
    -169563284896805
    -33153703374985
    250161692355443
    200109462603072
    -105451883799853
    156637813226791
    172847895325366
    -154449427199413
    -268951258161069
    -50472218658723
    -17866587015643
    212859719549321
    137819672936665
    -198767362969398
    -65844333446380
    135778343104853
    -198744781308447
    167086195173931
    113166708394284
    268565144580190
    162393753795025
    170945536398025
    -177952429057869
    182038443433283
    -1490654976488
    -83249084826918
    -97740002693685
    147620897628442
    257483987152488
    13412960615565
    -163176459332005
    -50324745535937
    68967763683740
    -225848376678172
    -141258271534903
    11109915301731
    169552522466167
    -167159759130682
    -69408710318894
    49547666812911
    -31109821958188
    45350254490920
    -41503508294622
    -27701764464359
    66171521024137
    221647494114475
    -167443240313356
    -39565324433702
    20003060648387
    -252635015278277
    90405248197681
    -130302336631318
    252673403983078
    -100306686775963
    -17578841731007
    -272231959335834
    -176098119612117
    -90832619848858
    -89682998610491
    -19439460631789
    232769228053005
    101828788419794
    -121162499766791
    -186909742161797
    278149304052630
    -6139544525658
    -129149480455358
    -171375701949036
    -219293620089996
    178279193319009
    -57763440640364
    193640172527529
    -268038122330359
    -94529777809625
    57921847502706
    -53898775584222
    91761595795124
    45623783579673
    121865706780855
    104990646577998
    78838334501365
    -27791022297293
    -260810087103926
    -242031914951693
    -169514831868290
    149127027710580
    -177958354899101
    61932719812468
    113561888259076
    -15879008081065
    226821193930990
    153732136839743
    60038389826316
    248885012213304
    -202766796020193
    -240500804085003
    54817517344076
    -71722139863390
    -202080701754116
    2925408072153
    218576138579921
    9257996522399
    83296177013350
    -69074733953527
    -56946324557156
    -30042057643454
    -59382389617890
    -207669841567387
    122005253281360
    138092537224283
    -52454342898849
    -159981566994119
    186118753412159
    -65182738473567
    -67763857039564
    145794997215491
    52276879333888
    -15644540686818
    -11773607016189
    -264839695128322
    -68893489861868
    207848347205300
    -37044575002448
    -116047937378624
    126979071708230
    204406766813312
    -191709334576698
    2580634937449
    -99557947138250
    8168579042410
    98975473480917
    -259546675334730
    -66396653038898
    264672699856268
    280144906011619
    -196102225153615
    -238380228494248
    63202166038497
    121921788269085
    200529938740189
    -101625956523736
    -195665376841569
    -134775388902863
    -88639656161953
    -247727264270197
    -147676384411500
    118065464918321
    281152683952815
    -195294952855223
    53487526404604
    259391885040670
    17924099540357
    -277100721292706
    -143417701273445
    251470925891391
    149607873138859
    276168329598549
    -275778559531371
    59424522637875
    57915688817410
    -196771835847599
    -12513939130841
    49627594845017
    277253766982298
    -120694142246329
    -239988032188285
    -116730898372108
    -259472240354992
    208542849628664
    205030131474616
    48847104999168
    144043911293847
    45144385307850
    232471932355542
    155707176385253
    39132168112620
    108354233502826
    -242802876977581
    -233457261996293
    270408120717692
    -261477884176532
    -232390956496855
    78042960552692
    261234366496589
    274932252999628
    -183616351160548
    -260663722917141
    87322893290665
    -177744771571100
    -159191369247123
    -220275248622607
    -76166517733233
    -23105501143472
    208704470986078
    -110051564353193
    -76289101182319
    227280540369344
    -213084491466983
    -274640611220738
    100414435798936
    34491414639983
    -61586928049325
    -73215857944601
    -94700377303385
    -139485687109255
    -23276348485013
    125168470212999
    -17537377624294
    -212230046072137
    -71232688783275
    -121364230920961
    -211739469444640
    -37902400165184
    -190960732376214
    -18315204295306
    209335464938619
    -76313853999364
    -92025457118542
    28484325762244
    218464399009951
    -40097344281981
    -210471739501510
    187761112104643
    -159801522127594
    165363566514472
    -260649689777783
    47997154911489
    -215309629066127
    181631371802476
    -259918484140150
    175781608352691
    -223603858485907
    228692660389405
    -16419490850071
    -131464596488066
    118733937116584
    -247360790123633
    66894796184399
    28541608806510
    -186640741514130
    -174156790604101
    259007394125006
    -21715643241971
    266294648323191
    -24743441932232
    -63535724170703
    -53585593231523
    -150218535868602
    -17124973443490
    212090158567986
    -236723595348878
    140889772059601
    -7508363872743
    -248173028277415
    67963423382465
    -17702251347681
    125512454249673
    -3658728940754
    190726751648146
    192847219097216
    1689566786990
    252808193769965
    120503210867060
    -193772792091559
    -159989635724277
    65823564941276
    149388720930216
    41148726042134
    277227635549019
    -274784395021278
    110679918722823
    -267797135517553
    -119817978266007
    229718114645521
    -116108742157737
    -161199143005959
    179022737942630
    -260846790188982
    94259261428506
    172359415198977
    -41221281548822
    -192855403548110
    -53176249388280
    159484519149071
    118177307274212
    -276606463757130
    -40568391985093
    -194597365946215
    -83795410706311
    -164345226159611
    -83634005130421
    -61951006892253
    -265912884862995
    138131909657375
    182297364829608
    -270674649972753
    -18434359931934
    -24797595617599
    145052035402358
    -125824761193332
    -168355624305893
    118743548108200
    105340392022264
    -217864965728708
    30635280011399
    88215220681307
    239094976554702
    -70245120039368
    -8221376652718
    -116082876749179
    198892212984613
    -177207628665703
}
Power of Attack (with # of attackers) = { 
    0.02
    0.35
    0.75
    0.85
    0.95
    0.97
    0.98
    0.99
}
Pseudo-Legal Move 1 = { 
    0217
    0219
    0722
    0724
    0917
    0925
    1018
    1026
    1119
    1127
    1220
    1228
    1321
    1329
    1422
    1430
    1523
    1531
    1624
    1632
}
Pseudo-Legal Move 2 = { 
    4941
    4933
    5042
    5034
    5143
    5135
    5244
    5236
    5345
    5337
    5446
    5438
    5547
    5539
    5648
    5640
    5843
    5841
    6348
    6346
}
Pseudo-Legal Moves Opposing Attacking = { 
    42
    41
    43
    42
    44
    43
    45
    44
    46
    45
    47
    46
    48
    47
    58
    49
    52
    43
    41
    52
    50
    61
    53
    52
    51
    59
    62
    54
    53
    52
    60
    55
    53
    48
    46
    53
    56
    63
}
Pseudo-Legal Moves We Attack = { 
    2
    9
    17
    19
    12
    10
    12
    5
    3
    11
    12
    13
    6
    4
    12
    13
    14
    13
    15
    13
    22
    24
    7
    16
    18
    17
    19
    18
    20
    19
    21
    20
    22
    21
    23
    22
    24
    23
}
PSQTs fast read list = { }
PutsInCheck? = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
QuickSort Part Stack = { }
Real Moves Index at Depth = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
Real Search Depth For Move = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
S3 Performance Depth = { 
    2
    2
    3
    3
    3
}
saved board state (book finder) = { 
    -500
    -320
    -330
    -900
    -99999
    -330
    -320
    -500
    -100
    -100
    -100
    -100
    -100
    -100
    -100
    -100
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    100
    100
    100
    100
    100
    100
    100
    100
    
    500
    320
    330
    900
    99999
    330
    320
    500
}
Scaled Piece Value = { 
    62
    390.5
    412.5
    638
    1269
    4332211
}
Scaled Piece Value (Endgame) = { 
    103
    427
    457.5
    690
    1341
    4332211
}
ScoreTypes = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
side to move attack square piece square (move gen) = { 
    00
    01
    04
    05
    04
    05
    08
    00
    01
    03
    04
    02
    04
    05
    06
    08
    02
    09
    02
    11
    12
    07
    14
    07
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
}
side to move attack square piece square 2 (move gen) = { 
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    03
    05
    00
    00
    00
    10
    11
    10
    13
    14
    13
    16
    15
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
    00
}
slider on queen threat black (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
slider on queen threat white (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
sourcePiece = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
SquaresToBeCoveredForCheck = { }
Squares Until End Of Board 1 = { 
    7
    6
    5
    4
    3
    2
    1
    0
    7
    6
    5
    4
    3
    2
    1
    0
    7
    6
    5
    4
    3
    2
    1
    0
    7
    6
    5
    4
    3
    2
    1
    0
    7
    6
    5
    4
    3
    2
    1
    0
    7
    6
    5
    4
    3
    2
    1
    0
    7
    6
    5
    4
    3
    2
    1
    0
    7
    6
    5
    4
    3
    2
    1
    0
}
Squares Until End Of Board 2 = { 
    0
    0
    0
    0
    0
    0
    0
    0
    1
    1
    1
    1
    1
    1
    1
    0
    2
    2
    2
    2
    2
    2
    1
    0
    3
    3
    3
    3
    3
    2
    1
    0
    4
    4
    4
    4
    3
    2
    1
    0
    5
    5
    5
    4
    3
    2
    1
    0
    6
    6
    5
    4
    3
    2
    1
    0
    7
    6
    5
    4
    3
    2
    1
    0
}
Squares Until End Of Board 3 = { 
    0
    0
    0
    0
    0
    0
    0
    0
    1
    1
    1
    1
    1
    1
    1
    1
    2
    2
    2
    2
    2
    2
    2
    2
    3
    3
    3
    3
    3
    3
    3
    3
    4
    4
    4
    4
    4
    4
    4
    4
    5
    5
    5
    5
    5
    5
    5
    5
    6
    6
    6
    6
    6
    6
    6
    6
    7
    7
    7
    7
    7
    7
    7
    7
}
Squares Until End Of Board 4 = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    1
    1
    1
    1
    1
    1
    1
    0
    1
    2
    2
    2
    2
    2
    2
    0
    1
    2
    3
    3
    3
    3
    3
    0
    1
    2
    3
    4
    4
    4
    4
    0
    1
    2
    3
    4
    5
    5
    5
    0
    1
    2
    3
    4
    5
    6
    6
    0
    1
    2
    3
    4
    5
    6
    7
}
Squares Until End Of Board 5 = { 
    0
    1
    2
    3
    4
    5
    6
    7
    0
    1
    2
    3
    4
    5
    6
    7
    0
    1
    2
    3
    4
    5
    6
    7
    0
    1
    2
    3
    4
    5
    6
    7
    0
    1
    2
    3
    4
    5
    6
    7
    0
    1
    2
    3
    4
    5
    6
    7
    0
    1
    2
    3
    4
    5
    6
    7
    0
    1
    2
    3
    4
    5
    6
    7
}
Squares Until End Of Board 6 = { 
    0
    1
    2
    3
    4
    5
    6
    7
    0
    1
    2
    3
    4
    5
    6
    6
    0
    1
    2
    3
    4
    5
    5
    5
    0
    1
    2
    3
    4
    4
    4
    4
    0
    1
    2
    3
    3
    3
    3
    3
    0
    1
    2
    2
    2
    2
    2
    2
    0
    1
    1
    1
    1
    1
    1
    1
    0
    0
    0
    0
    0
    0
    0
    0
}
Squares Until End Of Board 7 = { 
    7
    7
    7
    7
    7
    7
    7
    7
    6
    6
    6
    6
    6
    6
    6
    6
    5
    5
    5
    5
    5
    5
    5
    5
    4
    4
    4
    4
    4
    4
    4
    4
    3
    3
    3
    3
    3
    3
    3
    3
    2
    2
    2
    2
    2
    2
    2
    2
    1
    1
    1
    1
    1
    1
    1
    1
    0
    0
    0
    0
    0
    0
    0
    0
}
Squares Until End Of Board 8 = { 
    7
    6
    5
    4
    3
    2
    1
    0
    6
    6
    5
    4
    3
    2
    1
    0
    5
    5
    5
    4
    3
    2
    1
    0
    4
    4
    4
    4
    3
    2
    1
    0
    3
    3
    3
    3
    3
    2
    1
    0
    2
    2
    2
    2
    2
    2
    1
    0
    1
    1
    1
    1
    1
    1
    1
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
Squares With Pieces (Eval) = { 
    1
    2
    3
    4
    5
    6
    7
    8
    57
    58
    59
    60
    61
    62
    63
    64
}
Squares With Rooks (eval) = { 
    1
    8
    57
    64
}
Stand-Pat = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
StartsInCheck? = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
STATIC EVAL AT DEPTH = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
targetPieces = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
TTentryUsed (line) = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
TTentryUsed? = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
TTnodeAge = { }
TTnodeBestMove = { }
TTnodeBoardAttacked = { }
TTnodeBoardAttackedSource = { }
TTnodeBoardAttackedSource2 = { }
TTnodeDepth = { }
TTnodeHash = { }
TTnodeHorizon = { }
TTnodeLine = { }
TTnodeMaxDepth = { }
TTnodeQSstartDepth = { }
TTnodeScore = { }
TTnodeType = { }
TTread Horizon at Depth = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
TTread Node Type at Depth = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
TTread Score at Depth = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
WD_distance_to_closest_edge = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    1
    1
    1
    1
    1
    1
    0
    0
    1
    2
    2
    2
    2
    1
    0
    0
    1
    2
    3
    3
    2
    1
    0
    0
    1
    2
    3
    3
    2
    1
    0
    0
    1
    2
    2
    2
    2
    1
    0
    0
    1
    1
    1
    1
    1
    1
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
WD_NNUE_AccInWeightsGradientsHelper = { }
WD_NNUE_PrevRefreshBoard = { 
    -500
    -320
    -330
    -900
    -99999
    -330
    -320
    -500
    -100
    -100
    -100
    -100
    -100
    -100
    -100
    -100
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    100
    100
    100
    100
    100
    100
    100
    100
    500
    320
    330
    900
    99999
    330
    320
    500
}
white area counter (eval) = { }
White Attacks (eval) = { }
White Attacks Source (eval) = { }
White Checks Source (eval) = { }
white king flank (eval) = { 
    0
    0
    1
    1
    1
    1
    0
    0
}
White King Ring (eval) = { }
White Passers on File (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
}
whitePawn(ForEval) = { 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    1
    1
    1
    1
    1
    1
    1
    1
    
    
    
    
    
    
    
    
}
White Pawn Attacks Square (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    1
    2
    2
    2
    2
    2
    2
    1
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
WhitePawnMovementEquivalent = { 
    3
    2
    4
    3
}
White Pawn Movement Table = { }
White PST to Black PST (Vert Refl) = { 
    57
    58
    59
    60
    61
    62
    63
    64
    49
    50
    51
    52
    53
    54
    55
    56
    41
    42
    43
    44
    45
    46
    47
    48
    33
    34
    35
    36
    37
    38
    39
    40
    25
    26
    27
    28
    29
    30
    31
    32
    17
    18
    19
    20
    21
    22
    23
    24
    9
    10
    11
    12
    13
    14
    15
    16
    1
    2
    3
    4
    5
    6
    7
    8
}
White queen attacks on square (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    1
    1
    1
    0
    0
    0
    0
    0
    1
    0
    1
    0
    0
    0
}
White Queen Check Possible? (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
White Queen Threat Squares (eval) = { }
White Queen Threat Squares Source (eval) = { }
White Rook Check Possible? (eval) = { 
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
    0
}
White Rooks on File = { 
    1
    0
    0
    0
    0
    0
    0
    1
}
_BishopPieceSquares = { 
    25
    2.5
    4
    12
    12
    4
    2.5
    25
    7.5
    -4
    -10
    -2.5
    -2.5
    -10
    -4
    7.5
    3.5
    -11.5
    2.5
    -8.5
    -8.5
    2.5
    -10
    17.5
    3.5
    -5
    -12.5
    -20
    -20
    -12.5
    -5
    3.5
    15
    -15
    -5
    -15
    -15
    -5
    -15
    6
    10
    -3
    -1
    -5
    -5
    -15
    -3
    8
    30
    10
    -2.5
    0
    0
    -2.5
    10
    30
    60
    10
    30
    30
    30
    30
    10
    60
}
_BishopPieceSquares(End) = { 
    25
    20
    20
    6
    6
    18.5
    20
    25
    18
    5
    7.5
    -0.5
    -0.5
    7.5
    6.5
    30
    8
    1.5
    0.5
    -5
    -5
    2.5
    2.5
    15
    5
    3
    -2.5
    -10
    -10
    0
    2.5
    5
    9
    2.5
    7.5
    -7.5
    -7.5
    2.5
    2.5
    9
    15
    -5
    -2.5
    2.5
    2.5
    -2.5
    -5
    15
    25
    12.5
    5
    -0.5
    -0.5
    5
    12.5
    25
    25
    20
    18.5
    12.5
    12.5
    18.5
    20
    25
}
_Endgame Passed Pawn Bonus = { 
    
    130
    85
    30
    20
    12.5
    10
    
}
_KingPieceSquares(End) = { 
    0
    -20
    -42.5
    -37.5
    -37.5
    -42.5
    -22.5
    0
    -25
    -50
    -67.5
    -67.5
    -67.5
    -67.5
    -50
    -25
    -44
    -67.5
    -85
    -87.5
    -87.5
    -85
    -67.5
    -44
    -50
    -80
    -85
    -85
    -85
    -85
    -80
    -50
    -50
    -82.5
    -100
    -100
    -100
    -100
    -82.5
    -50
    -45
    -87.5
    -90
    -95
    -95
    -90
    -87.5
    -45
    -25
    -60
    -60
    -65
    -65
    -60
    -60
    -25
    -5
    -30
    -35
    -40
    -40
    -35
    -30
    -5
}
_KingPieceSquares(Middle) = { 
    -100
    -162.5
    -135
    -100
    -100
    -135
    -162.5
    -135
    -20
    -75
    -95
    -90
    -90
    -105
    -150
    -140
    -85
    -125
    -85
    -25
    -25
    20
    -120
    -90
    -50
    -50
    30
    -40
    -40
    -65
    -50
    -50
    -75
    -75
    40
    50
    50
    40
    -75
    -75
    30
    40
    40
    50
    50
    40
    40
    30
    30
    40
    40
    50
    50
    40
    40
    30
    30
    40
    40
    50
    50
    40
    40
    30
}
_KnightPieceSquare = { 
    50
    45
    30
    35
    35
    30
    45
    50
    40
    20
    15
    7.5
    7.5
    5
    20
    38.5
    30
    8.5
    -5
    -6
    -6
    -3
    8.5
    35
    17.5
    -12.5
    -20
    -25
    -25
    -20
    -4
    17.5
    15
    -6.5
    -22
    -25
    -25
    -22
    -6.5
    15
    30
    -17.5
    -30
    -27.5
    -27.5
    -30
    -17.5
    4.5
    32.5
    20
    -2
    -10
    -10
    -55
    40
    40
    75
    40
    27.5
    40
    40
    27.5
    40
    75
}
_KnightPieceSquares (End) = { 
    60
    32.5
    32.5
    10
    10
    32.5
    35
    60
    45
    25
    10
    -5
    -5
    10
    25
    45
    20
    10
    4
    -14.5
    -14.5
    4
    12
    20
    15
    -2.5
    -7
    -14
    -14
    -7.5
    -2.5
    7.5
    15
    5
    -5
    -20
    -20
    -5
    5
    15
    25
    10
    -8
    -10
    -10
    8
    10
    25
    35
    25
    25
    5
    5
    10
    27.5
    35
    60
    45
    30
    9
    9
    30
    45
    60
}
_Minor Threat eg = { 
    15
    20
    30
    60
    80
}
_Minor Threat mg = { 
    2.5
    30
    37
    45
    40
}
_Passed Pawn Bonus = { 
    
    105
    75
    30
    12.5
    5
    5
    
}
_PawnPieceSquare = { 
    
    
    
    
    
    
    
    
    -1.5
    -1.5
    -5
    -10
    -7.5
    -10
    -3.5
    2.5
    4.5
    7.5
    -5.5
    -7.5
    -15
    -11
    -2.5
    11
    2
    12.5
    -2.5
    -10
    -20
    -8
    -2.5
    4
    -7.5
    -5
    6.5
    -1
    -7.5
    1
    12.5
    -5
    -10
    -10
    -12.5
    -11
    -11
    -12.5
    -10
    -10
    -10
    -10
    -10
    -10
    -10
    -10
    -10
    -10
    
    
    
    
    
    
    
    
}
_PawnPieceSquare(End) = { 
    
    
    
    
    
    
    
    
    5
    2.5
    -5
    -2.5
    -7
    -3.5
    2.5
    10
    5
    5
    5
    -2
    -2
    -1.5
    2.5
    5
    3
    1
    4
    2.5
    6.5
    6
    5
    5
    -5
    -7.5
    -1.5
    2.5
    2.5
    2.5
    -7
    -5
    -10
    -3
    -10
    -10
    -10
    -5
    -3
    -10
    -2.5
    -20
    -6
    -15
    -15
    -6
    -20
    -2.5
    
    
    
    
    
    
    
    
}
_Queen Piece Squares = { 
    5
    5
    2.5
    -2
    -1.5
    2.5
    5
    -1.5
    10
    -2.5
    -4
    -6
    -6
    -1
    -2.5
    2.5
    1.5
    -3
    -5
    -2.5
    -2.5
    -6.5
    -3
    2.5
    -2.5
    20
    -4
    -4
    -4
    5
    2.5
    20
    1.5
    20
    -5
    -3.5
    -3.5
    -5
    2.5
    0
    10
    10
    -5
    -4
    -4
    -5
    -25
    2
    2.5
    -3
    5
    -4
    -4
    -5
    -22.5
    10
    1
    10
    10
    -5
    -20
    10
    10
    -20
}
_QueenPieceSquares(End) = { 
    35
    27.5
    25
    12.5
    12.5
    25
    27.5
    35
    22.5
    15
    11
    2
    2
    11
    15
    25
    20
    9
    5
    -2.5
    -2.5
    5
    9
    20
    10.5
    2
    -6.5
    -12
    -12
    -6.5
    2
    -10
    15
    3
    -4.5
    -10
    -10
    -4.5
    3
    15
    9
    6
    6
    -2
    -2
    6
    9
    20
    25
    12
    11
    4
    4
    11
    12
    25
    35
    25
    20
    15
    15
    20
    25
    35
}
_RookPieceSquares = { 
    16.5
    10
    7
    2.5
    2.5
    7
    10
    16
    11
    7
    4
    -2.5
    -2.5
    5
    6.5
    10
    12.5
    5
    2.5
    -2
    -2
    2.5
    5
    12.5
    5
    2.5
    2
    3
    3
    2
    2.5
    5
    2.5
    7.5
    2
    -2.5
    -2.5
    2
    7.5
    14
    10
    2
    -2.5
    -6.5
    -6.5
    -2.5
    1
    10
    1
    -6
    -8
    -9
    -9
    -8
    -6
    1
    8.5
    9
    0
    -5
    -5
    0
    9
    8
}
_RookPieceSquares(Endgame) = { 
    4.5
    7.5
    5
    3.5
    3.5
    5
    7.5
    4.5
    6
    4.5
    1
    2
    2
    0
    10
    20
    -1.5
    2.5
    2.5
    3.5
    3.5
    2.5
    2.5
    -2.5
    2.5
    
    5
    7.5
    7.5
    5
    
    2.5
    2.5
    -2.5
    -4
    2.5
    2.5
    -3.5
    -5
    2.5
    -5
    -0.5
    3.5
    -5
    -5
    3.5
    -0.5
    -5
    -2.5
    -2.5
    -12.5
    2.5
    2.5
    -10
    -2.5
    -2.5
    -10
    -2.5
    -20
    -7.5
    -7.5
    -20
    -2.5
    -10
}
_Rook Threat eg = { 
    24
    34
    30
    20
    20
}
_Rook Threat mg = { 
    1.5
    20
    20
    0
    30
}
__Bishop Mobility Bonus = { 
    -24
    -10
    8
    13
    19
    26
    27.5
    32.5
    32.5
    35
    42.5
    45
    45
    45
}
__Bishop Mobility Bonus End = { 
    -30
    -12
    -2
    6
    12
    21
    27
    29
    32
    36
    39
    43
    44
    50
}
__Knight Mobility Bonus = { 
    -32
    -26.5
    -6
    -2
    1.5
    6.5
    11
    14
    16.5
}
__Knight Mobility Bonus End = { 
    -40
    -27
    -15
    -8
    2.5
    5
    9
    10
    12.5
}
__Queen Mobility Bonus = { 
    -15
    -6
    -4
    -4
    10
    12
    12
    17.5
    20
    26
    32
    32
    33
    34
    35
    35
    36
    36
    38
    40
    46
    54
    54
    55
    57
    57
    58
}
__Queen Mobility Bonus End = { 
    -25
    -15
    -2.5
    10
    20
    27
    30
    37.5
    40
    48
    48
    50
    60
    64
    65
    67
    68
    70
    75
    75
    84
    84
    85
    90
    90
    95
    110
}
__Rook Mobility Bonus = { 
    -30
    -10
    1
    1.5
    1.5
    5
    10
    15.5
    19.5
    19.5
    20
    24
    26
    28
    30
}
__Rook Mobility Bonus End = { 
    -40
    -10
    12
    20
    35
    50
    55
    60
    65
    70
    80
    82.5
    84
    85
    86
}


//----- Green flag events ---------------------------------------------------------------------------------------------

WhenGreenFlagClicked()
{
    Call // comment("clear the TT first to try to avoid crashes");
    Call clear TT table with size:(0);
    Looks.Hide();
    WD_best move = 0000;
    Event.BroadcastAndWait("refresh eval bar");
    Call InitHashLookup;
    If (Sensing.Of(x position, WD project detector) == 100)
    {
        WD_DELTA_CI MODE ACTIVE? = 0;
    }
    Else
    {
        WD_DELTA_CI MODE ACTIVE? = 1;
    }
    PV_uci_format_total_res = "";
    Performance Mode: = "???";
    S_UCI MODE ON? = 0;
    Depth of Search = "0+all";
    ALLOW HCE FOR LATE ENDGAMES (NN MODE) = 1;
    ALLOW BOOK IN NN MODE? = 1;
    BLACK CONTEMPT VALUE = -15;
    WHITE CONTEMPT VALUE = 15;
    LAZY EVAL MARGIN = 50;
    SELF PLAY? = 0;
    BOARD X OFFSET = -80;
    USE NN FOR EVAL? = 0;
    Variable.Show(PV_uci_format_total_res);
    Variable.Show(Depth of Search);
    Variable.Show(LOADING PERCENTAGE);
    Call reset general project data;
    Call make board;
    Call make board's data;
    Call init file & rank from square index & zeros before single digit numbers;
    Call initialize squares until end of board;
    Call initialize engine with max real depth:(30) reset all data?(1);
    Call initialize distance to center & distance to square;
    Call set progress with a:(1) over b:(1);
    Call init black pawns movement table;
    Call init white pawns movement table;
    Call init knight movement table;
    Call init dir from square to square;
    Call init piece type to id;
    Call init map white pst to black pst;
    Call reset repetition table;
    Call init piece type to attacking king chunk;
    Call init massive list to verify checks;
    Call init piece to NN input type;
    Call init fast pst reading;
    Call init closest distance to edge with square;
    Call clear TT table with size:(0);
    Event.Broadcast("end of engine calcs");
    loaded custom FEN? = 0;
    Imported FEN Code: = "";
    Call load FEN:("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
    Call init WD_NNUE info;
    Call reset start data for search;
    Event.Broadcast("update board (visual)");
    If (Sensing.Of(x position, WD project detector) == 100)
    {
        Call // comment("in full project");
        Sensing.Ask("Play White or Black? (w/b)");
        PLAYER COLOR = Sensing.Answer();
        If (Not (((Sensing.Answer() == "w") Or (Sensing.Answer() == "b"))))
        {
            PLAYER COLOR = "w";
        }
    }
    Else
    {
        PLAYER COLOR = "w";
    }
    If (PLAYER COLOR == "w")
    {
        CPU COLOR = "b";
    }
    Else
    {
        CPU COLOR = "w";
    }
    If ((Sensing.Answer() == "delta_ci") Or (Not ((Sensing.Of(x position, WD project detector) == 100))))
    {
        Call // comment("once you export this sprite for use in a Delta_ci framework, the second condition will be true, automatically running this");
        Event.BroadcastAndWait("WD_DeltaCI MODE SETUP");
    }
    If (Sensing.Answer() == "uci")
    {
        S_UCI MODE ON? = 1;
    }
    Else
    {
        S_UCI MODE ON? = 0;
    }
    Call update CPU contempt value;
    Event.Broadcast("update user color display");
    Performance Mode: = 1;
    Performance Settings: = Operator.Join("Mode: ", Performance Mode:);
    Event.BroadcastAndWait("update perf mode display");
    USE NN FOR EVAL? = 0;
    minmax time exhausted? = 0;
    Event.BroadcastAndWait("update board (visual)");
    Event.Broadcast("loaded settings");
    BOARD EVAL = "???";
    If is compiled?
    {
        WD_TT_size = 2000000;
    }
    Else
    {
        WD_TT_size = 200000;
    }
    Call clear TT table with size:(WD_TT_size);
    LOADING A = 0;
    LOADING B = 20;
    Event.BroadcastAndWait("update progress bar");
    Event.BroadcastAndWait("hide best move indicator");
    If (USE NN FOR EVAL? == 1)
    {
        WD_UCI register name = "Black Crow v8.29";
    }
    Else
    {
        WD_UCI register name = "White Dove v8.29";
    }
    length of other uci engine uci out = 0;
    If (WD_DELTA_CI MODE ACTIVE? == 1)
    {
        Call ​​log​​("WD: delta_ci mode active, ready, waiting for move...");
    }
    Else
    {
        If (Not ((S_UCI MODE ON? == 1)))
        {
            List.DeleteAll(UCI_Control_In);
            List.DeleteAll(UCI_Control_Out);
            List.DeleteAll(UCI_Engine1_In);
            List.DeleteAll(UCI_Engine1_Out);
            List.DeleteAll(UCI_Engine2_In);
            List.DeleteAll(UCI_Engine2_Out);
            If (Not ((NN TRAIN MODE ON? == 1)))
            {
                If (Who To Move? (WD) == PLAYER COLOR)
                {
                    Event.Broadcast("PLAYER MOVE");
                }
                Else
                {
                    Event.Broadcast("CPU MOVE");
                }
            }
            Else
            {
                Event.Broadcast("start NN training");
            }
        }
        Else
        {
            Wait Until (UCI_Control_Out[1] == "uci");
            Control.Wait(1);
            List.Add(UCI_Control_In, Operator.Join("id name ", WD_UCI register name));
            Wait Until (List.Length(UCI_Control_Out) == 3);
            If Operator.Contains(UCI_Control_Out[3], WD_UCI register name)
            {
                WD SCRATCH UCI ENGINE # = 2;
                CPU COLOR = "b";
                PLAYER COLOR = "w";
                CPU CONTEMPT VALUE = BLACK CONTEMPT VALUE;
            }
            Else
            {
                WD SCRATCH UCI ENGINE # = 1;
                CPU COLOR = "w";
                PLAYER COLOR = "b";
                CPU CONTEMPT VALUE = WHITE CONTEMPT VALUE;
            }
            Event.Broadcast("wait for turn (Scratch UCI)");
        }
    }
}

WhenGreenFlagClicked()
{
    PAWN SHIELD BONUS = 40;
    NO PAWN SHIELD PENALTY = -2.5;
}


//----- Key pressed events --------------------------------------------------------------------------------------------

WhenKeyPressed(p)
{
    If (board piece ID == 0)
    {
        Variable.Hide(PV_uci_format_total_res);
        Wait Until (Not (Sensing.KeyPressed(p)));
        Wait Until Sensing.KeyPressed(p);
        Variable.Show(PV_uci_format_total_res);
    }
}

WhenKeyPressed(d)
{
    List.Show(FULL GAME DEBUG INFO);
    Wait Until (Not (Sensing.KeyPressed(d)));
    Wait Until Sensing.KeyPressed(d);
    List.Hide(FULL GAME DEBUG INFO);
}

WhenKeyPressed(c)
{
    Repeat Until (Not (Sensing.KeyPressed(c)))
    {
        Event.Broadcast("update board (visual)");
    }
}

WhenKeyPressed(e)
{
    Call log export data;
    List.Show(EXPORT DATA);
    Wait Until (Not (Sensing.KeyPressed(e)));
    Wait Until Sensing.KeyPressed(e);
    List.Hide(EXPORT DATA);
}

WhenKeyPressed(i)
{
    If (board piece ID == 0)
    {
        List.Show(Iterative Deepening DEBUG);
        Wait Until (Not (Sensing.KeyPressed(i)));
        Wait Until Sensing.KeyPressed(i);
        List.Hide(Iterative Deepening DEBUG);
    }
}

WhenKeyPressed(0)
{
    If (board piece ID == 0)
    {
        Call evaluation of current position with depth:(((Who To Move? (WD) == "b") * 1)) force HCE:("") log debug:((1 == 1));
        List.Show(EVAL DEBUG LIST);
        Wait Until (Not (Sensing.KeyPressed(0)));
        Wait Until Sensing.KeyPressed(0);
        List.Hide(EVAL DEBUG LIST);
    }
}

WhenKeyPressed(g)
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    If (1 == 1)
    {
        Call // comment("for debugging move gen");
        List.Show(ALL LEGAL MOVES FOR CPU CALCS);
        Call fast pseudo-legal move gen with depth:(2)((0 == 1))()();
    }
    Else
    {
        Call ​​warn​​("activate movegen debugging tool in "when [g] key pressed" in "Board" sprite");
        List.Hide(ALL LEGAL MOVES FOR CPU CALCS);
    }
}

WhenKeyPressed(l)
{
    If (board piece ID == 0)
    {
        List.Show(PV Res At Depth);
        Wait Until (Not (Sensing.KeyPressed(l)));
        Wait Until Sensing.KeyPressed(l);
        List.Hide(PV Res At Depth);
    }
}


//----- Broadcast received events -------------------------------------------------------------------------------------

WhenBroadcastReceived($white_dove)
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    Call ​​log​​("WD starting delta_ci turn");
    Call ​​log​​(_g board FEN);
    _g engine evaluation = WD_DELTA_CI DISPLAY EVAL;
    _g engine pv = PV_uci_format_total_res;
    Call FEN code reader wrapper:(_g board FEN);
    CPU COLOR = Who To Move? (WD);
    Call ​​log​​(Operator.Join("WD cpu color: ", Who To Move? (WD)));
    If (Who To Move? (WD) == "w")
    {
        PLAYER COLOR = "b";
    }
    Else
    {
        PLAYER COLOR = "w";
    }
    List.Add(_g deltaci, "info white_dove");
    Event.BroadcastAndWait("CPU MOVE");
    If (WD_best move == "stop")
    {
        If (WD_checkmated? == 1)
        {
            List.Add(_g deltaci, "resign");
            Call ​​log​​(best move (DELTA_CI notation));
            Call ​​log​​(WD_best move);
            Call ​​log​​("WD resign");
        }
        Else
        {
            List.Add(_g deltaci, "resign");
            Call ​​log​​(best move (DELTA_CI notation));
            Call ​​log​​(WD_best move);
            Call ​​log​​("WD Stalemate (resign for now...)");
        }
    }
    Else
    {
        If (WD_best move < 100)
        {
            If (WD_best move == BlackKingSideCastle)
            {
                best move (DELTA_CI notation) = Operator.Join("m", "e8g8");
            }
            Else
            {
                If (WD_best move == BlackQueenSideCastle)
                {
                    best move (DELTA_CI notation) = Operator.Join("m", "e8c8");
                }
                Else
                {
                    If (WD_best move == WhiteKingSideCastle)
                    {
                        best move (DELTA_CI notation) = Operator.Join("m", "e1g1");
                    }
                    Else
                    {
                        If (WD_best move == WhiteQueenSideCastle)
                        {
                            best move (DELTA_CI notation) = Operator.Join("m", "e1c1");
                        }
                    }
                }
            }
        }
        Else
        {
            best move (DELTA_CI notation) = Operator.Join("m", Operator.Join(A1 - H8 to #[floor((WD_best move / 100))], A1 - H8 to #[floor((WD_best move % 100))]));
        }
        _g engine evaluation = WD_DELTA_CI DISPLAY EVAL;
        _g engine pv = PV_uci_format_total_res;
        List.Add(_g deltaci, best move (DELTA_CI notation));
        Call ​​log​​(best move (DELTA_CI notation));
        Call ​​log​​(WD_best move);
    }
    Call ​​log​​("WD refreshing gui");
    Event.BroadcastAndWait("gui refresh stats");
    Call ​​log​​("WD ended delta_ci turn");
}

WhenBroadcastReceived(add board hash to game history)
{
    If (board piece ID == 0)
    {
        Call createCurrentBoardHash with depth:(((1 * (Who To Move? (WD) == "b")) + 2));
        List.Add(GAME POSITION HASH, currentBoardHash);
        Call reset repetition table;
    }
}

WhenBroadcastReceived(CPU MOVE)
{
    If (board piece ID == 0)
    {
        SIDE TO MOVE START TIME = Sensing.DaysSince2000();
        Call update CPU contempt value;
        WD_checkmated? = 0;
        PV_uci_format_total_res = "";
        Call get all legal moves from current position depth:(((CPU COLOR == "b") * 1)) is quiet search?:(0) completely legal?(1) generate checks?("");
        If (List.Length(ALL LEGAL MOVES FOR CPU CALCS) == 0)
        {
            If (GameState: == 2)
            {
                WD_checkmated? = 1;
            }
            WD_best move = "stop";
            Stop(this script);
        }
        LOADING PERCENTAGE = "?/?";
        current move (computer) = "????";
        WD_best move = "????";
        WHITE CPU BEST MOVE = "????";
        BOARD EVAL = "????";
        CALC STATE = "THINKING";
        minmax time exhausted? = 0;
        Control.Wait(0.1);
        Call engine search code;
        CALC STATE = "IDLE";
        If (CPU COLOR == "w")
        {
            WD_best move = WHITE CPU BEST MOVE;
        }
        bestMovePiece = Current Board Position[floor((WD_best move / 100))];
        bestMoveTaking = Current Board Position[floor((WD_best move % 100))];
        If (Who To Move? (WD) == "w")
        {
            WHITE CLOCK TIME += TIME CONTROL INCREMENT SECONDS;
            WHITE CLOCK TIME += ((Sensing.DaysSince2000() - SIDE TO MOVE START TIME) * -86400);
            WHITE CLOCK TIME += (-1 * MOVE INPUT LAG TIME);
            WHITE CLOCK TIME DISPLAY = WHITE CLOCK TIME;
        }
        Else
        {
            BLACK CLOCK TIME += TIME CONTROL INCREMENT SECONDS;
            BLACK CLOCK TIME += ((Sensing.DaysSince2000() - SIDE TO MOVE START TIME) * -86400);
            BLACK CLOCK TIME += (-1 * MOVE INPUT LAG TIME);
            BLACK CLOCK TIME DISPLAY = BLACK CLOCK TIME;
        }
        Event.BroadcastAndWait("moving piece (computer)");
        If ((WD_best move < 100) Or ((abs(bestMovePiece) == 100) Or (abs(bestMoveTaking) > 0)))
        {
            LAST NOT REVERSIBLE MOVE = full move counter (WD);
            half move counter = 0;
        }
        Else
        {
            half move counter += 1;
        }
        If (CPU COLOR == "b")
        {
            full move counter (WD) += 1;
        }
        Call log debug data;
        Call log export data;
        If (Who To Move? (WD) == "b")
        {
            Who To Move? (WD) = "w";
        }
        Else
        {
            Who To Move? (WD) = "b";
        }
        Event.BroadcastAndWait("add board hash to game history");
        Event.Broadcast("PLAYER MOVE");
    }
}

WhenBroadcastReceived(force move on real board)
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    If (Not ((S_UCI MODE ON? == 1)))
    {
        Stop(this script);
    }
    Call update actual board with move:(FORCE MOVE ON REAL BOARD) color of moving piece:(FORCE MOVE COLOR ON REAL BOARD);
    If (FORCE MOVE COLOR ON REAL BOARD == "w")
    {
        FORCE MOVE COLOR ON REAL BOARD = "b";
    }
    Else
    {
        FORCE MOVE COLOR ON REAL BOARD = "w";
    }
}

WhenBroadcastReceived(give side to move control)
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    If (CPU COLOR == Who To Move? (WD))
    {
        Event.Broadcast("CPU MOVE");
    }
    Else
    {
        Event.Broadcast("PLAYER MOVE");
    }
}

WhenBroadcastReceived(import board)
{
    isHighlightSquare? = 1;
}

WhenBroadcastReceived(import board)
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    Sensing.Ask("Load FEN Board Position? (blank for no import)");
    If (Not ((Sensing.Answer() == "")))
    {
        Call FEN code reader wrapper:(Sensing.Answer());
    }
}

WhenBroadcastReceived(loaded settings)
{
    If (board piece ID == 0)
    {
        Stop(this script);
    }
    If (USE NN FOR EVAL? == 0)
    {
        Looks.SetEffectTo(BRIGHTNESS, 0);
    }
    Else
    {
        If (Square Color[board piece ID] == "dark")
        {
            Looks.SetEffectTo(BRIGHTNESS, -10);
        }
        Else
        {
            Looks.SetEffectTo(BRIGHTNESS, 0);
        }
    }
}

WhenBroadcastReceived(log export data (broadcast))
{
    If (board piece ID == 0)
    {
        Call log export data;
    }
}

WhenBroadcastReceived(moving piece (computer))
{
    If (Not ((S_UCI MODE ON? == 1)))
    {
        Stop(this script);
    }
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    Call update actual board with move:(WD_best move) color of moving piece:(CPU COLOR);
}

WhenBroadcastReceived(register engine)
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    List.Add(_g engines, "white_dove");
}

WhenBroadcastReceived(update board (visual))
{
    If (WD_DELTA_CI MODE ACTIVE? == 1)
    {
        Control.DeleteThisClone();
    }
    If (board piece ID > 0)
    {
        If (Sensing.TouchingObject(_mouse_) And Sensing.KeyPressed(c))
        {
            Looks.Say(Operator.Join(board piece ID, Operator.Join("  |  ", isHighlightSquare?)));
        }
        Else
        {
            Looks.Say("");
        }
        update board visual last move square = GAME MOVES (SQUARES)[List.Length(GAME MOVES (SQUARES))];
        If (update board visual last move square > 100)
        {
            If ((floor((update board visual last move square / 100)) == board piece ID) Or (floor((update board visual last move square % 100)) == board piece ID))
            {
                isHighlightSquare? = 2;
            }
            Else
            {
                isHighlightSquare? = 1;
            }
        }
        If (((board file + board rank) % 2) == 0)
        {
            Looks.SwitchCostumeTo(Operator.Join("White", isHighlightSquare?));
        }
        Else
        {
            Looks.SwitchCostumeTo(Operator.Join("Green", isHighlightSquare?));
        }
    }
}

WhenBroadcastReceived(updated NN setting)
{
    If (board piece ID == 0)
    {
        If (USE NN FOR EVAL? == 1)
        {
            WD_UCI register name = "Black Crow v8.29";
        }
        Else
        {
            WD_UCI register name = "White Dove v8.29";
        }
        Event.Broadcast("update user color display");
        Event.Broadcast("loaded settings");
        Event.BroadcastAndWait("update board (visual)");
        Event.Broadcast("hide best move indicator");
    }
}

WhenBroadcastReceived(update progress bar internal)
{
    If (board piece ID == 0)
    {
        Event.BroadcastAndWait("update progress bar");
    }
}

WhenBroadcastReceived(wait for turn (Scratch UCI))
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    If (WD SCRATCH UCI ENGINE # == 2)
    {
        Wait Until ((List.Length(UCI_Engine1_Out) > length of other uci engine uci out) And Operator.Contains(UCI_Engine1_Out[List.Length(UCI_Engine1_Out)], "bestmove"));
        length of other uci engine uci out = List.Length(UCI_Engine1_Out);
        Call convert other UCI engine input move to WD format with their output:(UCI_Engine1_Out[List.Length(UCI_Engine1_Out)]);
        Event.Broadcast("force move on real board");
        Wait Until (UCI_Engine2_In[List.Length(UCI_Engine2_In)] == "isready");
        List.Add(UCI_Engine2_Out, "readyok");
        Wait Until (UCI_Engine2_In[List.Length(UCI_Engine2_In)] == "go");
        Event.BroadcastAndWait("CPU MOVE");
        Call convert WD best move to UCI format;
        List.Add(UCI_Engine2_Out, Operator.Join("bestmove ", WD to Scratch UCI Move Res));
    }
    Else
    {
        Wait Until (UCI_Engine1_In[List.Length(UCI_Engine1_In)] == "isready");
        List.Add(UCI_Engine1_Out, "readyok");
        Wait Until (UCI_Engine1_In[List.Length(UCI_Engine1_In)] == "go");
        Event.BroadcastAndWait("CPU MOVE");
        Call convert WD best move to UCI format;
        List.Add(UCI_Engine1_Out, Operator.Join("bestmove ", WD to Scratch UCI Move Res));
        Wait Until ((List.Length(UCI_Engine2_Out) > length of other uci engine uci out) And Operator.Contains(UCI_Engine2_Out[List.Length(UCI_Engine2_Out)], "bestmove"));
        length of other uci engine uci out = List.Length(UCI_Engine2_Out);
        Call convert other UCI engine input move to WD format with their output:(UCI_Engine2_Out[List.Length(UCI_Engine2_Out)]);
        Event.Broadcast("force move on real board");
    }
    Event.Broadcast("wait for turn (Scratch UCI)");
}

WhenBroadcastReceived(WD_clear_large_data)
{
    If (board piece ID == 0)
    {
        Call clear TT table with size:("");
        Call clear large runtime generated data;
    }
}

WhenBroadcastReceived(WD_clear_TT)
{
    If (board piece ID == 0)
    {
        Call clear TT table with size:(WD_TT_size);
    }
}

WhenBroadcastReceived(wd_cli_import_board)
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    If (Not ((WD_cli_import_fen == "")))
    {
        Call FEN code reader wrapper:(WD_cli_import_fen);
    }
    Control.Wait(0.3);
    Event.Broadcast("give side to move control");
}

WhenBroadcastReceived(WD_DeltaCI MODE SETUP)
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    WD_DELTA_CI MODE ACTIVE? = 1;
    Call make board;
    Event.Broadcast("update board (visual)");
    If (Who To Move? (WD) == "w")
    {
        PLAYER COLOR = "b";
        CPU COLOR = "w";
    }
    Else
    {
        PLAYER COLOR = "w";
        CPU COLOR = "b";
    }
}

WhenBroadcastReceived(WD_get_moving_piece_info)
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    List.ReplaceItem(WD_CastlingRights, 2, White CASTLING RIGHTS (DEPTH 0));
    Call get all legal moves from current position depth:(((PLAYER COLOR == "b") * 1)) is quiet search?:(0) completely legal?(1) generate checks?("");
    Call get all legal moves for target player piece:(Moving Piece ID);
    Event.Broadcast("update legal move display");
}

WhenBroadcastReceived(WD_import_rand_960)
{
    If (board piece ID > 0)
    {
        Stop(this script);
    }
    Call FEN code reader wrapper:(WD_CHESS960_FENS[WD_cli_chess960_fen_num]);
    Control.Wait(0.3);
    Event.Broadcast("give side to move control");
}


//----- Start as clone ------------------------------------------------------------------------------------------------

Control.WhenIStartAsClone()
{
    Looks.SetSizeTo(101);
    Looks.Show();
}


//----- Custom blocks -------------------------------------------------------------------------------------------------

Define (bool is compiled?) for compiled block (warp=false)
{
}

Define // comment(string write comment here) (warp=true)
{
}

Define add attack table info the snapshot with depth:(string depth) (warp=true)
{
    current val (board attacked snapshot prep) = "";
    current val 2 (board attacked snapshot prep) = "";
    current val 3 (board attacked snapshot prep) = "";
    counter to add attack table to snapshot = 1;
    Repeat (16)
    {
        current val (board attacked snapshot prep) = Operator.Join(current val (board attacked snapshot prep), Zero Before 1-3 => 4 Digit Num (1 offset)[(((((# side to move attacking square (move gen)[(counter to add attack table to snapshot + 0)] * 1000) + (# side to move attacking square (move gen)[(counter to add attack table to snapshot + 1)] * 100)) + (# side to move attacking square (move gen)[(counter to add attack table to snapshot + 2)] * 10)) + (# side to move attacking square (move gen)[(counter to add attack table to snapshot + 3)] * 1)) + 1)]);
        current val 2 (board attacked snapshot prep) = Operator.Join(current val 2 (board attacked snapshot prep), Zero Before 1-3 => 4 Digit Num (1 offset)[(((side to move attack square piece square (move gen)[(counter to add attack table to snapshot + 0)] * 100) + (side to move attack square piece square (move gen)[(counter to add attack table to snapshot + 1)] * 1)) + 1)]);
        current val 2 (board attacked snapshot prep) = Operator.Join(current val 2 (board attacked snapshot prep), Zero Before 1-3 => 4 Digit Num (1 offset)[(((side to move attack square piece square (move gen)[(counter to add attack table to snapshot + 2)] * 100) + (side to move attack square piece square (move gen)[(counter to add attack table to snapshot + 3)] * 1)) + 1)]);
        current val 3 (board attacked snapshot prep) = Operator.Join(current val 3 (board attacked snapshot prep), Zero Before 1-3 => 4 Digit Num (1 offset)[(((side to move attack square piece square 2 (move gen)[(counter to add attack table to snapshot + 0)] * 100) + (side to move attack square piece square 2 (move gen)[(counter to add attack table to snapshot + 1)] * 1)) + 1)]);
        current val 3 (board attacked snapshot prep) = Operator.Join(current val 3 (board attacked snapshot prep), Zero Before 1-3 => 4 Digit Num (1 offset)[(((side to move attack square piece square 2 (move gen)[(counter to add attack table to snapshot + 2)] * 100) + (side to move attack square piece square 2 (move gen)[(counter to add attack table to snapshot + 3)] * 1)) + 1)]);
        counter to add attack table to snapshot += 4;
    }
    List.ReplaceItem(BoardAttackedBySideToMoveSnapshot, depth, current val (board attacked snapshot prep));
    List.ReplaceItem(BoardAttackedBySideToMovePieceSnapshot, depth, current val 2 (board attacked snapshot prep));
    List.ReplaceItem(BoardAttackedBySideToMovePieceSnapshot 2, depth, current val 3 (board attacked snapshot prep));
}

Define add file to king flank(bool +1?)(string start file) (eval)(bool white?) (warp=true)
{
    If white?
    {
        List.ReplaceItem(white king flank (eval), start file, 1);
        List.ReplaceItem(white king flank (eval), (start file + 1), 1);
        List.ReplaceItem(white king flank (eval), (start file + 2), 1);
        If +1?
        {
            List.ReplaceItem(white king flank (eval), (start file + 3), 1);
        }
    }
    Else
    {
        List.ReplaceItem(black king flank (eval), start file, 1);
        List.ReplaceItem(black king flank (eval), (start file + 1), 1);
        List.ReplaceItem(black king flank (eval), (start file + 2), 1);
        If +1?
        {
            List.ReplaceItem(black king flank (eval), (start file + 3), 1);
        }
    }
}

Define add move(string start)(string end) movegen(string depth) (warp=true)
{
    movegen added move = Operator.Join(Zero Before Single Digit Numbers (1 offset)[(start + 1)], Zero Before Single Digit Numbers (1 offset)[(end + 1)]);
    List.Add(ALL LEGAL MOVES FOR CPU CALCS, movegen added move);
    List.ReplaceItem(Moves Count, depth, (Moves Count[depth] + 1));
    If (end == their king square (fast movegen))
    {
        opponent king hanging res (move gen) = 1;
    }
    Call add move:(movegen added move) with depth:(depth) to real move lists;
}

Define add move:(string move) with depth:(string depth) to real move lists (warp=true)
{
    If (depth < 6)
    {
        If (depth == 1)
        {
            List.Add(MovesDepth 1, move);
            Stop(this script);
        }
        If (depth == 2)
        {
            List.Add(MovesDepth 2, move);
            Stop(this script);
        }
        If (depth == 3)
        {
            List.Add(MovesDepth 3, move);
            Stop(this script);
        }
        If (depth == 4)
        {
            List.Add(MovesDepth 4, move);
            Stop(this script);
        }
        If (depth == 5)
        {
            List.Add(MovesDepth 5, move);
            Stop(this script);
        }
    }
    If (depth < 11)
    {
        If (depth == 6)
        {
            List.Add(MovesDepth 6, move);
            Stop(this script);
        }
        If (depth == 7)
        {
            List.Add(MovesDepth 7, move);
            Stop(this script);
        }
        If (depth == 8)
        {
            List.Add(MovesDepth 8, move);
            Stop(this script);
        }
        If (depth == 9)
        {
            List.Add(MovesDepth 9, move);
            Stop(this script);
        }
        If (depth == 10)
        {
            List.Add(MovesDepth 10, move);
            Stop(this script);
        }
    }
    If (depth < 16)
    {
        If (depth == 11)
        {
            List.Add(MovesDepth 11, move);
            Stop(this script);
        }
        If (depth == 12)
        {
            List.Add(MovesDepth 12, move);
            Stop(this script);
        }
        If (depth == 13)
        {
            List.Add(MovesDepth 13, move);
            Stop(this script);
        }
        If (depth == 14)
        {
            List.Add(MovesDepth 14, move);
            Stop(this script);
        }
        If (depth == 15)
        {
            List.Add(MovesDepth 15, move);
            Stop(this script);
        }
    }
    If (depth < 21)
    {
        If (depth == 16)
        {
            List.Add(MovesDepth 16, move);
            Stop(this script);
        }
        If (depth == 17)
        {
            List.Add(MovesDepth 17, move);
            Stop(this script);
        }
        If (depth == 18)
        {
            List.Add(MovesDepth 18, move);
            Stop(this script);
        }
        If (depth == 19)
        {
            List.Add(MovesDepth 9, move);
            Stop(this script);
        }
        If (depth == 20)
        {
            List.Add(MovesDepth 20, move);
            Stop(this script);
        }
    }
    If (depth < 26)
    {
        If (depth == 21)
        {
            List.Add(MovesDepth 21, move);
            Stop(this script);
        }
        If (depth == 22)
        {
            List.Add(MovesDepth 22, move);
            Stop(this script);
        }
        If (depth == 23)
        {
            List.Add(MovesDepth 23, move);
            Stop(this script);
        }
        If (depth == 24)
        {
            List.Add(MovesDepth 24, move);
            Stop(this script);
        }
        If (depth == 25)
        {
            List.Add(MovesDepth 25, move);
            Stop(this script);
        }
    }
    If (depth < 31)
    {
        If (depth == 26)
        {
            List.Add(MovesDepth 26, move);
            Stop(this script);
        }
        If (depth == 27)
        {
            List.Add(MovesDepth 27, move);
            Stop(this script);
        }
        If (depth == 28)
        {
            List.Add(MovesDepth 28, move);
            Stop(this script);
        }
        If (depth == 29)
        {
            List.Add(MovesDepth 29, move);
            Stop(this script);
        }
        If (depth == 30)
        {
            List.Add(MovesDepth 30, move);
            Stop(this script);
        }
    }
}

Define add move to legal moves with start square:(string start square) end square:(string end square) depth:(string depth) (warp=true)
{
    start square for moving pieces = Zero Before Single Digit Numbers (1 offset)[(start square + 1)];
    new square temp moving pieces = Zero Before Single Digit Numbers (1 offset)[(end square + 1)];
    List.Add(ALL LEGAL MOVES FOR CPU CALCS, Operator.Join(start square for moving pieces, new square temp moving pieces));
    List.ReplaceItem(Moves Count, depth, (Moves Count[depth] + 1));
    Call add move:(Operator.Join(start square for moving pieces, new square temp moving pieces)) with depth:(depth) to real move lists;
}

Define add move to pseudo-legal move list:(string list) start square:(string start square) end square:(string end square) isSlidingPiece?:(string isSlidingPiece) piece moving direction:(string piece moving direction) defending capture?(string defending capture?) pawn push?(string pawn push?) depth:(string depth) add to legal move list?:(string add to legal move list?) is quiet search?:(string is quiet search?) debug str:(string debug str) enpassant?(bool enpassant?) (warp=true)
{
    start square for moving pieces = Zero Before Single Digit Numbers (1 offset)[(start square + 1)];
    new square temp moving pieces = Zero Before Single Digit Numbers (1 offset)[(end square + 1)];
    If (Not ((defending capture? == 1)))
    {
        Call // comment("a "defending" capture means that the square is "seen" but not actually reachable");
        Call // comment("e.g. a pawn protecting a flank square, but it can't actually move there");
        Call // comment("or a queen looking a an own pawn, but not actually being able to move there");
        If (list == 0)
        {
            Call // comment("non-opposing side");
            List.Add(Piece Color, colorForPiecesOfPseudoLegalMoves);
            List.Add(IsSlidingPiece?, isSlidingPiece);
            List.Add(PieceMovingDirection, piece moving direction);
            List.Add(Pseudo-Legal Move 1, Operator.Join(start square for moving pieces, new square temp moving pieces));
            If (Not ((pawn push? == 1)))
            {
                List.Add(Pseudo-Legal Moves We Attack, end square);
                List.ReplaceItem(# side to move attacking square (move gen), end square, 1);
                If (side to move attack square piece square (move gen)[end square] == 00)
                {
                    List.ReplaceItem(side to move attack square piece square (move gen), end square, start square for moving pieces);
                }
                Else
                {
                    If (side to move attack square piece square 2 (move gen)[end square] == 00)
                    {
                        List.ReplaceItem(side to move attack square piece square 2 (move gen), end square, start square for moving pieces);
                    }
                }
            }
            If (abs(Current Board Position[end square]) == 99999)
            {
                opponent king hanging res (move gen) = 1;
            }
            Call // comment("if moves were to be added to the legal move list, make sure if q-search, it is a capture, promotion, or a check");
            If (add to legal move list? == 1)
            {
                Call // comment("only add moves to legal move list if allowed (eg. it's not allowed doing fully legal moves)");
                If (is quiet search? == 0)
                {
                    Call // comment("if we're doing pseudo-legal move gen, and it's not q-search, allow all moves");
                    Call add move to legal moves with start square:(start square) end square:(end square) depth:(depth);
                    Stop(this script);
                }
                If (end square > 64)
                {
                    Call // comment("castling");
                    Call add move to legal moves with start square:(start square) end square:(end square) depth:(depth);
                    Stop(this script);
                }
                If ((depth % 2) == 1)
                {
                    Call // comment("black move gen");
                    If (Current Board Position[start square] == -100)
                    {
                        If (end square > 56)
                        {
                            Call // comment("promotions are allowed in q-search");
                            Call add move to legal moves with start square:(start square) end square:(end square) depth:(depth);
                            Stop(this script);
                        }
                    }
                    If ((Current Board Position[end square] > 0) Or enpassant?)
                    {
                        Call // comment("capture");
                        Call add move to legal moves with start square:(start square) end square:(end square) depth:(depth);
                        Stop(this script);
                    }
                }
                Else
                {
                    Call // comment("white move gen");
                    If ((abs(Current Board Position[end square]) > 0) Or enpassant?)
                    {
                        Call // comment("piece on square");
                        If ((Current Board Position[end square] < 0) Or enpassant?)
                        {
                            Call // comment("capture");
                            Call add move to legal moves with start square:(start square) end square:(end square) depth:(depth);
                            Stop(this script);
                        }
                    }
                    If (Current Board Position[start square] == 100)
                    {
                        If (end square < 9)
                        {
                            Call // comment("promotions are allowed in q-search");
                            Call add move to legal moves with start square:(start square) end square:(end square) depth:(depth);
                            Stop(this script);
                        }
                    }
                }
                If (generate checks in q-search? (move gen) == 1)
                {
                    Call does piece type:(Current Board Position[start square]) on square:(end square) check square:(index of other king (for legal moves)) ignore piece:("") ?;
                    If (piece check square res (WD) == 1)
                    {
                        Call // comment("checks are allowed in q-search");
                        Call add move to legal moves with start square:(start square) end square:(end square) depth:(depth);
                        Stop(this script);
                    }
                }
                Call // comment("if these conditions are not met, then the move (probably quiet) should not be added to move list");
                Stop(this script);
            }
            Stop(this script);
        }
        If (list == 1)
        {
            Call // comment("opposing side");
            List.Add(Pseudo-Legal Move 2, Operator.Join(start square for moving pieces, new square temp moving pieces));
            If (Not ((pawn push? == 1)))
            {
                List.Add(Pseudo-Legal Moves Opposing Attacking, end square);
                List.ReplaceItem(# Opposing Attacks Square, end square, (# Opposing Attacks Square[end square] + 1));
                If (abs(Current Board Position[start square for moving pieces]) == 100)
                {
                    List.ReplaceItem(op pawn attack square, end square, (op pawn attack square[end square] + 1));
                }
            }
            Stop(this script);
        }
        Stop(this script);
    }
    If (defending capture? == 1)
    {
        Call // comment("defending capture means the square is controlled or "seen" by a piece, but not actually reachable");
        If (list == 1)
        {
            Call // comment("opposing side");
            If (Not ((pawn push? == 1)))
            {
                List.Add(Pseudo-Legal Moves Opposing Attacking, end square);
                List.ReplaceItem(# Opposing Attacks Square, end square, (# Opposing Attacks Square[end square] + 1));
                If (abs(Current Board Position[start square]) == 100)
                {
                    List.ReplaceItem(op pawn attack square, end square, (op pawn attack square[end square] + 1));
                }
            }
            Stop(this script);
        }
        If (list == 0)
        {
            Call // comment("not opposing side");
            If (Not ((pawn push? == 1)))
            {
                List.Add(Pseudo-Legal Moves We Attack, end square);
                List.ReplaceItem(# side to move attacking square (move gen), end square, 1);
                If (side to move attack square piece square (move gen)[end square] == 00)
                {
                    List.ReplaceItem(side to move attack square piece square (move gen), end square, start square for moving pieces);
                }
                Else
                {
                    If (side to move attack square piece square 2 (move gen)[end square] == 00)
                    {
                        List.ReplaceItem(side to move attack square piece square 2 (move gen), end square, start square for moving pieces);
                    }
                }
            }
            Stop(this script);
        }
    }
}

Define add piece as black king attacker with force:(string force) (eval) (warp=true)
{
    num black king attackers (eval) += 1;
    black king attacking force += force;
}

Define add piece as white king attacker with force:(string force) (eval) (warp=true)
{
    num white king attackers (eval) += 1;
    white king attacking force += force;
}

Define add queen attacked threats (eval) (warp=true)
{
    queen attacked threat idx (eval) = 0;
    Repeat (List.Length(White Queen Threat Squares (eval)))
    {
        queen attacked threat idx (eval) += 1;
        queen threat square (eval) = White Queen Threat Squares (eval)[queen attacked threat idx (eval)];
        If (Mobility Area Black[queen threat square (eval)] == 1)
        {
            If (White Queen Threat Squares Source (eval)[queen attacked threat idx (eval)] == -320)
            {
                If (Not (((num black attacks on square (eval)[queen threat square (eval)] < 2) And (num white attacks on square (eval)[queen threat square (eval)] > 1))))
                {
                    Call change board eval with mg term:(-10) eg term:(-5);
                }
            }
            Else
            {
                If (num black attacks on square (eval)[queen threat square (eval)] > 1)
                {
                    Call change board eval with mg term:(-30) eg term:(-10);
                }
            }
        }
    }
    queen attacked threat idx (eval) = 0;
    Repeat (List.Length(Black Queen Threat Squares (eval)))
    {
        queen attacked threat idx (eval) += 1;
        queen threat square (eval) = Black Queen Threat Squares (eval)[queen attacked threat idx (eval)];
        If (Mobility Area White[queen threat square (eval)] == 1)
        {
            If (Black Queen Threat Squares Source (eval)[queen attacked threat idx (eval)] == 320)
            {
                If (Not (((num white attacks on square (eval)[queen threat square (eval)] < 2) And (num black attacks on square (eval)[queen threat square (eval)] > 1))))
                {
                    Call change board eval with mg term:(10) eg term:(5);
                }
            }
            Else
            {
                If (num white attacks on square (eval)[queen threat square (eval)] > 1)
                {
                    Call change board eval with mg term:(30) eg term:(10);
                }
            }
        }
    }
}

Define add safe check with piece type:(string piece type) square:(string square) (warp=true)
{
    If (piece type == 900)
    {
        If (White Rook Check Possible? (eval)[square] == 0)
        {
            num safe checks res (eval) += 1;
            Call contact safe check bonus (eval)(square)(blackKingID(eval));
        }
        Stop(this script);
    }
    If (piece type == -900)
    {
        If (Black Rook Check Possible? (eval)[square] == 0)
        {
            num safe checks res (eval) += 1;
            Call contact safe check bonus (eval)(square)(whiteKingID(eval));
        }
        Stop(this script);
    }
    If (piece type == 500)
    {
        num safe checks res (eval) += 1;
        Call contact safe check bonus (eval)(square)(blackKingID(eval));
    }
    If (piece type == -500)
    {
        num safe checks res (eval) += 1;
        Call contact safe check bonus (eval)(square)(whiteKingID(eval));
    }
    If (piece type == 330)
    {
        If (White Queen Check Possible? (eval)[square] == 0)
        {
            num safe checks res (eval) += 0.35;
        }
        Stop(this script);
    }
    If (piece type == -330)
    {
        If (Black Queen Check Possible? (eval)[square] == 0)
        {
            num safe checks res (eval) += 0.35;
        }
        Stop(this script);
    }
}

Define add square:(string square) to king ring(bool is white) (eval) (warp=true)
{
    If is white
    {
        If (White Pawn Attacks Square (eval)[square] < 2)
        {
            List.ReplaceItem(White King Ring (eval), square, 1);
        }
        Call get chebyshev distance from square:(square) to square 2:(whiteKingID(eval));
        If (distance from square to square == 1)
        {
            If ((Current Board Position[square] + 0) < 0)
            {
                List.Add(White Attacks (eval), square);
                List.Add(White Attacks Source (eval), 99999);
            }
        }
    }
    Else
    {
        If (Black Pawn Attacks Square (eval)[square] < 2)
        {
            List.ReplaceItem(Black King Ring (eval), square, 1);
        }
        Call get chebyshev distance from square:(square) to square 2:(whiteKingID(eval));
        If (distance from square to square == 1)
        {
            If ((Current Board Position[square] + 0) > 0)
            {
                List.Add(Black Attacks (eval), square);
                List.Add(Black Attacks Source (eval), -99999);
            }
        }
    }
}

Define add to full game debug with label:(string label)(string num)(string full game debug idx) (warp=true)
{
    add to full game debug temp = Operator.Join(label, (Operator.Round((num * 100)) / 100));
    If (full game debug idx > 0)
    {
        List.ReplaceItem(FULL GAME DEBUG INFO, full game debug idx, add to full game debug temp);
        Stop(this script);
    }
    List.Add(FULL GAME DEBUG INFO, add to full game debug temp);
}

Define add to piece numbers and change mat (eval) (warp=true)
{
    Call // comment("add to the counters of the pieces + increment the material value");
    If (current piece type (eval) > 900)
    {
        Stop(this script);
    }
    If (current piece (eval) == -100)
    {
        NUM TOTAL PAWNS (EVAL) += 1;
        NUM BLACK PAWNS (EVAL) += 1;
        Call change piece value bonus with multiplier:(-1) piece num:(1);
        Stop(this script);
    }
    If (current piece (eval) == 100)
    {
        NUM TOTAL PAWNS (EVAL) += 1;
        NUM WHITE PAWNS (EVAL) += 1;
        Call change piece value bonus with multiplier:(1) piece num:(1);
        Stop(this script);
    }
    If (current piece (eval) < -330)
    {
        NUM BLACK MAJOR PIECES (EVAL) += 1;
        NUM BLACK PIECES (NOT PAWNS) (EVAL) += 1;
        If (current piece (eval) == -500)
        {
            NUM BLACK ROOKS (EVAL) += 1;
            Call change piece value bonus with multiplier:(-1) piece num:(4);
        }
        Else
        {
            NUM BLACK QUEENS (EVAL) += 1;
            Call change piece value bonus with multiplier:(-1) piece num:(5);
        }
        Stop(this script);
    }
    If (current piece (eval) > 330)
    {
        NUM WHITE MAJOR PIECES (EVAL) += 1;
        NUM WHITE PIECES (NOT PAWNS) (EVAL) += 1;
        If (current piece (eval) == 500)
        {
            NUM WHITE ROOKS (EVAL) += 1;
            Call change piece value bonus with multiplier:(1) piece num:(4);
        }
        Else
        {
            NUM WHITE QUEENS (EVAL) += 1;
            Call change piece value bonus with multiplier:(1) piece num:(5);
        }
        Stop(this script);
    }
    If (current piece (eval) == 330)
    {
        NUM WHITE PIECES (NOT PAWNS) (EVAL) += 1;
        NUM WHITE BISHOPS (EVAL) += 1;
        NUM WHITE MINOR PIECES (EVAL) += 1;
        WHITE BISHOP TYPE (EVAL) = Square Color[counter for evaluation];
        Call change piece value bonus with multiplier:(1) piece num:(3);
        Stop(this script);
    }
    If (current piece (eval) == 320)
    {
        NUM WHITE PIECES (NOT PAWNS) (EVAL) += 1;
        NUM WHITE KNIGHTS (EVAL) += 1;
        NUM WHITE MINOR PIECES (EVAL) += 1;
        Call change piece value bonus with multiplier:(1) piece num:(2);
        Stop(this script);
    }
    If (current piece (eval) == -330)
    {
        NUM BLACK PIECES (NOT PAWNS) (EVAL) += 1;
        NUM BLACK BISHOPS (EVAL) += 1;
        NUM BLACK MINOR PIECES (EVAL) += 1;
        BLACK BISHOP TYPE (EVAL) = Square Color[counter for evaluation];
        Call change piece value bonus with multiplier:(-1) piece num:(3);
        Stop(this script);
    }
    If (current piece (eval) == -320)
    {
        NUM BLACK PIECES (NOT PAWNS) (EVAL) += 1;
        NUM BLACK KNIGHTS (EVAL) += 1;
        NUM BLACK MINOR PIECES (EVAL) += 1;
        Call change piece value bonus with multiplier:(-1) piece num:(2);
        Stop(this script);
    }
}

Define after makemove minmax temp with depth:(string depth)(string max depth)(string rounds of quiet search)(string numExtensions)(string num SE) (warp=true)
{
    Repeat (Moves Count[depth])
    {
        List.ReplaceItem(Moves Index Temp, depth, (Moves Index Temp[depth] + 1));
        List.ReplaceItem(Moves Index, depth, Moves Index Temp[depth]);
        Call get current applying move with depth:(depth);
        If (Not ((current move (computer) == Exclude Move at Depth[depth])))
        {
            Call apply move with depth:(depth) manual override:("") full search:((1 == 1));
            If ((depth % 2) == 1)
            {
                List.ReplaceItem(Alphas Temp, depth, (TTread Score at Depth[depth] + 100));
                List.ReplaceItem(Betas Temp, depth, (Alphas[depth] + 1));
            }
            Else
            {
                List.ReplaceItem(Betas Temp, depth, (TTread Score at Depth[depth] - 100));
                List.ReplaceItem(Alphas Temp, depth, (Betas[depth] - 1));
            }
            Call should futility prune move at depth(depth);
            If (should futility prune? == 0)
            {
                Call minmax depth:((depth + 1)) max depth:(max depth) rounds of quiet search?(rounds of quiet search) numExtensions:(numExtensions) num SE:(num SE);
                Eval/Score = MinMax Results[(depth + 1)];
                Call revert moves with depth:(depth) manual override:("");
                If (depth < search starting depth)
                {
                    Stop(this script);
                }
                Call minmax time exhausted?;
                If (minmax time exhausted? == 1)
                {
                    Call // comment("if the time is up, we must stop this script before it starts affecting other search data");
                    Call // comment("this is because it is very very likely that we did not completely search this move, resulting in a bad score");
                    Stop(this script);
                }
                If ((depth % 2) == 1)
                {
                    If (Eval/Score < Best Score Temp[depth])
                    {
                        List.ReplaceItem(Best Score Temp, depth, Eval/Score);
                        List.ReplaceItem(Minmax Res Temp, depth, Eval/Score);
                    }
                    If (Eval/Score < Betas Temp[depth])
                    {
                        List.ReplaceItem(Betas Temp, depth, Eval/Score);
                    }
                    If ((Betas Temp[depth] < Alphas Temp[depth]) Or (Betas Temp[depth] == Alphas Temp[depth]))
                    {
                        Call // comment("cutoff");
                        Stop(this script);
                    }
                }
                Else
                {
                    If (Eval/Score > Best Score Temp[depth])
                    {
                        List.ReplaceItem(Best Score Temp, depth, Eval/Score);
                        List.ReplaceItem(Minmax Res Temp, depth, Eval/Score);
                    }
                    If (Eval/Score > Alphas Temp[depth])
                    {
                        List.ReplaceItem(Alphas Temp, depth, Eval/Score);
                    }
                    If ((Betas Temp[depth] < Alphas Temp[depth]) Or (Betas Temp[depth] == Alphas Temp[depth]))
                    {
                        Call // comment("cutoff");
                        Stop(this script);
                    }
                }
            }
            Else
            {
                Call revert moves with depth:(depth) manual override:("");
            }
        }
    }
}

Define apply / revert move castling movement with king:(string king idx) rook idx:(string rook idx) empties:(string blank1)(string blank2) multiplier:(string multiplier)(bool update hash?) king start:(string king start) rook start:(string rook start) (warp=true)
{
    List.ReplaceItem(Current Board Position, king idx, (99999 * multiplier));
    List.ReplaceItem(Current Board Position, rook idx, (500 * multiplier));
    List.ReplaceItem(Current Board Position, blank1, "");
    List.ReplaceItem(Current Board Position, blank2, "");
    If update hash?
    {
        Call get piece pos hash at pos:(king start) piece:((99999 * multiplier));
        next ply board hash temp += (-1 * piecePosHash);
        Call get piece pos hash at pos:(king idx) piece:((99999 * multiplier));
        next ply board hash temp += (1 * piecePosHash);
        Call get piece pos hash at pos:(rook start) piece:((500 * multiplier));
        next ply board hash temp += (-1 * piecePosHash);
        Call get piece pos hash at pos:(rook idx) piece:((500 * multiplier));
        next ply board hash temp += (1 * piecePosHash);
    }
}

Define apply move with depth:(string depth) manual override:(string override) full search:(bool full search) (warp=true)
{
    move type (for applying moves) = "quiet";
    next ply board hash temp = Board Hash At Depth[depth];
    If ((depth % 2) == 1)
    {
        next ply board hash temp += (-1 * WD_side key (hash table));
    }
    Else
    {
        next ply board hash temp += WD_side key (hash table);
    }
    If (depth == 1)
    {
        If (CPU COLOR == "w")
        {
            Stop(this script);
        }
    }
    If (Not ((override == "")))
    {
        current move (computer) = override;
    }
    Else
    {
        Call get current applying move with depth:(depth);
    }
    If full search
    {
        total nodes: += 1;
    }
    Else
    {
        total q-search nodes: += 1;
    }
    start square for applying moves = floor((current move (computer) / 100));
    end square for applying moves = floor((current move (computer) % 100));
    List.ReplaceItem(Moves Played In Search, depth, current move (computer));
    List.ReplaceItem(WD_EnPassantTarget, (depth + 1), "");
    List.ReplaceItem(PutsInCheck?, depth, 0);
    If (current move (computer) > 100)
    {
        Call // comment("normal move (not castling)");
        newPiece (for Applying Moves) = Current Board Position[start square for applying moves];
        If (newPiece (for Applying Moves) == 100)
        {
            Call // comment("white pawn");
            If (end square for applying moves < 9)
            {
                newPiece (for Applying Moves) = 900;
                move type (for applying moves) = "promotion";
                Call change incrementally updated num pieces with value:(100) change value by:(-1) square:(start square for applying moves);
                Call change incrementally updated num pieces with value:(900) change value by:(1) square:(end square for applying moves);
            }
            If ((start square for applying moves - end square for applying moves) == 16)
            {
                List.ReplaceItem(WD_EnPassantTarget, (depth + 1), (start square for applying moves - 8));
            }
            If (end square for applying moves == WD_EnPassantTarget[depth])
            {
                List.ReplaceItem(Current Board Position, (WD_EnPassantTarget[depth] + 8), "");
                Call change incrementally updated num pieces with value:(-100) change value by:(-1) square:((WD_EnPassantTarget[depth] + 8));
                Call get piece pos hash at pos:((WD_EnPassantTarget[depth] + 8)) piece:(-100);
                next ply board hash temp += (-1 * piecePosHash);
            }
        }
        If (newPiece (for Applying Moves) == -100)
        {
            Call // comment("black pawn");
            If (end square for applying moves > 56)
            {
                newPiece (for Applying Moves) = -900;
                move type (for applying moves) = "promotion";
                Call change incrementally updated num pieces with value:(-100) change value by:(-1) square:(start square for applying moves);
                Call change incrementally updated num pieces with value:(-900) change value by:(1) square:(end square for applying moves);
            }
            If ((end square for applying moves - start square for applying moves) == 16)
            {
                List.ReplaceItem(WD_EnPassantTarget, (depth + 1), (start square for applying moves + 8));
            }
            If (end square for applying moves == WD_EnPassantTarget[depth])
            {
                List.ReplaceItem(Current Board Position, (WD_EnPassantTarget[depth] - 8), "");
                Call change incrementally updated num pieces with value:(100) change value by:(-1) square:((WD_EnPassantTarget[depth] - 8));
                Call get piece pos hash at pos:((WD_EnPassantTarget[depth] - 8)) piece:(100);
                next ply board hash temp += (-1 * piecePosHash);
            }
        }
        If (Not ((Current Board Position[end square for applying moves] == "")))
        {
            move type (for applying moves) = "capture";
        }
        Call does piece type:(newPiece (for Applying Moves)) on square:(end square for applying moves) check square:(OP KING ID AT DEPTH[depth]) ignore piece:("") ?;
        If (piece check square res (WD) == 1)
        {
            List.ReplaceItem(PutsInCheck?, depth, 1);
        }
        List.ReplaceItem(Move Type (applying moves), depth, move type (for applying moves));
        List.ReplaceItem(targetPieces, depth, Current Board Position[end square for applying moves]);
        List.ReplaceItem(sourcePiece, depth, Current Board Position[start square for applying moves]);
        Call change incrementally updated num pieces with value:(Current Board Position[end square for applying moves]) change value by:(-1) square:(end square for applying moves);
        Call // comment("move the pieces on the real board");
        List.ReplaceItem(Current Board Position, end square for applying moves, newPiece (for Applying Moves));
        List.ReplaceItem(Current Board Position, start square for applying moves, "");
        Call get piece pos hash at pos:(end square for applying moves) piece:(targetPieces[depth]);
        next ply board hash temp += (-1 * piecePosHash);
        Call get piece pos hash at pos:(start square for applying moves) piece:(sourcePiece[depth]);
        next ply board hash temp += (-1 * piecePosHash);
        Call get piece pos hash at pos:(end square for applying moves) piece:(newPiece (for Applying Moves));
        next ply board hash temp += (1 * piecePosHash);
        If (Current Board Position[end square for applying moves] == 99999)
        {
            WHITE KING ID (UPDATED) = end square for applying moves;
        }
        If (Current Board Position[end square for applying moves] == -99999)
        {
            BLACK KING ID (UPDATED) = end square for applying moves;
        }
        Call // comment("if not a normal check, see if it's a discovery check AFTER the move has already been played (that's why some of the params seem strange)");
        If (Not ((PutsInCheck?[depth] == 1)))
        {
            Call does piece on square:(start square for applying moves) discover check square:(OP KING ID AT DEPTH[depth]) with depth:(depth);
            If (does piece discover check square res == 1)
            {
                List.ReplaceItem(PutsInCheck?, depth, 1);
            }
        }
        List.ReplaceItem(WD_CastlingRights, (depth + 2), WD_CastlingRights[depth]);
        If ((depth % 2) == 1)
        {
            If (start square for applying moves == 5)
            {
                List.ReplaceItem(WD_CastlingRights, (depth + 2), 00);
            }
            If (start square for applying moves == 1)
            {
                List.ReplaceItem(WD_CastlingRights, (depth + 2), Operator.Join(Operator.LetterOf(WD_CastlingRights[depth], 1), 0));
            }
            If (start square for applying moves == 8)
            {
                List.ReplaceItem(WD_CastlingRights, (depth + 2), Operator.Join(0, Operator.LetterOf(WD_CastlingRights[depth], 2)));
            }
            If (end square for applying moves == 57)
            {
                List.ReplaceItem(WD_CastlingRights, (depth + 1), Operator.Join(Operator.LetterOf(WD_CastlingRights[(depth + 1)], 1), 0));
            }
            If (end square for applying moves == 64)
            {
                List.ReplaceItem(WD_CastlingRights, (depth + 1), Operator.Join(0, Operator.LetterOf(WD_CastlingRights[(depth + 1)], 2)));
            }
        }
        Else
        {
            If (start square for applying moves == 61)
            {
                List.ReplaceItem(WD_CastlingRights, (depth + 2), 00);
            }
            If (start square for applying moves == 57)
            {
                List.ReplaceItem(WD_CastlingRights, (depth + 2), Operator.Join(Operator.LetterOf(WD_CastlingRights[depth], 1), 0));
            }
            If (start square for applying moves == 64)
            {
                List.ReplaceItem(WD_CastlingRights, (depth + 2), Operator.Join(0, Operator.LetterOf(WD_CastlingRights[depth], 2)));
            }
            If (end square for applying moves == 1)
            {
                List.ReplaceItem(WD_CastlingRights, (depth + 1), Operator.Join(Operator.LetterOf(WD_CastlingRights[(depth + 1)], 1), 0));
            }
            If (end square for applying moves == 8)
            {
                List.ReplaceItem(WD_CastlingRights, (depth + 1), Operator.Join(0, Operator.LetterOf(WD_CastlingRights[(depth + 1)], 2)));
            }
        }
    }
    Else
    {
        move type (for applying moves) = "castling";
        List.ReplaceItem(WD_CastlingRights, (depth + 2), 00);
        If (current move (computer) == BlackKingSideCastle)
        {
            Call apply / revert move castling movement with king:(7) rook idx:(6) empties:(5)(8) multiplier:(-1)((1 == 1)) king start:(5) rook start:(8);
            BLACK KING ID (UPDATED) = 7;
        }
        Else
        {
            If (current move (computer) == BlackQueenSideCastle)
            {
                Call apply / revert move castling movement with king:(3) rook idx:(4) empties:(1)(5) multiplier:(-1)((1 == 1)) king start:(5) rook start:(1);
                BLACK KING ID (UPDATED) = 3;
            }
            Else
            {
                If (current move (computer) == WhiteKingSideCastle)
                {
                    Call apply / revert move castling movement with king:(63) rook idx:(62) empties:(61)(64) multiplier:(1)((1 == 1)) king start:(61) rook start:(64);
                    WHITE KING ID (UPDATED) = 63;
                }
                Else
                {
                    If (current move (computer) == WhiteQueenSideCastle)
                    {
                        Call apply / revert move castling movement with king:(59) rook idx:(60) empties:(61)(57) multiplier:(1)((1 == 1)) king start:(61) rook start:(57);
                        WHITE KING ID (UPDATED) = 59;
                    }
                }
            }
        }
    }
    List.ReplaceItem(Next Ply Board Hash, depth, next ply board hash temp);
}

Define basic legality check of hash move:(string hash move) depth:(string depth) (warp=true)
{
    hash move passed basic legality test res = 0;
    If (hash move == "???")
    {
        Stop(this script);
    }
    If (Not (((hash move < 100) Or (Not ((floor((hash move / 100)) == ""))))))
    {
        Stop(this script);
    }
    hash move passed basic legality test res = 1;
    If ((depth % 2) == 1)
    {
        If ((hash move == BlackKingSideCastle) Or (hash move == BlackQueenSideCastle))
        {
            If (BLACK KING ID (UPDATED) == 5)
            {
                hash move passed basic legality test res = 1;
            }
        }
    }
    Else
    {
        If ((hash move == WhiteKingSideCastle) Or (hash move == WhiteQueenSideCastle))
        {
            If (WHITE KING ID (UPDATED) == 61)
            {
                hash move passed basic legality test res = 1;
            }
        }
    }
}

Define benchmark movegen speed:(string idx) (warp=true)
{
    benchmark movegen speed start time = Operator.Join(Sensing.DaysSince2000(), "");
    benchmark movegen NPS = 0;
    Repeat (idx)
    {
        Call fast pseudo-legal move gen with depth:(0)((0 == 1))((0 == 1))();
        benchmark movegen NPS += List.Length(ALL LEGAL MOVES FOR CPU CALCS);
    }
    benchmark movegen time elapsed = ((Sensing.DaysSince2000() - benchmark movegen speed start time) * 86400);
    benchmark movegen NPS = Operator.Join((Operator.Round((benchmark movegen NPS / benchmark movegen time elapsed)) / 1000), "k");
    benchmark time for 10k = Operator.Join((Operator.Round((((benchmark movegen time elapsed * 10000) / idx) * 1000)) / 1000), "s");
}

Define bishop movement with color:(string color) board index:(string index) depth:(string depth) add to legal move list?:(string add to legal move list?) is quiet search?:(string is quiet search?) (warp=true)
{
    Call get distance to edge with index:(index) //  MOVE GEN;
    start square for moving pieces = index;
    color of piece = color;
    moves for sliding pieces direction = 0;
    Repeat (4)
    {
        moves for sliding pieces direction += 2;
        Call loop for sliding pieces inner with depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?(is quiet search?) caller type:("B");
    }
}

Define Black King Safety (warp=true)
{
    Shelter Pawns Kingside (eval) = 0;
    Shelter Pawns Queenside (eval) = 0;
    Shelter Pawns No Castle (eval) = 0;
    Shelter Val Kingside (eval) = "none";
    Shelter Val Queenside (eval) = "none";
    Shelter Val No Castle (eval) = 0;
    Black King Shelter Val = 0;
    Black King Attacked Val = 0;
    num black shield pawns = 0;
    king can pseudo-castle (eval) = 0;
    Call get rank and file from square index:(blackKingID(eval));
    If (rank from square index < 7)
    {
        Black King Shelter Val += 100;
    }
    Black King Attacked Val += Operator.Round(((black king attacking force * Power of Attack (with # of attackers)[num black king attackers (eval)]) * 0.5));
    If (((Current Board Position[7] == -500) And (blackKingID(eval) == 8)) Or ((Current Board Position[2] == -500) And (blackKingID(eval) == 1)))
    {
        Black King Attacked Val += 45;
    }
    If ((BlackKingSide(ForEval) == "king") Or (((blackKingID(eval) == 5) And (Current Board Position[8] == -500)) And ((isEndgame? (for eval) == 0) Or ((Current Board Position[6] == "") And (Current Board Position[7] == "")))))
    {
        If ((blackKingID(eval) == 5) And (Current Board Position[8] == -500))
        {
            king can pseudo-castle (eval) = 1;
        }
        If (blackPawn(ForEval)[14] == 1)
        {
            Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * -1);
            num black shield pawns += 1;
        }
        Else
        {
            If (blackPawn(ForEval)[22] == 1)
            {
                Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * -0.75);
            }
            Else
            {
                If (blackPawn(ForEval)[30] == 1)
                {
                    Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * -0.15);
                }
                Else
                {
                    If (abs(Most Advanced Black Pawn[6]) < 999)
                    {
                        Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * -0.05);
                    }
                    Else
                    {
                        Shelter Val Kingside (eval) += (NO PAWN SHIELD PENALTY * -1);
                    }
                }
            }
        }
        If ((blackPawn(ForEval)[15] == 1) Or (blackPawn(ForEval)[23] == 1))
        {
            If (blackPawn(ForEval)[15] == 1)
            {
                Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * -1);
            }
            Else
            {
                Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * -0.35);
            }
            num black shield pawns += 1;
        }
        Else
        {
            If (abs(Most Advanced Black Pawn[7]) == 999)
            {
                Shelter Val Kingside (eval) += (NO PAWN SHIELD PENALTY * -2);
            }
        }
        If (((blackPawn(ForEval)[16] == 1) Or (blackPawn(ForEval)[24] == 1)) And ((file from square index > 6) Or (king can pseudo-castle (eval) == 1)))
        {
            Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * -1);
            num black shield pawns += 1;
        }
        Else
        {
            If (abs(Most Advanced Black Pawn[6]) < 999)
            {
                Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * -0.5);
                If (blackPawn(ForEval)[32] == 1)
                {
                    Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * -0.25);
                }
            }
            Else
            {
                Shelter Val Kingside (eval) += (NO PAWN SHIELD PENALTY * -1);
            }
        }
    }
    If ((BlackKingSide(ForEval) == "queen") Or (((blackKingID(eval) == 5) And (Current Board Position[1] == -500)) And (isEndgame? (for eval) == 0)))
    {
        If ((blackKingID(eval) == 5) And (Current Board Position[1] == -500))
        {
            king can pseudo-castle (eval) = 1;
        }
        If ((blackPawn(ForEval)[9] == 1) Or ((blackPawn(ForEval)[17] == 1) Or (blackPawn(ForEval)[25] == 1)))
        {
            If (BlackKingFile (eval) < 3)
            {
                num black shield pawns += 1;
                If ((whitePawn(ForEval)[9] == 1) Or (whitePawn(ForEval)[17] == 1))
                {
                    Shelter Val Queenside (eval) += (PAWN SHIELD BONUS * -1);
                }
                Else
                {
                    Shelter Val Queenside (eval) += (PAWN SHIELD BONUS * -0.25);
                }
            }
        }
        Else
        {
            Shelter Val Queenside (eval) += (NO PAWN SHIELD PENALTY * -1.25);
        }
        If ((blackPawn(ForEval)[10] == 1) Or (blackPawn(ForEval)[18] == 1))
        {
            Shelter Val Queenside (eval) += (PAWN SHIELD BONUS * -1);
            num black shield pawns += 1;
        }
        Else
        {
            Shelter Val Queenside (eval) += (NO PAWN SHIELD PENALTY * -1);
            Black King Shelter Val += 25;
        }
        If ((blackPawn(ForEval)[11] == 1) Or (blackPawn(ForEval)[19] == 1))
        {
            If (blackPawn(ForEval)[11] == "")
            {
                Shelter Val Queenside (eval) += (PAWN SHIELD BONUS * -0.3);
            }
            Else
            {
                Shelter Val Queenside (eval) += (PAWN SHIELD BONUS * -1);
            }
            num black shield pawns += 1;
        }
        Else
        {
            Shelter Val Queenside (eval) += (NO PAWN SHIELD PENALTY * -0.5);
        }
        If ((blackPawn(ForEval)[10] == "") And (blackPawn(ForEval)[11] == ""))
        {
            Shelter Val Queenside (eval) += 15;
            If (blackPawn(ForEval)[09] == "")
            {
                Shelter Val Queenside (eval) += 55;
            }
        }
        If (abs(Most Advanced Black Pawn[1]) == 999)
        {
            Call change shelter val by:(35) scaled to material:(WHITE MATERIAL (NO PAWNS)) white perspective?((0 == 1));
            If (Open File? (eval)[1] == 1)
            {
                Call change shelter val by:(35) scaled to material:(WHITE MATERIAL (NO PAWNS)) white perspective?((0 == 1));
            }
        }
        If (Current Board Position[17] == 330)
        {
            Shelter Val Queenside (eval) += 50;
        }
    }
    If (abs(Least Advanced Black Pawn[4]) == 999)
    {
        Shelter Val No Castle (eval) += 15;
        If (Open File? (eval)[4] == 1)
        {
            If ((blackKingID(eval) == 5) And ((Current Board Position[6] == "") And (Current Board Position[7] == "")))
            {
                Shelter Val No Castle (eval) += -5;
            }
            Else
            {
                Shelter Val No Castle (eval) += 35;
                If (White Rooks on File[4] > 0)
                {
                    Shelter Val No Castle (eval) += 200;
                }
            }
        }
    }
    If (abs(Least Advanced Black Pawn[5]) == 999)
    {
        Shelter Val No Castle (eval) += 15;
        If (Open File? (eval)[5] == 1)
        {
            If ((blackKingID(eval) == 5) And ((Current Board Position[6] == "") And (Current Board Position[7] == "")))
            {
                Shelter Val No Castle (eval) += -5;
            }
            Else
            {
                Shelter Val No Castle (eval) += 35;
                If (White Rooks on File[5] > 0)
                {
                    Shelter Val No Castle (eval) += 200;
                }
            }
        }
    }
    Black King Shelter Val = Shelter Val No Castle (eval);
    If ((Shelter Val Kingside (eval) < Black King Shelter Val) And (Not ((Shelter Val Kingside (eval) == "none"))))
    {
        Black King Shelter Val = Shelter Val Kingside (eval);
    }
    If ((Shelter Val Queenside (eval) < Black King Shelter Val) And (Not ((Shelter Val Queenside (eval) == "none"))))
    {
        Black King Shelter Val = Shelter Val Queenside (eval);
    }
    If (BlackKingSide(ForEval) == "")
    {
        If ((abs(Least Advanced Black Pawn[4]) == 999) And (abs(Least Advanced Black Pawn[5]) == 999))
        {
            If (WHITE MATERIAL (NO PAWNS) > 2000)
            {
                If (num black king attacks (eval) > 2)
                {
                    Black King Shelter Val += 125;
                }
                Else
                {
                    Black King Shelter Val += 55;
                }
            }
        }
    }
}

Define black minor piece is developed?(string square) (warp=true)
{
    If ((Current Board Position[square] == -320) Or (Current Board Position[square] == -330))
    {
        If ((square == 2) Or ((square == 3) Or ((square == 6) Or (square == 7))))
        {
            BLACK MINOR PIECES DEVELOPED (EVAL) += -1;
        }
    }
}

Define blockages (evaluation) (warp=true)
{
    Call // comment("evaluates pieces getting blocked, reducing available moves");
    If (Current Board Position[1] == -500)
    {
        If (Current Board Position[2] == -500)
        {
            BOARD EVAL += 35;
        }
    }
    If (Current Board Position[8] == -500)
    {
        If (Current Board Position[7] == -500)
        {
            BOARD EVAL += 35;
        }
    }
    If (Current Board Position[57] == 500)
    {
        If (Current Board Position[58] == 500)
        {
            BOARD EVAL += -35;
        }
    }
    If (Current Board Position[64] == 500)
    {
        If (Current Board Position[63] == 500)
        {
            BOARD EVAL += -35;
        }
    }
}

Define book finder look at line:(string line) (warp=true)
{
    book finder depth idx = 0;
    book finder idx = 1;
    Repeat (floor(((Variable.Length(line) + 0) / 4)))
    {
        Call fast makemove for book finder start idx:(Operator.Join(Operator.LetterOf(line, (book finder idx + 0)), Operator.LetterOf(line, (book finder idx + 1)))) end idx:(Operator.Join(Operator.LetterOf(line, (book finder idx + 2)), Operator.LetterOf(line, (book finder idx + 3)))) move:(Operator.Join(Operator.Join(Operator.LetterOf(line, (book finder idx + 0)), Operator.LetterOf(line, (book finder idx + 1))), Operator.Join(Operator.LetterOf(line, (book finder idx + 2)), Operator.LetterOf(line, (book finder idx + 3)))));
        book finder depth idx += 1;
        Call createCurrentBoardHash with depth:(book finder depth idx);
        If (current real position board hash (book finder) == currentBoardHash)
        {
            Call // comment("book line position matches current real position");
            WD_best move = Operator.Join(Operator.Join(Operator.LetterOf(line, ((book finder idx + 0) + 4)), Operator.LetterOf(line, ((book finder idx + 1) + 4))), Operator.Join(Operator.LetterOf(line, ((book finder idx + 2) + 4)), Operator.LetterOf(line, ((book finder idx + 3) + 4))));
            Stop(this script);
        }
        book finder idx += 4;
    }
}

Define calculate castling legality with depth:(string depth) (warp=true)
{
    If (Pseudo-Legal Move 1[counter to get all legal moves] == BlackKingSideCastle)
    {
        If ((Current Board Position[6] == "") And ((Current Board Position[7] == "") And (Current Board Position[8] == -500)))
        {
            If ((abs(# Opposing Attacks Square[6]) == 0) And (abs(# Opposing Attacks Square[7]) == 0))
            {
                Call add move to legal moves with start square:(start square for finding legal moves) end square:(end square for finding legal moves) depth:(depth);
            }
        }
    }
    Else
    {
        If (Pseudo-Legal Move 1[counter to get all legal moves] == BlackQueenSideCastle)
        {
            If ((Current Board Position[2] == "") And ((Current Board Position[3] == "") And ((Current Board Position[4] == "") And (Current Board Position[1] == -500))))
            {
                If ((abs(# Opposing Attacks Square[3]) == 0) And (abs(# Opposing Attacks Square[4]) == 0))
                {
                    Call add move to legal moves with start square:(start square for finding legal moves) end square:(end square for finding legal moves) depth:(depth);
                }
            }
        }
        Else
        {
            If (Pseudo-Legal Move 1[counter to get all legal moves] == WhiteKingSideCastle)
            {
                If ((Current Board Position[62] == "") And ((Current Board Position[63] == "") And (Current Board Position[64] == 500)))
                {
                    If ((abs(# Opposing Attacks Square[62]) == 0) And (abs(# Opposing Attacks Square[63]) == 0))
                    {
                        Call add move to legal moves with start square:(start square for finding legal moves) end square:(end square for finding legal moves) depth:(depth);
                    }
                }
            }
            Else
            {
                If (Pseudo-Legal Move 1[counter to get all legal moves] == WhiteQueenSideCastle)
                {
                    If ((Current Board Position[58] == "") And ((Current Board Position[59] == "") And ((Current Board Position[60] == "") And (Current Board Position[57] == 500))))
                    {
                        If ((abs(# Opposing Attacks Square[59]) == 0) And (abs(# Opposing Attacks Square[60]) == 0))
                        {
                            Call add move to legal moves with start square:(start square for finding legal moves) end square:(end square for finding legal moves) depth:(depth);
                        }
                    }
                }
            }
        }
    }
}

Define change area counter (eval) (warp=true)
{
    Call get rank and file from square index:(counter for evaluation);
    If ((file from square index > 2) And (file from square index < 7))
    {
        If ((rank from square index > 1) And (rank from square index < 5))
        {
            If (Not ((Current Board Position[counter for evaluation] == 100)))
            {
                If ((Not ((Current Board Position[(counter for evaluation - 7)] == -100))) And (Not ((Current Board Position[(counter for evaluation - 9)] == -100))))
                {
                    List.ReplaceItem(white area counter (eval), counter for evaluation, 1);
                    area counter white (eval) += 1;
                    If (((Current Board Position[(counter for evaluation - 8)] == 100) And (num black attacks on square (eval)[counter for evaluation] == 0)) Or ((Current Board Position[(counter for evaluation - 16)] == 100) And (num black attacks on square (eval)[counter for evaluation] == 0)))
                    {
                        List.ReplaceItem(white area counter (eval), counter for evaluation, 2);
                        area counter white (eval) += 1;
                    }
                }
            }
            Stop(this script);
        }
        If ((rank from square index > 4) And (rank from square index < 8))
        {
            If (Not ((Current Board Position[counter for evaluation] == -100)))
            {
                If ((Not ((Current Board Position[(counter for evaluation + 7)] == 100))) And (Not ((Current Board Position[(counter for evaluation + 9)] == 100))))
                {
                    List.ReplaceItem(black area counter (eval), counter for evaluation, 1);
                    area counter black (eval) += 1;
                    If (((Current Board Position[(counter for evaluation + 8)] == -100) And (num white attacks on square (eval)[counter for evaluation] == 0)) Or ((Current Board Position[(counter for evaluation + 16)] == -100) And (num white attacks on square (eval)[counter for evaluation] == 0)))
                    {
                        List.ReplaceItem(black area counter (eval), counter for evaluation, 2);
                        area counter black (eval) += 1;
                    }
                }
            }
            Stop(this script);
        }
    }
}

Define change board eval from PSTs and game state (eval)(string endgame) value:(string value) (warp=true)
{
    If (endgame == 1)
    {
        If (current piece (eval) < 0)
        {
            Black PSTs End (eval) += value;
            Stop(this script);
        }
        White PSTs End (eval) += value;
        Stop(this script);
    }
    If (current piece (eval) < 0)
    {
        Black PSTs Middle (eval) += value;
        Stop(this script);
    }
    White PSTs Middle (eval) += value;
}

Define change board eval with mg term:(string mg term) eg term:(string eg term) (warp=true)
{
    BOARD EVAL += Operator.Round((((mg term * EVAL PHASE (eval)) + (eg term * (128 - EVAL PHASE (eval)))) / 128));
}

Define change board hash with piece:(string piece) pos:(string pos) (warp=true)
{
    If (abs(piece) > 0)
    {
        currentBoardHash += PosPieceHashLookup[((64 * (PIECE TYPE TO ID[(piece + 100000)] - 1)) + pos)];
    }
}

Define change incrementally updated num pieces with value:(string value) change value by:(string change value by) square:(string square) (warp=true)
{
    If (value == "")
    {
        Stop(this script);
    }
    If (Not ((abs(value) == 100)))
    {
        NOT PAWN MATERIAL (UPDATED) += (abs(value) * change value by);
    }
    MATERIAL BALANCE (UPDATED) += (value * change value by);
    If (value == 100)
    {
        NUM WHITE PAWNS (UPDATED) += change value by;
        Stop(this script);
    }
    If (value == 320)
    {
        NUM WHITE KNIGHTS (UPDATED) += change value by;
        Stop(this script);
    }
    If (value == 330)
    {
        NUM WHITE BISHOPS (UPDATED) += change value by;
        Stop(this script);
    }
    If (value == 500)
    {
        NUM WHITE ROOKS (UPDATED) += change value by;
        Stop(this script);
    }
    If (value == 900)
    {
        NUM WHITE QUEENS (UPDATED) += change value by;
        Stop(this script);
    }
    If (value == -100)
    {
        NUM BLACK PAWNS (UPDATED) += change value by;
        Stop(this script);
    }
    If (value == -320)
    {
        NUM BLACK KNIGHTS (UPDATED) += change value by;
        Stop(this script);
    }
    If (value == -330)
    {
        NUM BLACK BISHOPS (UPDATED) += change value by;
        Stop(this script);
    }
    If (value == -500)
    {
        NUM BLACK ROOKS (UPDATED) += change value by;
        Stop(this script);
    }
    If (value == -900)
    {
        NUM BLACK QUEENS (UPDATED) += change value by;
        Stop(this script);
    }
}

Define change piece value bonus with multiplier:(string multiplier) piece num:(string piece num) (warp=true)
{
    PIECE VALUE BONUS MIDDLEGAME (EVAL) += (multiplier * Scaled Piece Value[piece num]);
    PIECE VALUE BONUS ENDGAME (EVAL) += (multiplier * Scaled Piece Value (Endgame)[piece num]);
}

Define change shelter val by:(string delta eval) scaled to material:(string scaled to material) white perspective?(bool white) (warp=true)
{
    If white
    {
        If (scaled to material > 2500)
        {
            White King Shelter Val += Operator.Round((delta eval * (scaled to material / 3200)));
        }
        Else
        {
            White King Shelter Val += Operator.Round((delta eval * (scaled to material / 6400)));
        }
    }
    Else
    {
        If (scaled to material > 2500)
        {
            Black King Shelter Val += Operator.Round((delta eval * (scaled to material / 3200)));
        }
        Else
        {
            Black King Shelter Val += Operator.Round((delta eval * (scaled to material / 6400)));
        }
    }
}

Define check if file:(string file) has piece:(string piece) (warp=true)
{
    file has target piece res = 0;
    If (Current Board Position[(file + (8 * 0))] == piece)
    {
        file has target piece res = 1;
        Stop(this script);
    }
    If (Current Board Position[(file + (8 * 1))] == piece)
    {
        file has target piece res = 1;
        Stop(this script);
    }
    If (Current Board Position[(file + (8 * 2))] == piece)
    {
        file has target piece res = 1;
        Stop(this script);
    }
    If (Current Board Position[(file + (8 * 3))] == piece)
    {
        file has target piece res = 1;
        Stop(this script);
    }
    If (Current Board Position[(file + (8 * 4))] == piece)
    {
        file has target piece res = 1;
        Stop(this script);
    }
    If (Current Board Position[(file + (8 * 5))] == piece)
    {
        file has target piece res = 1;
        Stop(this script);
    }
    If (Current Board Position[(file + (8 * 6))] == piece)
    {
        file has target piece res = 1;
        Stop(this script);
    }
    If (Current Board Position[(file + (8 * 7))] == piece)
    {
        file has target piece res = 1;
        Stop(this script);
    }
}

Define check knight mobility with delta rank:(string delta rank) delta file:(string delta file) white perspective?:(bool white?) (warp=true)
{
    piece attacked during mobility check (eval) = "";
    mobility in direction res = 0;
    Call get rank and file from square index:(counter for evaluation);
    temp file for mob. calc (eval) = file from square index;
    temp rank for mob. calc (eval) = rank from square index;
    temp file for mob. calc (eval) += delta file;
    temp rank for mob. calc (eval) += delta rank;
    If (((temp file for mob. calc (eval) > 8) Or (temp file for mob. calc (eval) < 1)) Or ((temp rank for mob. calc (eval) > 8) Or (temp rank for mob. calc (eval) < 1)))
    {
        Stop(this script);
    }
    Call get square idx with rank:(temp rank for mob. calc (eval)) file:(temp file for mob. calc (eval));
    piece attacked during mobility check (eval) = (Current Board Position[square idx from rank and file res] + 0);
    mobility piece type (eval) = (Current Board Position[counter for evaluation] + 0);
    If white?
    {
        If (square idx from rank and file res == blackKingID(eval))
        {
            BlackKingisAttacked (eval) += 1;
        }
        List.ReplaceItem(num white attacks on square (eval), square idx from rank and file res, (num white attacks on square (eval)[square idx from rank and file res] + 1));
        Call try to add flank attack black king with square:(square idx from rank and file res);
        Call get chebyshev distance from square:(square idx from rank and file res) to square 2:(whiteKingID(eval));
        If (distance from square to square == 1)
        {
            num white king knight defenders (eval) += 1;
            knight is king defender (eval) = 1;
        }
        If (Mobility Area White[square idx from rank and file res] == 1)
        {
            mobility in direction res = 1;
        }
        If (Black King Ring (eval)[square idx from rank and file res] == 1)
        {
            knight attacks their king ring (eval) += 1;
            Call get chebyshev distance from square:(square idx from rank and file res) to square 2:(blackKingID(eval));
            If (distance from square to square < 2)
            {
                num black king attacks (eval) += 1;
            }
        }
        If (Black Pawn Attacks Square (eval)[square idx from rank and file res] == 0)
        {
            If (piece attacked during mobility check (eval) < 0)
            {
                knight attacks weak piece (eval) += abs((Current Board Position[square idx from rank and file res] / 100));
            }
        }
        If (piece attacked during mobility check (eval) == -900)
        {
            knight attacks queen (eval) += 1;
        }
        If (piece attacked during mobility check (eval) == -500)
        {
            knight attacks rook (eval) += 1;
        }
        If (piece attacked during mobility check (eval) < 1)
        {
            Call // comment("black piece or empty square");
            Call is square outpost?(square idx from rank and file res)(white?) (eval);
            knight reachable outposts (eval) += is square outpost res (eval);
            Call does piece type:(320) on square:(square idx from rank and file res) check square:(blackKingID(eval)) ignore piece:("") ?;
            If (piece check square res (WD) == 1)
            {
                List.Add(White Checks (eval), square idx from rank and file res);
                List.Add(White Checks Source (eval), Current Board Position[counter for evaluation]);
            }
            If (Black Pawn Attacks Square (eval)[square idx from rank and file res] == 0)
            {
                Call does piece type:(mobility piece type (eval)) on square:(square idx from rank and file res) check square:(BlackQueenID(eval)) ignore piece:("") ?;
                If (piece check square res (WD) == 1)
                {
                    List.Add(Black Queen Threat Squares (eval), square idx from rank and file res);
                    List.Add(Black Queen Threat Squares Source (eval), mobility piece type (eval));
                }
            }
        }
    }
    Else
    {
        If (square idx from rank and file res == whiteKingID(eval))
        {
            WhiteKingIsAttacked (eval) += 1;
        }
        List.ReplaceItem(num black attacks on square (eval), square idx from rank and file res, (num black attacks on square (eval)[square idx from rank and file res] + 1));
        Call try to add flank attack white king with square:(square idx from rank and file res);
        Call get chebyshev distance from square:(square idx from rank and file res) to square 2:(blackKingID(eval));
        If (distance from square to square == 1)
        {
            num black king knight defenders (eval) += 1;
            knight is king defender (eval) = 1;
        }
        If (Mobility Area Black[square idx from rank and file res] == 1)
        {
            mobility in direction res = 1;
        }
        If (White King Ring (eval)[square idx from rank and file res] == 1)
        {
            knight attacks their king ring (eval) += 1;
            Call get chebyshev distance from square:(square idx from rank and file res) to square 2:(whiteKingID(eval));
            If (distance from square to square < 2)
            {
                num white king attacks (eval) += 1;
            }
        }
        If (Black Pawn Attacks Square (eval)[square idx from rank and file res] == 0)
        {
            If (piece attacked during mobility check (eval) > 0)
            {
                knight attacks weak piece (eval) += abs((Current Board Position[square idx from rank and file res] / 100));
            }
        }
        If (piece attacked during mobility check (eval) == 900)
        {
            knight attacks queen (eval) += 1;
        }
        If (piece attacked during mobility check (eval) == 500)
        {
            knight attacks rook (eval) += 1;
        }
        If (piece attacked during mobility check (eval) > -1)
        {
            Call // comment("white piece or empty square");
            Call is square outpost?(square idx from rank and file res)(white?) (eval);
            knight reachable outposts (eval) += is square outpost res (eval);
            Call does piece type:(-320) on square:(square idx from rank and file res) check square:(whiteKingID(eval)) ignore piece:("") ?;
            If (piece check square res (WD) == 1)
            {
                List.Add(Black Checks (eval), square idx from rank and file res);
                List.Add(Black Checks Source (eval), Current Board Position[counter for evaluation]);
            }
            If (White Pawn Attacks Square (eval)[square idx from rank and file res] == 0)
            {
                Call does piece type:(mobility piece type (eval)) on square:(square idx from rank and file res) check square:(WhiteQueenID(eval)) ignore piece:("") ?;
                If (piece check square res (WD) == 1)
                {
                    List.Add(White Queen Threat Squares (eval), square idx from rank and file res);
                    List.Add(White Queen Threat Squares Source (eval), mobility piece type (eval));
                }
            }
        }
    }
}

Define clear info before move gen (warp=true)
{
    List.DeleteAll(PiecePinnedDirection);
    List.DeleteAll(# Opposing Attacks Square);
    List.DeleteAll(op pawn attack square);
    List.DeleteAll(# side to move attacking square (move gen));
    List.DeleteAll(side to move attack square piece square (move gen));
    List.DeleteAll(side to move attack square piece square 2 (move gen));
    Repeat (64)
    {
        List.Add(PiecePinnedDirection, "");
        List.Add(# Opposing Attacks Square, 0);
        List.Add(# side to move attacking square (move gen), 0);
        List.Add(side to move attack square piece square (move gen), 00);
        List.Add(side to move attack square piece square 2 (move gen), 00);
        List.Add(op pawn attack square, 0);
    }
    List.DeleteAll(PieceMovingDirection);
    List.DeleteAll(ALL LEGAL MOVES FOR CPU CALCS);
    List.DeleteAll(SquaresToBeCoveredForCheck);
}

Define clear large runtime generated data (warp=true)
{
    List.DeleteAll(PIECE TYPE TO ID);
    List.DeleteAll(Iterative Deepening DEBUG);
    List.DeleteAll(Zero Before Single Digit Numbers (1 offset));
    List.DeleteAll(Zero Before 1-3 => 4 Digit Num (1 offset));
    List.DeleteAll(PSQTs fast read list);
    List.DeleteAll(MASSIVE LIST TO VERIFY CHECKS);
    List.DeleteAll(PIECE TYPE TO CHECK CHUNK);
    List.DeleteAll(book finder current book);
    List.DeleteAll(A1 - H8 to #);
    List.DeleteAll(PV_moves);
    List.DeleteAll(Square Color);
    List.DeleteAll(Training Set Batch Pos => Board State);
    List.DeleteAll(WD_NNUE_debugging_list);
    List.DeleteAll(Chebyshev Distance to Square);
    List.DeleteAll(dir from square to square);
    List.DeleteAll(Knight Movement Table);
    List.DeleteAll(White Pawn Movement Table);
    List.DeleteAll(Black Pawn Movement Table);
    List.DeleteAll(Rank From Square Index);
    List.DeleteAll(File From Square Index);
    List.DeleteAll(REPETITION TABLE);
    List.DeleteAll(REPETITION TABLE SIDE TO MOVE);
    List.DeleteAll(Knight Movement Table Endsquare);
    List.DeleteAll(Manhattan Distance To Square);
    List.DeleteAll(Board Hash At Depth);
    List.DeleteAll(Current Board Position);
    List.DeleteAll(Day of Week);
    List.DeleteAll(MinMax Results);
    List.DeleteAll(OP KING ID AT DEPTH);
    List.DeleteAll(PV Res At Depth);
    List.DeleteAll(PV_length);
    List.DeleteAll(Search Node State:);
    List.DeleteAll(WD_CastlingRights);
    List.DeleteAll(WD_EnPassantTarget);
    List.DeleteAll(# Opposing Attacks Square);
    List.DeleteAll(# side to move attacking square (move gen));
    List.DeleteAll(Alphas);
    List.DeleteAll(Betas);
    List.DeleteAll(Alphas Temp);
    List.DeleteAll(Betas Temp);
    List.DeleteAll(Apply Num Extensions At Depth);
    List.DeleteAll(Best Move);
    List.DeleteAll(Best Score Temp);
    List.DeleteAll(BestMoveIndex);
    List.DeleteAll(black area counter (eval));
    List.DeleteAll(Black King Ring (eval));
    List.DeleteAll(white area counter (eval));
    List.DeleteAll(White King Ring (eval));
    List.DeleteAll(BoardAttackedBySideToMovePieceSnapshot);
    List.DeleteAll(BoardAttackedBySideToMovePieceSnapshot 2);
    List.DeleteAll(BoardAttackedBySideToMoveSnapshot);
    List.DeleteAll(Exclude Move at Depth);
    List.DeleteAll(Is Futility Pruned?);
    List.DeleteAll(ITERATIVE IDX BEST MOVE IN POS);
    List.DeleteAll(ITERATIVE IDX EVAL AT POS);
    List.DeleteAll(KillerMoves);
    List.DeleteAll(Large Positional in Static Eval at Depth);
    List.DeleteAll(MaxEval);
    List.DeleteAll(MinEval);
    List.DeleteAll(Minmax Res Temp);
    List.DeleteAll(Next Ply Board Hash);
    List.DeleteAll(Board Hash At Depth);
    List.DeleteAll(PiecePinnedDirection);
    clear large info idx = 0;
    Repeat (30)
    {
        clear large info idx += 1;
        Call delete depth:(clear large info idx) for move storage | clear move count?((1 == 1));
    }
}

Define clear TT table with size:(string size) (warp=true)
{
    TTcurrentAge = 0;
    List.DeleteAll(TTnodeAge);
    List.DeleteAll(TTnodeDepth);
    List.DeleteAll(TTnodeHash);
    List.DeleteAll(TTnodeHorizon);
    List.DeleteAll(TTnodeScore);
    List.DeleteAll(TTnodeBestMove);
    List.DeleteAll(TTnodeType);
    List.DeleteAll(TTnodeMaxDepth);
    List.DeleteAll(TTnodeLine);
    List.DeleteAll(TTnodeIDidx);
    List.DeleteAll(TTnodeQSstartDepth);
    List.DeleteAll(TTnodeBoardAttacked);
    List.DeleteAll(TTnodeBoardAttackedSource);
    List.DeleteAll(TTnodeBoardAttackedSource2);
    Repeat (size)
    {
        List.Add(TTnodeIDidx, "");
        List.Add(TTnodeAge, "");
        List.Add(TTnodeDepth, "");
        List.Add(TTnodeHash, "");
        List.Add(TTnodeHorizon, "");
        List.Add(TTnodeScore, "");
        List.Add(TTnodeBestMove, "");
        List.Add(TTnodeType, "");
        List.Add(TTnodeMaxDepth, "");
        List.Add(TTnodeLine, "");
        List.Add(TTnodeQSstartDepth, "");
        List.Add(TTnodeBoardAttacked, "");
        List.Add(TTnodeBoardAttackedSource, "");
        List.Add(TTnodeBoardAttackedSource2, "");
    }
}

Define closest piece from square idx:(string square idx) delta rank:(string delta rank) delta file:(string delta file) (warp=true)
{
    closest piece from square res = 0;
    Call get rank and file from square index:(square idx);
    temp rank for closest piece = rank from square index;
    temp file for closest piece = file from square index;
    Repeat (7)
    {
        temp rank for closest piece += delta rank;
        temp file for closest piece += delta file;
        If ((temp rank for closest piece > 8) Or (temp rank for closest piece < 1))
        {
            Stop(this script);
        }
        If ((temp file for closest piece > 8) Or (temp file for closest piece < 1))
        {
            Stop(this script);
        }
        Call get square idx with rank:(temp rank for closest piece) file:(temp file for closest piece);
        If (abs(Current Board Position[square idx from rank and file res]) > 0)
        {
            closest piece from square res = Current Board Position[square idx from rank and file res];
            Stop(this script);
        }
    }
}

Define complicated drawn ending scaler helper(string scale down)(string their king id)(string is opposition?)(string opposition bonus) (eval) (warp=true)
{
    possible to win finished (eval) = 1;
    Call scale down eval value:(scale down);
    BOARD EVAL += CPU CONTEMPT VALUE;
    If ((WD_distance_to_closest_edge[their king id] == 0) And (is opposition? == 1))
    {
        BOARD EVAL += opposition bonus;
    }
}

Define contact safe check bonus (eval)(string square)(string their king id) (warp=true)
{
    Call get chebyshev distance from square:(square) to square 2:(their king id);
    If (distance from square to square == 1)
    {
        num safe checks res (eval) += 2;
        If (WD_distance_to_closest_edge[their king id] == 0)
        {
            num safe checks res (eval) += 1;
            Call get manhattan distance from square:(square) to square 2:(their king id);
            If (distance from square to square == 1)
            {
                num safe checks res (eval) += 2;
            }
        }
    }
}

Define convert from uci to WD (from force move on real board)(string num 1) (warp=true)
{
    force move on real board to WD temp res = Zero Before Single Digit Numbers (1 offset)[(List.IndexOf(A1 - H8 to #, Operator.Join(Operator.LetterOf(FORCE MOVE ON REAL BOARD, (num 1 + 0)), Operator.LetterOf(FORCE MOVE ON REAL BOARD, (num 1 + 1)))) + 1)];
}

Define convert from uci to WD (from force move on real board) wrapper(string start)(string end) (warp=true)
{
    Call convert from uci to WD (from force move on real board)(start);
    force move on real board start = force move on real board to WD temp res;
    Call convert from uci to WD (from force move on real board)(end);
    force move on real board end = force move on real board to WD temp res;
}

Define convert other UCI engine input move to WD format with their output:(string their output) (warp=true)
{
    FORCE MOVE COLOR ON REAL BOARD = PLAYER COLOR;
    other UCI engine input move = Operator.Join(Operator.LetterOf(their output, 10), Operator.Join(Operator.LetterOf(their output, 11), Operator.Join(Operator.LetterOf(their output, 12), Operator.Join(Operator.LetterOf(their output, 13), Operator.Join(Operator.LetterOf(their output, 14), Operator.Join(Operator.LetterOf(their output, 15), Operator.Join(Operator.LetterOf(their output, 16), Operator.Join(Operator.LetterOf(their output, 17), Operator.LetterOf(their output, 18)))))))));
    FORCE MOVE ON REAL BOARD = other UCI engine input move;
    If (other UCI engine input move == "O-O")
    {
        If (PLAYER COLOR == "w")
        {
            FORCE MOVE ON REAL BOARD = WhiteKingSideCastle;
        }
        Else
        {
            FORCE MOVE ON REAL BOARD = BlackKingSideCastle;
        }
    }
    Else
    {
        If (other UCI engine input move == "O-O-O")
        {
            If (PLAYER COLOR == "w")
            {
                FORCE MOVE ON REAL BOARD = WhiteQueenSideCastle;
            }
            Else
            {
                FORCE MOVE ON REAL BOARD = BlackQueenSideCastle;
            }
        }
        Else
        {
            If Operator.Contains(other UCI engine input move, "x")
            {
                If (Variable.Length(other UCI engine input move) == 5)
                {
                    Call convert from uci to WD (from force move on real board) wrapper(1)(4);
                }
                Else
                {
                    Call convert from uci to WD (from force move on real board) wrapper(2)(5);
                }
            }
            Else
            {
                If (Variable.Length(other UCI engine input move) == 4)
                {
                    Call convert from uci to WD (from force move on real board) wrapper(1)(3);
                }
                Else
                {
                    Call convert from uci to WD (from force move on real board) wrapper(2)(4);
                }
            }
            FORCE MOVE ON REAL BOARD = Operator.Join(force move on real board start, force move on real board end);
        }
    }
}

Define convert WD best move to UCI format (warp=true)
{
    WD_last_piece_moved(convert WD to UCI form.) = abs(GAME MOVES (PIECES MOVED)[List.Length(GAME MOVES (PIECES MOVED))]);
    If (WD_best move == "stop")
    {
        WD to Scratch UCI Move Res = "stop";
        Stop(this script);
    }
    If ((WD_best move == WhiteKingSideCastle) Or (WD_best move == BlackKingSideCastle))
    {
        WD to Scratch UCI Move Res = "O-O";
        Stop(this script);
    }
    If ((WD_best move == WhiteQueenSideCastle) Or (WD_best move == BlackQueenSideCastle))
    {
        WD to Scratch UCI Move Res = "O-O-O";
        Stop(this script);
    }
    If (WD_last_piece_moved(convert WD to UCI form.) > 100)
    {
        WD to Scratch UCI moving piece type = Pieces ID PGN/FEN Capital[List.IndexOf(Pieces ID, WD_last_piece_moved(convert WD to UCI form.))];
    }
    Else
    {
        WD to Scratch UCI moving piece type = "";
    }
    WD to Scratch UCI Move Res = Operator.Join(WD to Scratch UCI moving piece type, A1 - H8 to #[floor((WD_best move / 100))]);
    If (real board move application is capture? == 1)
    {
        WD to Scratch UCI Move Res = Operator.Join(WD to Scratch UCI moving piece type, "x");
    }
    Else
    {
        WD to Scratch UCI Move Res = Operator.Join(WD to Scratch UCI moving piece type, A1 - H8 to #[floor((WD_best move % 100))]);
    }
    If (WD_last_piece_moved(convert WD to UCI form.) == 100)
    {
        If ((floor((WD_best move % 100)) < 9) Or (floor((WD_best move % 100)) > 56))
        {
            WD to Scratch UCI Move Res = Operator.Join(WD to Scratch UCI Move Res, "=Q");
        }
    }
}

Define createCurrentBoardHash with depth:(string depth) (warp=true)
{
    currentBoardHash = 0;
    counter for creating board hash = 0;
    Repeat (64)
    {
        counter for creating board hash += 1;
        Call change board hash with piece:(Current Board Position[counter for creating board hash]) pos:(counter for creating board hash);
    }
    currentBoardHash += (WD_side key (hash table) * ((depth % 2) == 1));
}

Define custom debug data with depth:(string debug depth) target depth:(string target depth) message after depth:(string msg) display current move:(string display current move) header message:(string header message) max depth:(string max depth) log after move #:(string log after move #) (warp=true)
{
    If (debug depth == target depth)
    {
        If (Moves Index[debug depth] < log after move #)
        {
            Stop(this script);
        }
        If (header message > "")
        {
            Call ​​log​​(header message);
        }
        Call ​​log​​("==========================================");
        Call ​​log​​(Operator.Join(Operator.Join(Operator.Join(Operator.Join(Operator.Join("depth: ", debug depth), " | move depth: "), Real Search Depth For Move[debug depth]), " | "), msg));
        Call ​​log​​(Operator.Join("max depth: ", max depth));
        Call ​​log​​(Operator.Join("MOVES IDX: ", Operator.Join(Moves Index[debug depth], Operator.Join("  /  ", Moves Count[debug depth]))));
        Call ​​log​​(Operator.Join("current move (in depth): ", display current move));
        Call ​​log​​(Operator.Join("best move: ", Best Move[debug depth]));
        Call ​​log​​(Operator.Join("min eval: ", MinEval[debug depth]));
        Call ​​log​​(Operator.Join("max eval: ", MaxEval[debug depth]));
        Call ​​log​​(Operator.Join("minmax res: ", MinMax Results[debug depth]));
        Call ​​log​​(Operator.Join("next minmax res: ", MinMax Results[(debug depth + 1)]));
        Call ​​log​​(Operator.Join("d + 1 search node state: ", Search Node State:[(debug depth + 1)]));
        Call ​​log​​(Eval/Score);
        Call ​​log​​(promotionBonus?);
        Call ​​log​​(Operator.Join("castling rights: ", WD_CastlingRights[debug depth]));
        Call ​​log​​(eval is draw (repetition));
        Call ​​log​​(Operator.Join("Starts in Check?: ", StartsInCheck?[debug depth]));
        Call ​​log​​(Operator.Join("Puts in Check?: ", PutsInCheck?[debug depth]));
        Call ​​log​​(Operator.Join("Puts in Check (d - 1)?: ", PutsInCheck?[(debug depth - 1)]));
        Call ​​log​​(Operator.Join("target pieces (depth): ", targetPieces[debug depth]));
        Call ​​log​​(Operator.Join("target pieces (depth-1): ", targetPieces[(debug depth - 1)]));
        Call ​​log​​(Operator.Join("Fully Legal Move Gen?: ", Fully Legal Move Gen?[debug depth]));
        Call ​​log​​(Operator.Join("Futility pruned?: ", Is Futility Pruned?[debug depth]));
        Call ​​log​​(Operator.Join("d+1 futility pruned?: ", Is Futility Pruned?[(debug depth + 1)]));
        Call ​​log​​(Operator.Join(Operator.Join("d+1 move: ", Moves Played In Search[(debug depth + 1)]), Operator.Join(Operator.Join(" | d+1 best move: ", Best Move[(debug depth + 1)]), Operator.Join(" | d+1 hash move: ", Hash Move[(debug depth + 1)]))));
        Call ​​log​​(TTentryUsed?[(debug depth + 1)]);
        Call ​​log​​(TTentryUsed (line)[(debug depth + 1)]);
        Call ​​log​​(Operator.Join("Alpha: ", Alphas[debug depth]));
        Call ​​log​​(Operator.Join("Beta: ", Betas[debug depth]));
        Call ​​log​​(Operator.Join("Next Alpha: ", Alphas[(debug depth + 1)]));
        Call ​​log​​(Operator.Join("Next Beta: ", Betas[(debug depth + 1)]));
        Call ​​log​​(Operator.Join(Operator.Join("Board Eval: ", BOARD EVAL), Operator.Join(Operator.Join(" | Static Eval At Depth: ", STATIC EVAL AT DEPTH[debug depth]), Operator.Join(" | Stand-pat eval: ", Stand-Pat[debug depth]))));
        Call ​​log​​("==========================================");
    }
}

Define dataset extractor with rule (warp=true)
{
    List.DeleteAll(DATASET EXTRACT OUTPUT);
    dataset extract with rule idx = 0;
    Repeat (List.Length(DATASET EXTRACT INPUT))
    {
        dataset extract with rule idx += 1;
        Call load FEN:(DATASET EXTRACT INPUT[dataset extract with rule idx]);
        Call evaluation of current position with depth:(((1 * (Who To Move? (WD) == "b")) + 2)) force HCE:(1) log debug:();
        Call rule for dataset extractor;
    }
}

Define delete depth:(string depth) for move storage | clear move count?(bool clear move count?) (warp=true)
{
    If clear move count?
    {
        List.ReplaceItem(Moves Count, depth, 0);
    }
    If (depth < 11)
    {
        If (depth == 1)
        {
            List.DeleteAll(MovesDepth 1);
            Stop(this script);
        }
        If (depth == 2)
        {
            List.DeleteAll(MovesDepth 2);
            Stop(this script);
        }
        If (depth == 3)
        {
            List.DeleteAll(MovesDepth 3);
            Stop(this script);
        }
        If (depth == 4)
        {
            List.DeleteAll(MovesDepth 4);
            Stop(this script);
        }
        If (depth == 5)
        {
            List.DeleteAll(MovesDepth 5);
            Stop(this script);
        }
        If (depth == 6)
        {
            List.DeleteAll(MovesDepth 6);
            Stop(this script);
        }
        If (depth == 7)
        {
            List.DeleteAll(MovesDepth 7);
            Stop(this script);
        }
        If (depth == 8)
        {
            List.DeleteAll(MovesDepth 8);
            Stop(this script);
        }
        If (depth == 9)
        {
            List.DeleteAll(MovesDepth 9);
            Stop(this script);
        }
        If (depth == 10)
        {
            List.DeleteAll(MovesDepth 10);
            Stop(this script);
        }
        Stop(this script);
    }
    If (depth < 21)
    {
        If (depth == 11)
        {
            List.DeleteAll(MovesDepth 11);
            Stop(this script);
        }
        If (depth == 12)
        {
            List.DeleteAll(MovesDepth 12);
            Stop(this script);
        }
        If (depth == 13)
        {
            List.DeleteAll(MovesDepth 13);
            Stop(this script);
        }
        If (depth == 14)
        {
            List.DeleteAll(MovesDepth 14);
            Stop(this script);
        }
        If (depth == 15)
        {
            List.DeleteAll(MovesDepth 15);
            Stop(this script);
        }
        If (depth == 16)
        {
            List.DeleteAll(MovesDepth 16);
            Stop(this script);
        }
        If (depth == 17)
        {
            List.DeleteAll(MovesDepth 17);
            Stop(this script);
        }
        If (depth == 18)
        {
            List.DeleteAll(MovesDepth 18);
            Stop(this script);
        }
        If (depth == 19)
        {
            List.DeleteAll(MovesDepth 19);
            Stop(this script);
        }
        If (depth == 20)
        {
            List.DeleteAll(MovesDepth 20);
            Stop(this script);
        }
        Stop(this script);
    }
    If (depth < 31)
    {
        If (depth == 21)
        {
            List.DeleteAll(MovesDepth 21);
            Stop(this script);
        }
        If (depth == 22)
        {
            List.DeleteAll(MovesDepth 22);
            Stop(this script);
        }
        If (depth == 23)
        {
            List.DeleteAll(MovesDepth 23);
            Stop(this script);
        }
        If (depth == 24)
        {
            List.DeleteAll(MovesDepth 24);
            Stop(this script);
        }
        If (depth == 25)
        {
            List.DeleteAll(MovesDepth 25);
            Stop(this script);
        }
        If (depth == 26)
        {
            List.DeleteAll(MovesDepth 26);
            Stop(this script);
        }
        If (depth == 27)
        {
            List.DeleteAll(MovesDepth 27);
            Stop(this script);
        }
        If (depth == 28)
        {
            List.DeleteAll(MovesDepth 28);
            Stop(this script);
        }
        If (depth == 29)
        {
            List.DeleteAll(MovesDepth 29);
            Stop(this script);
        }
        If (depth == 30)
        {
            List.DeleteAll(MovesDepth 30);
            Stop(this script);
        }
        Stop(this script);
    }
}

Define does king id:(string id) attack square:(string square) (eval) (warp=true)
{
    king id attacks square res (eval) = 0;
    Call get chebyshev distance from square:(square) to square 2:(id);
    If (distance from square to square < 2)
    {
        king id attacks square res (eval) = 1;
    }
}

Define does piece on square:(string start square) discover check square:(string check square) with depth:(string depth) (warp=true)
{
    does piece discover check square res = 0;
    Call // comment("the start square of the piece is attacked (including "pseudo-attacks" by own pieces)");
    Call // comment("this function should only get triggered after makemove");
    If (Operator.LetterOf(BoardAttackedBySideToMoveSnapshot[depth], start square) > 0)
    {
        source of attack (discovery check verification) = ((Operator.LetterOf(BoardAttackedBySideToMovePieceSnapshot[depth], ((start square * 2) - 1)) * 10) + Operator.LetterOf(BoardAttackedBySideToMovePieceSnapshot[depth], (start square * 2)));
        If (abs(Current Board Position[(source of attack (discovery check verification) + 0)]) > 320)
        {
            Call does piece type:(Current Board Position[(source of attack (discovery check verification) + 0)]) on square:(source of attack (discovery check verification)) check square:(check square) ignore piece:("") ?;
            If (piece check square res (WD) == 1)
            {
                does piece discover check square res = piece check square res (WD);
                Stop(this script);
            }
        }
    }
    If (Operator.LetterOf(BoardAttackedBySideToMovePieceSnapshot 2[depth], start square) > 0)
    {
        source of attack (discovery check verification) = ((Operator.LetterOf(BoardAttackedBySideToMovePieceSnapshot 2[depth], ((start square * 2) - 1)) * 10) + Operator.LetterOf(BoardAttackedBySideToMovePieceSnapshot 2[depth], (start square * 2)));
        If (abs(Current Board Position[(source of attack (discovery check verification) + 0)]) > 320)
        {
            Call does piece type:(Current Board Position[(source of attack (discovery check verification) + 0)]) on square:(source of attack (discovery check verification)) check square:(check square) ignore piece:("") ?;
            does piece discover check square res = piece check square res (WD);
        }
    }
}

Define does piece type:(string piece type) on square:(string start square) check square:(string target square) ignore piece:(string ignore piece) ? (warp=true)
{
    piece check square res (WD) = 0;
    If ((abs(piece type) == 99999) Or (abs(piece type) == 0))
    {
        Stop(this script);
    }
    potential check direction (for check gen) = (MASSIVE LIST TO VERIFY CHECKS[((((PIECE TYPE TO CHECK CHUNK[(piece type + 1000)] - 1) * (64 * 64)) + ((start square - 1) * 64)) + target square)] + 0);
    If (Not ((potential check direction (for check gen) > 0)))
    {
        Call // comment("if the direction is not larger than 0, it must mean that the piece will NEVER check the other square");
        Call // comment("even on an empty board! So therefore, we'll stop the script.");
        Stop(this script);
    }
    If (potential check direction (for check gen) == 99)
    {
        Call // comment("if the potential check direction is 99, that means it's a pawn or a knight, which does not need");
        Call // comment("additional verifications");
        piece check square res (WD) = 1;
        Stop(this script);
    }
    Call get distance to edge with index:(start square) //  CHECK DETECTION;
    If (Distance To Each Edge (Check Detection)[(potential check direction (for check gen) + 0)] == 0)
    {
        piece check square res (WD) = 0;
        Stop(this script);
    }
    temp square index to get potential check (for check gen) = start square;
    counter to get potential check (for check gen) = 0;
    Repeat (Distance To Each Edge (Check Detection)[(potential check direction (for check gen) + 0)])
    {
        counter to get potential check (for check gen) += 1;
        temp square index to get potential check (for check gen) += direction offsets for sliding pieces[(potential check direction (for check gen) + 0)];
        If (temp square index to get potential check (for check gen) == target square)
        {
            piece check square res (WD) = 1;
            Stop(this script);
        }
        Else
        {
            If (abs(Current Board Position[(temp square index to get potential check (for check gen) + 0)]) > 0)
            {
                If (Not ((Current Board Position[temp square index to get potential check (for check gen)] == ignore piece)))
                {
                    piece check square res (WD) = 0;
                    Stop(this script);
                }
            }
        }
    }
}

Define easy winning position (eval) (warp=true)
{
    If ((NUM WHITE PIECES (NOT PAWNS) (EVAL) == 0) And ((NUM BLACK MAJOR PIECES (EVAL) > 0) Or (NUM BLACK MINOR PIECES (EVAL) > 2)))
    {
        BOARD EVAL += -5000;
        possible to win finished (eval) = 1;
        Stop(this script);
    }
    If ((NUM BLACK PIECES (NOT PAWNS) (EVAL) == 0) And ((NUM WHITE MAJOR PIECES (EVAL) > 0) Or (NUM WHITE MINOR PIECES (EVAL) > 2)))
    {
        BOARD EVAL += 5000;
        possible to win finished (eval) = 1;
        Stop(this script);
    }
}

Define engine search code (warp=true)
{
    Event.Broadcast("start of engine calcs");
    List.DeleteAll(BEST MOVES (LOG));
    List.DeleteAll(BEST MOVES EVAL (LOG));
    evaluated positions (WD) = 0;
    first search move = "????";
    start time for search = Sensing.DaysSince2000();
    WD_time for search = 0;
    isSearching? = 1;
    usedBook = "???";
    USED THIS MOVE (DEBUGGING OVERIDE) = 0;
    If (CPU COLOR == "b")
    {
        search starting depth = 1;
        If (Not ((USE THIS MOVE (DEBUGGING OVERIDE)[(List.Length(GAME MOVES) + 1)] == "")))
        {
            WD_best move = USE THIS MOVE (DEBUGGING OVERIDE)[(List.Length(GAME MOVES) + 1)];
            USED THIS MOVE (DEBUGGING OVERIDE) = 1;
        }
        If (USED THIS MOVE (DEBUGGING OVERIDE) == 0)
        {
            Call search book;
            If (loaded custom FEN? == 0)
            {
                Depth of Search = "Book";
            }
            If (usedBook == "???")
            {
                Call iterative deepening search;
            }
        }
    }
    Else
    {
        search starting depth = 2;
        Call evaluation of current position with depth:(((Who To Move? (WD) == "b") * 1)) force HCE:("") log debug:();
        Endgame Eval @ Search Start? = isEndgame? (for eval);
        Call reset start data for search;
        Call reset white CPU data;
        If (Not ((USE THIS MOVE (DEBUGGING OVERIDE)[(List.Length(GAME MOVES) + 1)] == "")))
        {
            WD_best move = USE THIS MOVE (DEBUGGING OVERIDE)[(List.Length(GAME MOVES) + 1)];
            WHITE CPU BEST MOVE = USE THIS MOVE (DEBUGGING OVERIDE)[(List.Length(GAME MOVES) + 1)];
            USED THIS MOVE (DEBUGGING OVERIDE) = 1;
        }
        If (USED THIS MOVE (DEBUGGING OVERIDE) == 0)
        {
            Call search book;
            If (loaded custom FEN? == 0)
            {
                Depth of Search = "Book";
            }
            If (usedBook == "???")
            {
                Call iterative deepening search;
            }
        }
    }
    Call get time for search;
    isSearching? = 0;
    Event.Broadcast("end of engine calcs");
}

Define evaluate all king safety (eval) (warp=true)
{
    Call // comment("BLACK KING SAFETY EVALUATION");
    Call Black King Safety;
    Call get num safe checks for perspective((1 == 1)) (eval);
    If (NUM WHITE QUEENS (EVAL) == 0)
    {
        Black King Attacked Val += -125;
    }
    Black King Attacked Val += (90 * num safe checks res (eval));
    Black King Attacked Val += (15 * unsafe checks total white (eval));
    Black King Attacked Val += (MOBILITY TOTAL TAPERED (EVAL) / 3);
    Black King Attacked Val += (0.35 * (((3 * flank attack white king counter (eval)) * flank attack white king counter (eval)) / 8));
    Black King Attacked Val += (-10 * num black king knight defenders (eval));
    Black King Attacked Val += (10 * num black king attacks (eval));
    Black King Attacked Val += (0.35 * Black King Shelter Val);
    If (Black King Attacked Val < 25)
    {
        Black King Attacked Val = 0;
    }
    If (WHITE MATERIAL (NO PAWNS) > 1200)
    {
        Call change board eval with mg term:(Black King Shelter Val) eg term:(0);
    }
    Call change board eval with mg term:(Black King Attacked Val) eg term:((Black King Attacked Val / 8));
    Call change board eval with mg term:((2 * (flank attack black king counter (eval) - flank attack white king counter (eval)))) eg term:(0);
    Call round eval (for evaluation function);
    List.ReplaceItem(EVAL DEBUG LIST, 10, Operator.Join(BOARD EVAL, " b"));
    Call // comment("WHITE KING SAFETY EVALUATION");
    Call White King Safety;
    Call get num safe checks for perspective((0 == 1)) (eval);
    If (NUM BLACK QUEENS (EVAL) == 0)
    {
        White King Attacked Val += 125;
    }
    White King Attacked Val += (-90 * num safe checks res (eval));
    White King Attacked Val += (-15 * unsafe checks total black (eval));
    White King Attacked Val += (MOBILITY TOTAL TAPERED (EVAL) / 3);
    White King Attacked Val += (-0.35 * (((3 * flank attack black king counter (eval)) * flank attack black king counter (eval)) / 8));
    White King Attacked Val += (10 * num white king knight defenders (eval));
    White King Attacked Val += (-10 * num white king attacks (eval));
    White King Attacked Val += (0.35 * White King Shelter Val);
    If (White King Attacked Val > -25)
    {
        White King Attacked Val = 0;
    }
    If (BLACK MATERIAL (NO PAWNS) > 1200)
    {
        Call change board eval with mg term:(White King Shelter Val) eg term:(0);
    }
    Call change board eval with mg term:(White King Attacked Val) eg term:((White King Attacked Val / 8));
    Call change board eval with mg term:((2 * (flank attack black king counter (eval) - flank attack white king counter (eval)))) eg term:(0);
    Call round eval (for evaluation function);
    List.ReplaceItem(EVAL DEBUG LIST, 10, Operator.Join(Operator.Join(EVAL DEBUG LIST[10], " | "), Operator.Join(BOARD EVAL, " w")));
    Call blockages (evaluation);
    Call round eval (for evaluation function);
    List.ReplaceItem(EVAL DEBUG LIST, 10, Operator.Join(Operator.Join(EVAL DEBUG LIST[10], " | "), Operator.Join(BOARD EVAL, " blocking")));
}

Define evaluation of current position with depth:(string depth) force HCE:(string force HCE) log debug:(bool log debug) (warp=true)
{
    Call reset info for eval function;
    Call force HCE for current position? (in eval);
    If ((USE NN FOR EVAL? == 1) And ((Not ((force HCE == 1))) And ((Not ((FORCE HCE DURING SEARCH? (NN MODE) == 1))) And (Not ((force HCE res (eval) == 1))))))
    {
        eval used HCE res = 0;
        If log debug
        {
            List.ReplaceItem(EVAL DEBUG LIST, 1, "NNUE eval:");
        }
        Call WD_NNUE_Evaluate // Side To Move is Black?((((depth % 2) == 1) * 1)) // use efficient acc update:(1);
        If ((depth % 2) == 1)
        {
            Call // comment("black to move (the NNUE always gives the eval relative to the side to move)");
            WD_NNUE_output_res = (WD_NNUE_output_res * -1);
        }
        Call round eval (for evaluation function);
        If log debug
        {
            List.ReplaceItem(EVAL DEBUG LIST, 18, Operator.Join("NNUE: ", BOARD EVAL));
        }
    }
    Else
    {
        eval used HCE res = 1;
        ENDGAME MATERIAL THRESHOLD = 3450;
        If log debug
        {
            List.ReplaceItem(EVAL DEBUG LIST, 1, "Piece Values for Hand Crafted Evaluation (eval)");
        }
        Call get info for evaluation function;
        If (whiteKingID(eval) == "no king")
        {
            BOARD EVAL = (0 - Scaled Piece Value[6]);
            If log debug
            {
                List.ReplaceItem(EVAL DEBUG LIST, 2, Operator.Join(BOARD EVAL, " no white king"));
            }
            Stop(this script);
        }
        If (blackKingID(eval) == "no king")
        {
            BOARD EVAL = Scaled Piece Value[6];
            If log debug
            {
                List.ReplaceItem(EVAL DEBUG LIST, 2, Operator.Join(BOARD EVAL, " no black king"));
            }
            Stop(this script);
        }
        If log debug
        {
            List.ReplaceItem(EVAL DEBUG LIST, 2, Operator.Join(BOARD EVAL, Operator.Join(Operator.Join(" | piece value: ", PIECE VALUE BONUS TOTAL (EVAL)), Operator.Join(Operator.Join(" | imbalance: ", IMBALANCE VALUE BONUS TOTAL (EVAL)), Operator.Join(" | space: ", space total res (eval))))));
            List.ReplaceItem(EVAL DEBUG LIST, 4, Operator.Join(Operator.Join("is endgame: ", isEndgame? (for eval)), Operator.Join(Operator.Join(Operator.Join("  //  simple endgame: ", isSimpleEndgame? (for eval)), "  //  eval: "), BOARD EVAL)));
        }
        If (draw by material? (eval) == 1)
        {
            If log debug
            {
                List.ReplaceItem(EVAL DEBUG LIST, 18, Operator.Join("DRAW //  ", BOARD EVAL));
            }
            Stop(this script);
        }
        pawn multiplier value (for eval) = 1;
        Call special pawn values (for eval);
        If log debug
        {
            List.ReplaceItem(EVAL DEBUG LIST, 6, BOARD EVAL);
        }
        Call Get Special Info (PST + Pawn + Others) For Eval With Depth:(depth);
        BOARD EVAL += king pawn tropism total value (eval);
        Call round eval (for evaluation function);
        If (WhiteKingIsAttacked (eval) > 0)
        {
            Call // comment("this prevents standpat when the king is hanging");
            BOARD EVAL = (0 - Scaled Piece Value[6]);
            If log debug
            {
                List.ReplaceItem(EVAL DEBUG LIST, 8, Operator.Join(BOARD EVAL, " white king hanging"));
            }
            Stop(this script);
        }
        If (BlackKingisAttacked (eval) > 0)
        {
            Call // comment("this prevents standpat when the king is hanging");
            BOARD EVAL = Scaled Piece Value[6];
            If log debug
            {
                List.ReplaceItem(EVAL DEBUG LIST, 2, Operator.Join(BOARD EVAL, " black king hanging"));
            }
            Stop(this script);
        }
        If log debug
        {
            List.ReplaceItem(EVAL DEBUG LIST, 8, Operator.Join(Operator.Join(BOARD EVAL, Operator.Join("  // K-P tropism: ", king pawn tropism total value (eval))), Operator.Join(Operator.Join("  // Pass Prox. : ", king passer proximity total (eval)), Operator.Join("  // Mob.: ", Operator.Join(Operator.Round((((MOBILITY mg (eval) * EVAL PHASE (eval)) + (MOBILITY eg (eval) * (128 - EVAL PHASE (eval)))) / 128)), Operator.Join(" ( ", Operator.Join(Operator.Join(MOBILITY mg (eval), Operator.Join("  |  ", MOBILITY eg (eval))), ")")))))));
            List.ReplaceItem(EVAL DEBUG LIST, 10, "[nothing yet]");
        }
        Call evaluate all king safety (eval);
        kingEndGameEval = 0;
        Used Mop-Up Eval? (evaluation) = 0;
        If ((NUM BLACK PAWNS (EVAL) + NUM WHITE PAWNS (EVAL)) == 0)
        {
            If (PIECE EVAL (NO PAWNS) > 0)
            {
                Call mop-up EVAL // perspective is white?((1 == 1));
            }
            If (PIECE EVAL (NO PAWNS) < 0)
            {
                Call mop-up EVAL // perspective is white?((0 == 1));
            }
        }
        If log debug
        {
            List.ReplaceItem(EVAL DEBUG LIST, 12, BOARD EVAL);
        }
        Call piece combo bonus/penalty (for eval);
        Call round eval (for evaluation function);
        If log debug
        {
            List.ReplaceItem(EVAL DEBUG LIST, 14, BOARD EVAL);
        }
        If ((depth % 2) == 1)
        {
            BOARD EVAL += -12.5;
            If ((BLACK MINOR PIECES DEVELOPED (EVAL) - WHITE MINOR PIECES DEVELOPED (EVAL)) > 1)
            {
                BOARD EVAL += -5;
            }
        }
        Else
        {
            BOARD EVAL += 12.5;
            If ((WHITE MINOR PIECES DEVELOPED (EVAL) - BLACK MINOR PIECES DEVELOPED (EVAL)) > 1)
            {
                BOARD EVAL += 5;
            }
        }
        Call round eval (for evaluation function);
        If log debug
        {
            List.ReplaceItem(EVAL DEBUG LIST, 16, BOARD EVAL);
        }
        Call possible to win (eval);
        BOARD EVAL = Operator.Round(BOARD EVAL);
        If log debug
        {
            List.ReplaceItem(EVAL DEBUG LIST, 18, BOARD EVAL);
            List.ReplaceItem(EVAL DEBUG LIST, 20, Operator.Join(Operator.Join("b # atk: ", num black king attackers (eval)), Operator.Join(Operator.Join(" // atk force: ", Operator.Round(black king attacking force)), Operator.Join(Operator.Join(" // w # atk: ", num white king attackers (eval)), Operator.Join(" // atk force: ", Operator.Round(white king attacking force))))));
            List.ReplaceItem(EVAL DEBUG LIST, 21, Operator.Join(Operator.Join(Operator.Join("MIDDLE  //  b PSTs: ", Black PSTs Middle (eval)), Operator.Join(" // w PSTs: ", White PSTs Middle (eval))), Operator.Join("  //  Total: ", (Black PSTs Middle (eval) + White PSTs Middle (eval)))));
            List.ReplaceItem(EVAL DEBUG LIST, 22, Operator.Join(Operator.Join(Operator.Join("END  //  b PSTs: ", Black PSTs End (eval)), Operator.Join(" // w PSTs: ", White PSTs End (eval))), Operator.Join("  //  Total: ", (Black PSTs End (eval) + White PSTs End (eval)))));
            List.ReplaceItem(EVAL DEBUG LIST, 23, Operator.Join(Operator.Join("Total PSTs: ", Operator.Round(((((White PSTs Middle (eval) + Black PSTs Middle (eval)) * EVAL PHASE (eval)) + ((White PSTs End (eval) + Black PSTs End (eval)) * (128 - EVAL PHASE (eval)))) / 128))), Operator.Join("  //  Phase: ", EVAL PHASE (eval))));
        }
    }
}

Define fast king movegen(bool only captures?)(bool allow checks?)(string depth) (warp=true)
{
    movegen inner idx = 0;
    Repeat (8)
    {
        movegen inner idx += 1;
        movegen endsquare = (movegen outer idx + direction offsets for sliding pieces[movegen inner idx]);
        movegen endsquare legal? = 0;
        If (Distance To Each Edge (movegen)[movegen inner idx] > 0)
        {
            movegen endsquare piece = (Current Board Position[movegen endsquare] + 0);
            Call fast movegen add attack on square:(movegen outer idx)(movegen endsquare);
            If (((movegen current piece > 0) And (movegen endsquare piece < 1)) Or ((movegen current piece < 0) And (movegen endsquare piece > -1)))
            {
                movegen endsquare legal? = 1;
                If only captures?
                {
                    If (Not ((movegen endsquare piece == 0)))
                    {
                        Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
                    }
                }
                Else
                {
                    Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
                }
            }
        }
    }
    If (Operator.LetterOf(movegen castling state, 1) == 1)
    {
        If ((Current Board Position[(movegen outer idx + 1)] == "") And ((Current Board Position[(movegen outer idx + 2)] == "") And (abs(Current Board Position[(movegen outer idx + 3)]) == 500)))
        {
            Call add move(00)((90 + (((depth + 1) % 2) * 2))) movegen(depth);
        }
    }
    If (Operator.LetterOf(movegen castling state, 2) == 1)
    {
        If ((Current Board Position[(movegen outer idx - 1)] == "") And ((Current Board Position[(movegen outer idx - 2)] == "") And ((Current Board Position[(movegen outer idx - 3)] == "") And (abs(Current Board Position[(movegen outer idx + 3)]) == 500))))
        {
            Call add move(00)((91 + (((depth + 1) % 2) * 2))) movegen(depth);
        }
    }
}

Define fast knight movegen(bool only captures?)(bool allow checks?)(string depth) (warp=true)
{
    movegen inner idx = 0;
    Repeat (8)
    {
        movegen inner idx += 1;
        movegen endsquare = Knight Movement Table Endsquare[(((movegen outer idx - 1) * 8) + movegen inner idx)];
        movegen endsquare piece = (Current Board Position[movegen endsquare] + 0);
        If (movegen endsquare > 0)
        {
            Call fast movegen add attack on square:(movegen outer idx)(movegen endsquare);
            If (((movegen current piece > 0) And (movegen endsquare piece < 1)) Or ((movegen current piece < 0) And (movegen endsquare piece > -1)))
            {
                movegen endsquare legal? = 1;
                If only captures?
                {
                    If (Not ((movegen endsquare piece == 0)))
                    {
                        Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
                    }
                    Else
                    {
                        If allow checks?
                        {
                            Call does piece type:(movegen current piece) on square:(movegen endsquare) check square:(their king square (fast movegen)) ignore piece:("") ?;
                            If (piece check square res (WD) == 1)
                            {
                                Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
                            }
                        }
                    }
                }
                Else
                {
                    Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
                }
            }
        }
    }
}

Define fast makemove for book finder start idx:(string start idx) end idx:(string end idx) move:(string move) (warp=true)
{
    If (move == BlackKingSideCastle)
    {
        List.ReplaceItem(Current Board Position, 5, "");
        List.ReplaceItem(Current Board Position, 7, -99999);
        List.ReplaceItem(Current Board Position, 8, "");
        List.ReplaceItem(Current Board Position, 6, -500);
        Stop(this script);
    }
    If (move == BlackQueenSideCastle)
    {
        List.ReplaceItem(Current Board Position, 5, "");
        List.ReplaceItem(Current Board Position, 3, -99999);
        List.ReplaceItem(Current Board Position, 1, "");
        List.ReplaceItem(Current Board Position, 4, -500);
        Stop(this script);
    }
    If (move == WhiteKingSideCastle)
    {
        List.ReplaceItem(Current Board Position, 61, "");
        List.ReplaceItem(Current Board Position, 63, 99999);
        List.ReplaceItem(Current Board Position, 64, "");
        List.ReplaceItem(Current Board Position, 62, 500);
        Stop(this script);
    }
    If (move == WhiteQueenSideCastle)
    {
        List.ReplaceItem(Current Board Position, 61, "");
        List.ReplaceItem(Current Board Position, 59, 99999);
        List.ReplaceItem(Current Board Position, 57, "");
        List.ReplaceItem(Current Board Position, 60, 500);
        Stop(this script);
    }
    If ((Current Board Position[start idx] == 100) And (end idx < 9))
    {
        List.ReplaceItem(Current Board Position, start idx, "");
        List.ReplaceItem(Current Board Position, end idx, 900);
        Stop(this script);
    }
    If ((Current Board Position[start idx] == -100) And (end idx > 56))
    {
        List.ReplaceItem(Current Board Position, start idx, "");
        List.ReplaceItem(Current Board Position, end idx, -900);
        Stop(this script);
    }
    List.ReplaceItem(Current Board Position, end idx, Current Board Position[start idx]);
    List.ReplaceItem(Current Board Position, start idx, "");
}

Define fast movegen add attack on square:(string start square)(string atk square) (warp=true)
{
    If (atk square == their king square (fast movegen))
    {
        opponent king hanging res (move gen) = 1;
    }
    List.ReplaceItem(# side to move attacking square (move gen), atk square, (# side to move attacking square (move gen)[atk square] + 1));
    If (side to move attack square piece square (move gen)[atk square] == 00)
    {
        List.ReplaceItem(side to move attack square piece square (move gen), atk square, start square);
    }
    Else
    {
        If (side to move attack square piece square 2 (move gen)[atk square] == 00)
        {
            List.ReplaceItem(side to move attack square piece square 2 (move gen), atk square, start square);
        }
    }
}

Define fast pawn capture movegen(string depth) (warp=true)
{
    If (movegen current piece == 100)
    {
        If (file from square index > 1)
        {
            Call pawn capture verification(1)(-9)(depth);
        }
        If (file from square index < 8)
        {
            Call pawn capture verification(1)(-7)(depth);
        }
    }
    Else
    {
        If (file from square index > 1)
        {
            Call pawn capture verification(-1)(7)(depth);
        }
        If (file from square index < 8)
        {
            Call pawn capture verification(-1)(9)(depth);
        }
    }
}

Define fast pawn push inner with offset:(string offset) their king id:(string their king id) prom rank:(string prom rank) start rank:(string start rank)(bool only captures?)(bool allow checks?)(string depth) (warp=true)
{
    movegen endsquare = (movegen outer idx + offset);
    If (Not (((Current Board Position[movegen endsquare] + 0) == 0)))
    {
        Stop(this script);
    }
    If (only captures? And (Not ((rank from square index == prom rank))))
    {
        If allow checks?
        {
            Call does piece type:(movegen current piece) on square:(movegen endsquare) check square:(their king id) ignore piece:("") ?;
            If (piece check square res (WD) == 1)
            {
                Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
            }
        }
    }
    Else
    {
        Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
    }
    If (Not ((rank from square index == start rank)))
    {
        Stop(this script);
    }
    movegen endsquare = (movegen outer idx + (offset * 2));
    If (Not (((Current Board Position[movegen endsquare] + 0) == 0)))
    {
        Stop(this script);
    }
    If only captures?
    {
        If allow checks?
        {
            Call does piece type:(movegen current piece) on square:(movegen endsquare) check square:(their king id) ignore piece:("") ?;
            If (piece check square res (WD) == 1)
            {
                Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
            }
        }
    }
    Else
    {
        Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
    }
}

Define fast pawn push move gen(bool only captures?)(bool allow checks?)(string depth) (warp=true)
{
    If (movegen current piece == 100)
    {
        Call fast pawn push inner with offset:(-8) their king id:(their king square (fast movegen)) prom rank:(7) start rank:(2)(only captures?)(allow checks?)(depth);
    }
    Else
    {
        Call fast pawn push inner with offset:(8) their king id:(their king square (fast movegen)) prom rank:(2) start rank:(7)(only captures?)(allow checks?)(depth);
    }
}

Define fast pseudo-legal move gen with depth:(string depth)(bool only captures?)(bool allow checks?)(bool store atk table?) (warp=true)
{
    Call fast reset info for movegen(depth);
    movegen outer idx = 0;
    If ((depth % 2) == 1)
    {
        Repeat (64)
        {
            movegen outer idx += 1;
            movegen current piece = (Current Board Position[movegen outer idx] + 0);
            If (movegen current piece < 0)
            {
                Call get movegen piece(only captures?)(allow checks?)(depth);
            }
        }
    }
    Else
    {
        Repeat (64)
        {
            movegen outer idx += 1;
            movegen current piece = (Current Board Position[movegen outer idx] + 0);
            If (movegen current piece > 0)
            {
                Call get movegen piece(only captures?)(allow checks?)(depth);
            }
        }
    }
    If store atk table?
    {
        Call add attack table info the snapshot with depth:(depth);
    }
}

Define fast psqt read with piece type:(string piece type) square idx:(string square idx) endgame:(string endgame) (warp=true)
{
    fast psqt read res = PSQTs fast read list[((square idx + ((PIECE TYPE TO ID[(piece type + 100000)] - 1) * 64)) + ((64 * 12) * endgame))];
}

Define fast reset info for movegen(string depth) (warp=true)
{
    List.DeleteAll(ALL LEGAL MOVES FOR CPU CALCS);
    List.ReplaceItem(Moves Count, depth, 0);
    GameState: = 1;
    opponent king hanging res (move gen) = 0;
    If (depth > 0)
    {
        movegen castling state = WD_CastlingRights[depth];
        movegen enpassant target = WD_EnPassantTarget[depth];
    }
    Else
    {
        movegen castling state = White CASTLING RIGHTS (DEPTH 0);
        movegen enpassant target = WHITE MOVE EN PASSANT TARGET;
    }
    movegen outer idx = 1;
    Repeat (64)
    {
        List.ReplaceItem(side to move attack square piece square (move gen), movegen outer idx, 00);
        List.ReplaceItem(side to move attack square piece square 2 (move gen), movegen outer idx, 00);
        List.ReplaceItem(# side to move attacking square (move gen), movegen outer idx, 0);
        If (((depth % 2) == 1) And (Current Board Position[movegen outer idx] == 99999))
        {
            their king square (fast movegen) = movegen outer idx;
        }
        If (((depth % 2) == 0) And (Current Board Position[movegen outer idx] == -99999))
        {
            their king square (fast movegen) = movegen outer idx;
        }
        movegen outer idx += 1;
    }
}

Define fast slider movegen with(bool only captures?)(bool allow checks?)(string depth)(string dir1)(string dir2)(string dir3)(string dir4) (warp=true)
{
    Call fast slider movegen with dir:(dir1) max steps:(Distance To Each Edge (movegen)[dir1])(only captures?)(allow checks?)(depth);
    Call fast slider movegen with dir:(dir2) max steps:(Distance To Each Edge (movegen)[dir2])(only captures?)(allow checks?)(depth);
    Call fast slider movegen with dir:(dir3) max steps:(Distance To Each Edge (movegen)[dir3])(only captures?)(allow checks?)(depth);
    Call fast slider movegen with dir:(dir4) max steps:(Distance To Each Edge (movegen)[dir4])(only captures?)(allow checks?)(depth);
}

Define fast slider movegen with dir:(string dir) max steps:(string max steps)(bool only captures?)(bool allow checks?)(string depth) (warp=true)
{
    movegen endsquare = movegen outer idx;
    movegen inner idx = 0;
    Repeat (max steps)
    {
        movegen inner idx += 1;
        movegen endsquare += direction offsets for sliding pieces[dir];
        movegen endsquare piece = (Current Board Position[movegen endsquare] + 0);
        Call fast movegen add attack on square:(movegen outer idx)(movegen endsquare);
        If (((movegen current piece > 0) And (movegen endsquare piece < 1)) Or ((movegen current piece < 0) And (movegen endsquare piece > -1)))
        {
            movegen endsquare legal? = 1;
            If only captures?
            {
                If (Not ((movegen endsquare piece == 0)))
                {
                    Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
                }
                Else
                {
                    If allow checks?
                    {
                        Call does piece type:(movegen current piece) on square:(movegen endsquare) check square:(their king square (fast movegen)) ignore piece:("") ?;
                        If (piece check square res (WD) == 1)
                        {
                            Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
                        }
                    }
                }
            }
            Else
            {
                Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
            }
        }
        If (Not ((movegen endsquare piece == 0)))
        {
            Stop(this script);
        }
    }
}

Define FEN code reader wrapper:(string FEN) (warp=false)
{
    Imported FEN Code: = FEN;
    PV_uci_format_total_res = "";
    Call reset general project data;
    loaded custom FEN? = 1;
    Call load FEN:(FEN);
    Call init WD_NNUE info;
    Call reset start data for search;
    Event.Broadcast("update board (visual)");
}

Define file has pawns?(string file) (eval) (warp=true)
{
    file has pawns res (eval) = 0;
    If ((file > 8) Or (file < 1))
    {
        Stop(this script);
    }
    If ((abs(Most Advanced Black Pawn[file]) < 999) Or (abs(Most Advanced White Pawn[file]) < 999))
    {
        file has pawns res (eval) = 1;
    }
}

Define find all pseudo-legal moves for target piece ID:(string target piece ID) color of piece:(string color of piece) depth:(string depth) isOpposing?:(string isOpposing?) add to legal move list?:(string add to legal move list?) is quiet search?:(string is quiet search?) (warp=true)
{
    ArePseudoLegalMovesForOpposing? = isOpposing?;
    colorForPiecesOfPseudoLegalMoves = color of piece;
    piece on square ID (for finding pseudo-legal moves) = abs(Current Board Position[target piece ID]);
    If (piece on square ID (for finding pseudo-legal moves) == 100)
    {
        Call pawn movement with position index:(target piece ID) piece color:(color of piece) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?);
        Stop(this script);
    }
    If (piece on square ID (for finding pseudo-legal moves) == 320)
    {
        Call knight movement with ID:(target piece ID) color:(color of piece) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?);
        Stop(this script);
    }
    If (piece on square ID (for finding pseudo-legal moves) == 330)
    {
        Call bishop movement with color:(color of piece) board index:(target piece ID) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?);
        Stop(this script);
    }
    If (piece on square ID (for finding pseudo-legal moves) == 500)
    {
        Call rook movement with color:(color of piece) board index:(target piece ID) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?);
        Stop(this script);
    }
    If (piece on square ID (for finding pseudo-legal moves) == 900)
    {
        Call queen movement with board position index:(target piece ID) color of piece:(color of piece) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?);
        Stop(this script);
    }
    Call king moves with position index:(target piece ID) color:(color of piece) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?);
}

Define find legal check evasions with depth:(string depth) (warp=true)
{
    If (Pseudo-Legal Move 1[counter to get all legal moves] > 100)
    {
        Call // comment("not castling, as that is NOT a valid way to evade checkes");
        If (# Opposing Attacks Square[index of target king] > 1)
        {
            Call // comment("double attacked king, can only move away");
            If ((start square for finding legal moves == index of target king) And (# Opposing Attacks Square[end square for finding legal moves] == 0))
            {
                Call add move to legal moves with start square:(start square for finding legal moves) end square:(end square for finding legal moves) depth:(depth);
                Stop(this script);
            }
        }
        Else
        {
            If ((piecePinnedDirection(var) < 1) Or ((IsSlidingPiece?[counter to get all legal moves] > 0) And ((piecePinnedDirection(var) == pieceMovingDirection(var)) Or (piecePinnedDirection(var) == pieceMovingDirectionAlt(var)))))
            {
                If (((start square for finding legal moves == index of target king) And (# Opposing Attacks Square[end square for finding legal moves] == 0)) Or ((List.ContainsItem(SquaresToBeCoveredForCheck, end square for finding legal moves) Or (List.Length(SquaresToBeCoveredForCheck) == 0)) And (Not ((start square for finding legal moves == index of target king)))))
                {
                    Call add move to legal moves with start square:(start square for finding legal moves) end square:(end square for finding legal moves) depth:(depth);
                    Stop(this script);
                }
                If (Current Board Position[start square for finding legal moves] == 100)
                {
                    If (Current Board Position[SquaresToBeCoveredForCheck[1]] == -100)
                    {
                        If (end square for finding legal moves == (SquaresToBeCoveredForCheck[1] - 8))
                        {
                            Call // comment("enpassant check evasion");
                            Call add move to legal moves with start square:(start square for finding legal moves) end square:(end square for finding legal moves) depth:(depth);
                            Stop(this script);
                        }
                    }
                    If (Current Board Position[start square for finding legal moves] == -100)
                    {
                        If (Current Board Position[SquaresToBeCoveredForCheck[1]] == 100)
                        {
                            If (end square for finding legal moves == (SquaresToBeCoveredForCheck[1] + 8))
                            {
                                Call // comment("enpassant check evasion");
                                Call add move to legal moves with start square:(start square for finding legal moves) end square:(end square for finding legal moves) depth:(depth);
                                Stop(this script);
                            }
                        }
                    }
                }
            }
        }
    }
}

Define force HCE for current position? (in eval) (warp=true)
{
    force HCE res (eval) = 0;
    If ((NUM BLACK KNIGHTS (UPDATED) + (NUM BLACK BISHOPS (UPDATED) + (NUM BLACK ROOKS (UPDATED) + (NUM BLACK QUEENS (UPDATED) + (NUM WHITE KNIGHTS (UPDATED) + (NUM WHITE BISHOPS (UPDATED) + (NUM WHITE ROOKS (UPDATED) + NUM WHITE QUEENS (UPDATED)))))))) < 7)
    {
        force HCE res (eval) = 1;
    }
}

Define force set start position (book finder) (warp=true)
{
    List.DeleteAll(Current Board Position);
    List.Add(Current Board Position, -500);
    List.Add(Current Board Position, -320);
    List.Add(Current Board Position, -330);
    List.Add(Current Board Position, -900);
    List.Add(Current Board Position, -99999);
    List.Add(Current Board Position, -330);
    List.Add(Current Board Position, -320);
    List.Add(Current Board Position, -500);
    Repeat (8)
    {
        List.Add(Current Board Position, -100);
    }
    Repeat (32)
    {
        List.Add(Current Board Position, "");
    }
    Repeat (8)
    {
        List.Add(Current Board Position, 100);
    }
    List.Add(Current Board Position, 500);
    List.Add(Current Board Position, 320);
    List.Add(Current Board Position, 330);
    List.Add(Current Board Position, 900);
    List.Add(Current Board Position, 99999);
    List.Add(Current Board Position, 330);
    List.Add(Current Board Position, 320);
    List.Add(Current Board Position, 500);
}

Define gen checks in q-search with depth:(string depth) q-search start:(string start depth) (warp=true)
{
    Call // comment("see if we should be looking at checks in q-search");
    gen checks in q-search res = 0;
    If ((depth - start depth) < 2)
    {
        gen checks in q-search res = 1;
        Stop(this script);
    }
    If ((depth - start depth) < 3)
    {
        If (StartsInCheck?[(depth - 1)] == 0)
        {
            gen checks in q-search res = 1;
            Stop(this script);
        }
    }
    If (StartsInCheck?[(depth - 1)] == 1)
    {
        If (Moves Count[(depth - 1)] == 1)
        {
            If ((depth - start depth) < 6)
            {
                gen checks in q-search res = 1;
                Stop(this script);
            }
        }
        If (Moves Count[(depth - 1)] == 2)
        {
            If ((depth - start depth) < 2)
            {
                gen checks in q-search res = 1;
                Stop(this script);
            }
        }
    }
}

Define get all legal moves for target player piece:(string piece idx) (warp=true)
{
    List.DeleteAll(Legal Moves For Selected Piece);
    List.DeleteAll(Legal Moves For Selected Piece Ending);
    counter to get all legal moves for target player piece = 0;
    Repeat (List.Length(ALL LEGAL MOVES FOR CPU CALCS))
    {
        counter to get all legal moves for target player piece += 1;
        get all legal moves for piece move = ALL LEGAL MOVES FOR CPU CALCS[counter to get all legal moves for target player piece];
        get all legal moves for piece start square = floor((get all legal moves for piece move / 100));
        get all legal moves for piece end square = floor((get all legal moves for piece move % 100));
        If ((get all legal moves for piece start square == piece idx) Or (((Current Board Position[piece idx] == 99999) And ((get all legal moves for piece move == WhiteKingSideCastle) Or (get all legal moves for piece move == WhiteQueenSideCastle))) Or ((Current Board Position[piece idx] == -99999) And ((get all legal moves for piece move == BlackKingSideCastle) Or (get all legal moves for piece move == BlackQueenSideCastle)))))
        {
            List.Add(Legal Moves For Selected Piece, get all legal moves for piece move);
            List.Add(Legal Moves For Selected Piece Ending, get all legal moves for piece end square);
        }
    }
}

Define get all legal moves from current position depth:(string depth) is quiet search?:(string is quiet search?) completely legal?(string completely legal) generate checks?(string gen checks?) (warp=true)
{
    opponent king hanging res (move gen) = 0;
    generate checks in q-search? (move gen) = gen checks?;
    GameState: = 1;
    Call clear info before move gen;
    If (depth == "")
    {
        Stop(this script);
    }
    Call delete depth:(depth) for move storage | clear move count?((Not ()));
    If ((depth % 2) == 1)
    {
        index of target king = List.IndexOf(Current Board Position, -99999);
        index of other king (for legal moves) = List.IndexOf(Current Board Position, 99999);
    }
    Else
    {
        index of target king = List.IndexOf(Current Board Position, 99999);
        index of other king (for legal moves) = List.IndexOf(Current Board Position, -99999);
    }
    If (depth == 0)
    {
        enpassant target square (move legality check) = WHITE MOVE EN PASSANT TARGET;
    }
    Else
    {
        enpassant target square (move legality check) = WD_EnPassantTarget[depth];
    }
    OG king square for legal moves calc = index of target king;
    If (completely legal == 0)
    {
        Call get all pseudo-legal moves from position color:(Operator.LetterOf("wb", ((depth % 2) + 1))) isOpposing?:(0) depth:(depth) add to legal move list?:(1) is quiet search?:(is quiet search?);
        startsInCheck? (var) = 0;
        Call // comment("Since we're only doing move gen for ourselves, we can only assume that we're not in check");
        Call // comment("but checks may be handled by the move making function");
        Stop(this script);
    }
    If (completely legal == 1)
    {
        Call get all pseudo-legal moves from position color:(Operator.LetterOf("wb", ((depth % 2) + 1))) isOpposing?:(0) depth:(depth) add to legal move list?:(0) is quiet search?:("");
        Call get all pseudo-legal moves from position color:(Operator.LetterOf("bw", ((depth % 2) + 1))) isOpposing?:(1) depth:((depth + 1)) add to legal move list?:(0) is quiet search?:("");
        ArePseudoLegalMovesForOpposing? = 0;
        If (# Opposing Attacks Square[index of target king] > 0)
        {
            startsInCheck? (var) = 1;
        }
        Else
        {
            startsInCheck? (var) = 0;
        }
        counter to get all legal moves = 0;
        Repeat (List.Length(Pseudo-Legal Move 1))
        {
            counter to get all legal moves += 1;
            start square for finding legal moves = Operator.Join(Operator.LetterOf(Pseudo-Legal Move 1[counter to get all legal moves], 1), Operator.LetterOf(Pseudo-Legal Move 1[counter to get all legal moves], 2));
            end square for finding legal moves = Operator.Join(Operator.LetterOf(Pseudo-Legal Move 1[counter to get all legal moves], 3), Operator.LetterOf(Pseudo-Legal Move 1[counter to get all legal moves], 4));
            promotionMove?(for legal moves) = 0;
            If ((depth % 2) == 1)
            {
                If (Current Board Position[start square for finding legal moves] == -100)
                {
                    If (end square for finding legal moves > 56)
                    {
                        promotionMove?(for legal moves) = 1;
                    }
                }
            }
            Else
            {
                If (Current Board Position[start square for finding legal moves] == 100)
                {
                    If (end square for finding legal moves < 9)
                    {
                        promotionMove?(for legal moves) = 1;
                    }
                }
            }
            piece check square res (WD) = 0;
            If ((is quiet search? == 1) And ((gen checks? == 1) And ((promotionMove?(for legal moves) == 0) And (startsInCheck? (var) == 0))))
            {
                Call does piece type:(Current Board Position[start square for finding legal moves]) on square:(end square for finding legal moves) check square:(index of other king (for legal moves)) ignore piece:("") ?;
            }
            If (((is quiet search? == 0) Or ((abs(Current Board Position[end square for finding legal moves]) > 0) Or (promotionMove?(for legal moves) == 1))) Or ((startsInCheck? (var) == 1) Or (piece check square res (WD) == 1)))
            {
                If (IsSlidingPiece?[counter to get all legal moves] == 1)
                {
                    pieceMovingDirection(var) = PieceMovingDirection[counter to get all legal moves];
                }
                Else
                {
                    If (IsSlidingPiece?[counter to get all legal moves] == 2)
                    {
                        If (Piece Color[counter to get all legal moves] == "w")
                        {
                            pieceMovingDirection(var) = WhitePawnMovementEquivalent[PieceMovingDirection[counter to get all legal moves]];
                        }
                        Else
                        {
                            pieceMovingDirection(var) = BlackPawnMovementEquivalent[PieceMovingDirection[counter to get all legal moves]];
                        }
                    }
                }
                pieceMovingDirectionAlt(var) = PieceMovingAlternateDirection[pieceMovingDirection(var)];
                piecePinnedDirection(var) = PiecePinnedDirection[start square for finding legal moves];
                If (# Opposing Attacks Square[index of target king] > 0)
                {
                    Call // comment("is in check, must find a legal evasion");
                    Call find legal check evasions with depth:(depth);
                }
                Else
                {
                    If (Pseudo-Legal Move 1[counter to get all legal moves] > 100)
                    {
                        If ((piecePinnedDirection(var) < 1) Or ((IsSlidingPiece?[counter to get all legal moves] > 0) And ((piecePinnedDirection(var) == pieceMovingDirection(var)) Or (piecePinnedDirection(var) == pieceMovingDirectionAlt(var)))))
                        {
                            If ((Not ((start square for finding legal moves == index of target king))) Or ((start square for finding legal moves == index of target king) And (# Opposing Attacks Square[end square for finding legal moves] == 0)))
                            {
                                Call add move to legal moves with start square:(start square for finding legal moves) end square:(end square for finding legal moves) depth:(depth);
                            }
                        }
                    }
                    Else
                    {
                        Call calculate castling legality with depth:(depth);
                    }
                }
            }
        }
        Total Moves Generated += List.Length(ALL LEGAL MOVES FOR CPU CALCS);
        If ((List.Length(ALL LEGAL MOVES FOR CPU CALCS) == 0) And ((is quiet search? == 0) Or (startsInCheck? (var) == 1)))
        {
            If (startsInCheck? (var) == 1)
            {
                Call // comment("checkmate");
                GameState: = 2;
                Stop(this script);
            }
            Call // comment("stalemate");
            GameState: = 3;
        }
    }
}

Define get all pseudo-legal moves from position color:(string color) isOpposing?:(string isOpposing?) depth:(string depth) add to legal move list?:(string add to legal move list?) is quiet search?:(string is quiet search?) (warp=true)
{
    If (isOpposing? == 0)
    {
        List.DeleteAll(Pseudo-Legal Move 1);
        List.DeleteAll(Piece Color);
        List.DeleteAll(IsSlidingPiece?);
        List.DeleteAll(Pseudo-Legal Moves We Attack);
        If (add to legal move list? == 1)
        {
            Call delete depth:(depth) for move storage | clear move count?((Not ()));
            Call clear info before move gen;
        }
    }
    Else
    {
        If (isOpposing? == 1)
        {
            List.DeleteAll(Pseudo-Legal Move 2);
            List.DeleteAll(Pseudo-Legal Moves Opposing Attacking);
        }
    }
    If (color == "w")
    {
        opKingIndex (For Pseudo-Legal Move Gen) = List.IndexOf(Current Board Position, -99999);
        counter to get all pseudo-legal moves = 0;
        Repeat (64)
        {
            counter to get all pseudo-legal moves += 1;
            If (Current Board Position[counter to get all pseudo-legal moves] > 0)
            {
                Call find all pseudo-legal moves for target piece ID:(counter to get all pseudo-legal moves) color of piece:(color) depth:(depth) isOpposing?:(isOpposing?) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?);
            }
        }
        If (isOpposing? == 0)
        {
            Call add attack table info the snapshot with depth:(depth);
        }
        Stop(this script);
    }
    If (color == "b")
    {
        opKingIndex (For Pseudo-Legal Move Gen) = List.IndexOf(Current Board Position, 99999);
        counter to get all pseudo-legal moves = 0;
        Repeat (64)
        {
            counter to get all pseudo-legal moves += 1;
            If ((Current Board Position[counter to get all pseudo-legal moves] + 0) < 0)
            {
                Call find all pseudo-legal moves for target piece ID:(counter to get all pseudo-legal moves) color of piece:(color) depth:(depth) isOpposing?:(isOpposing?) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?);
            }
        }
        If (isOpposing? == 0)
        {
            Call add attack table info the snapshot with depth:(depth);
        }
    }
}

Define get chebyshev distance from square:(string square) to square 2:(string square 2) (warp=true)
{
    distance from square to square = Chebyshev Distance to Square[((64 * (square - 1)) + square 2)];
}

Define get current applying move with depth:(string depth) (warp=true)
{
    get current applying move idx at depth = Moves Index[depth];
    If (depth > 20)
    {
        If (depth == 30)
        {
            current move (computer) = MovesDepth 30[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 29)
        {
            current move (computer) = MovesDepth 29[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 28)
        {
            current move (computer) = MovesDepth 28[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 27)
        {
            current move (computer) = MovesDepth 27[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 26)
        {
            current move (computer) = MovesDepth 26[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 25)
        {
            current move (computer) = MovesDepth 25[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 24)
        {
            current move (computer) = MovesDepth 24[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 23)
        {
            current move (computer) = MovesDepth 23[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 22)
        {
            current move (computer) = MovesDepth 22[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 21)
        {
            current move (computer) = MovesDepth 21[get current applying move idx at depth];
            Stop(this script);
        }
        Stop(this script);
    }
    If (depth > 10)
    {
        If (depth == 20)
        {
            current move (computer) = MovesDepth 20[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 19)
        {
            current move (computer) = MovesDepth 19[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 18)
        {
            current move (computer) = MovesDepth 18[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 17)
        {
            current move (computer) = MovesDepth 17[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 16)
        {
            current move (computer) = MovesDepth 16[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 15)
        {
            current move (computer) = MovesDepth 15[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 14)
        {
            current move (computer) = MovesDepth 14[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 13)
        {
            current move (computer) = MovesDepth 13[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 12)
        {
            current move (computer) = MovesDepth 12[get current applying move idx at depth];
            Stop(this script);
        }
        If (depth == 11)
        {
            current move (computer) = MovesDepth 11[get current applying move idx at depth];
            Stop(this script);
        }
        Stop(this script);
    }
    If (depth == 10)
    {
        current move (computer) = MovesDepth 10[get current applying move idx at depth];
        Stop(this script);
    }
    If (depth == 9)
    {
        current move (computer) = MovesDepth 9[get current applying move idx at depth];
        Stop(this script);
    }
    If (depth == 8)
    {
        current move (computer) = MovesDepth 8[get current applying move idx at depth];
        Stop(this script);
    }
    If (depth == 7)
    {
        current move (computer) = MovesDepth 7[get current applying move idx at depth];
        Stop(this script);
    }
    If (depth == 6)
    {
        current move (computer) = MovesDepth 6[get current applying move idx at depth];
        Stop(this script);
    }
    If (depth == 5)
    {
        current move (computer) = MovesDepth 5[get current applying move idx at depth];
        Stop(this script);
    }
    If (depth == 4)
    {
        current move (computer) = MovesDepth 4[get current applying move idx at depth];
        Stop(this script);
    }
    If (depth == 3)
    {
        current move (computer) = MovesDepth 3[get current applying move idx at depth];
        Stop(this script);
    }
    If (depth == 2)
    {
        current move (computer) = MovesDepth 2[get current applying move idx at depth];
        Stop(this script);
    }
    If (depth == 1)
    {
        current move (computer) = MovesDepth 1[get current applying move idx at depth];
        Stop(this script);
    }
    current move (computer) = "error";
}

Define get dir from square to square(string square1)(string square2) (warp=true)
{
    dir from square to square res = dir from square to square[((square1 * 100) + square2)];
}

Define get distance to edge with index:(string index) //  CHECK DETECTION (warp=true)
{
    List.ReplaceItem(Distance To Each Edge (Check Detection), 1, Squares Until End Of Board 1[index]);
    List.ReplaceItem(Distance To Each Edge (Check Detection), 2, Squares Until End Of Board 2[index]);
    List.ReplaceItem(Distance To Each Edge (Check Detection), 3, Squares Until End Of Board 3[index]);
    List.ReplaceItem(Distance To Each Edge (Check Detection), 4, Squares Until End Of Board 4[index]);
    List.ReplaceItem(Distance To Each Edge (Check Detection), 5, Squares Until End Of Board 5[index]);
    List.ReplaceItem(Distance To Each Edge (Check Detection), 6, Squares Until End Of Board 6[index]);
    List.ReplaceItem(Distance To Each Edge (Check Detection), 7, Squares Until End Of Board 7[index]);
    List.ReplaceItem(Distance To Each Edge (Check Detection), 8, Squares Until End Of Board 8[index]);
}

Define get distance to edge with index:(string index) //  MOVE GEN (warp=true)
{
    List.ReplaceItem(Distance To Each Edge (movegen), 1, Squares Until End Of Board 1[index]);
    List.ReplaceItem(Distance To Each Edge (movegen), 2, Squares Until End Of Board 2[index]);
    List.ReplaceItem(Distance To Each Edge (movegen), 3, Squares Until End Of Board 3[index]);
    List.ReplaceItem(Distance To Each Edge (movegen), 4, Squares Until End Of Board 4[index]);
    List.ReplaceItem(Distance To Each Edge (movegen), 5, Squares Until End Of Board 5[index]);
    List.ReplaceItem(Distance To Each Edge (movegen), 6, Squares Until End Of Board 6[index]);
    List.ReplaceItem(Distance To Each Edge (movegen), 7, Squares Until End Of Board 7[index]);
    List.ReplaceItem(Distance To Each Edge (movegen), 8, Squares Until End Of Board 8[index]);
}

Define get eval phase (warp=true)
{
    phase endgame limit (eval) = 1500;
    If (PIECE MATERIAL (NO PAWNS) (EVAL) < 5800)
    {
        phase factor (eval) = PIECE MATERIAL (NO PAWNS) (EVAL);
    }
    Else
    {
        phase factor (eval) = 5800;
    }
    If (phase endgame limit (eval) > phase factor (eval))
    {
        phase factor (eval) = phase endgame limit (eval);
    }
    EVAL PHASE (eval) = Operator.Round((((phase factor (eval) - phase endgame limit (eval)) * 128) / (5800 - phase endgame limit (eval))));
}

Define get hanging states(bool white) (eval) (warp=true)
{
    hanging state idx (eval) = 0;
    If white
    {
        Repeat (List.Length(White Attacks (eval)))
        {
            hanging state idx (eval) += 1;
            hanging state our square id (eval) = White Attacks (eval)[hanging state idx (eval)];
            If (Piece is Hanging? (eval)[hanging state our square id (eval)] == 0)
            {
                If (Black Pawn Attacks Square (eval)[hanging state our square id (eval)] == 0)
                {
                    If (num black attacks on square (eval)[hanging state our square id (eval)] == 0)
                    {
                        Call change board eval with mg term:(35) eg term:(18);
                        List.ReplaceItem(Piece is Hanging? (eval), hanging state our square id (eval), 1);
                    }
                    If (abs(Current Board Position[hanging state our square id (eval)]) > 100)
                    {
                        If (num white attacks on square (eval)[hanging state our square id (eval)] > 1)
                        {
                            Call change board eval with mg term:(35) eg term:(18);
                            List.ReplaceItem(Piece is Hanging? (eval), hanging state our square id (eval), 1);
                        }
                    }
                }
            }
        }
    }
    Else
    {
        Repeat (List.Length(Black Attacks (eval)))
        {
            hanging state idx (eval) += 1;
            hanging state our square id (eval) = Black Attacks (eval)[hanging state idx (eval)];
            If (Piece is Hanging? (eval)[hanging state our square id (eval)] == 0)
            {
                If (White Pawn Attacks Square (eval)[hanging state our square id (eval)] == 0)
                {
                    If (num white attacks on square (eval)[hanging state our square id (eval)] == 0)
                    {
                        Call change board eval with mg term:(-35) eg term:(-18);
                        List.ReplaceItem(Piece is Hanging? (eval), hanging state our square id (eval), 1);
                    }
                    If (abs(Current Board Position[hanging state our square id (eval)]) > 100)
                    {
                        If (num black attacks on square (eval)[hanging state our square id (eval)] > 1)
                        {
                            Call change board eval with mg term:(-35) eg term:(-18);
                            List.ReplaceItem(Piece is Hanging? (eval), hanging state our square id (eval), 1);
                        }
                    }
                }
            }
        }
    }
}

Define get imbalance from perspective (eval) (warp=true)
{
    imbalance from perspective res (eval) = 0;
    imbalance calc piece outer (eval) = 0;
    Repeat (6)
    {
        imbalance calc piece inner (eval) = 0;
        imbalance temp during calc (eval) = 0;
        Repeat (6)
        {
            If (Not ((imbalance calc piece inner (eval) > imbalance calc piece outer (eval))))
            {
                Call imbalance ours with piece 1:(imbalance calc piece outer (eval)) piece 2:(imbalance calc piece inner (eval)) (eval);
                Call imbalance theirs with piece 1:(imbalance calc piece outer (eval)) piece 2:(imbalance calc piece inner (eval)) (eval);
                imbalance temp during calc (eval) += ((imbalance ours res (eval) * ImbalancePieceCounts (eval)[(imbalance calc piece inner (eval) + 1)]) + (imbalance theirs res (eval) * ImbalancePieceCounts (eval)[((imbalance calc piece inner (eval) + 6) + 1)]));
            }
            imbalance calc piece inner (eval) += 1;
        }
        imbalance from perspective res (eval) += (imbalance temp during calc (eval) * ImbalancePieceCounts (eval)[(imbalance calc piece outer (eval) + 1)]);
        imbalance calc piece outer (eval) += 1;
    }
}

Define get info for evaluation function (warp=true)
{
    counter for evaluation = 0;
    Repeat (64)
    {
        counter for evaluation += 1;
        List.Add(blackPawn(ForEval), "");
        List.Add(whitePawn(ForEval), "");
        List.Add(Black King Ring (eval), 0);
        List.Add(White King Ring (eval), 0);
        Call get info inner for evaluation function;
    }
    ABS PAWN DIFF (EVAL) = abs((NUM WHITE PAWNS (EVAL) - NUM BLACK PAWNS (EVAL)));
    pawn file average (eval) = (pawn file average (eval) / (NUM WHITE PAWNS (EVAL) + NUM BLACK PAWNS (EVAL)));
    If (((NUM WHITE MINOR PIECES (EVAL) + NUM BLACK MINOR PIECES (EVAL)) == 0) And (((NUM BLACK QUEENS (EVAL) + NUM WHITE QUEENS (EVAL)) == 0) And ((NUM BLACK ROOKS (EVAL) + NUM WHITE ROOKS (EVAL)) > 1)))
    {
        is rook endgame? (eval) = 1;
    }
    Call get rank and file from square index:(whiteKingID(eval));
    WhiteKingFile (eval) = file from square index;
    WhiteKingRank (eval) = rank from square index;
    Call get rank and file from square index:(blackKingID(eval));
    BlackKingFile (eval) = file from square index;
    BlackKingRank (eval) = rank from square index;
    Call get king attack areas (eval);
    Call king on pawnless flank (eval);
    Call isEndgame + Easy Draw Detection (eval);
    PIECE VALUE BONUS TOTAL (EVAL) = 0;
    If (draw by material? (eval) == 1)
    {
        Stop(this script);
    }
    Call get eval phase;
    PIECE VALUE BONUS TOTAL (EVAL) = Operator.Round((((PIECE VALUE BONUS MIDDLEGAME (EVAL) * EVAL PHASE (eval)) + (PIECE VALUE BONUS ENDGAME (EVAL) * (128 - EVAL PHASE (eval)))) / 128));
    Call get total imbalance of position (eval);
    BOARD EVAL += (PIECE VALUE BONUS TOTAL (EVAL) + IMBALANCE VALUE BONUS TOTAL (EVAL));
}

Define get info inner for evaluation function (warp=true)
{
    Call get rank and file from square index:(counter for evaluation);
    current piece (eval) = Current Board Position[counter for evaluation];
    current piece type (eval) = abs(current piece (eval));
    If ((current piece (eval) + 0) == 0)
    {
        Stop(this script);
    }
    TOTAL MATERIAL += current piece type (eval);
    piece count (eval) += 1;
    Call add to piece numbers and change mat (eval);
    If (abs(current piece (eval)) > 100)
    {
        Call // comment("piece (i.e. not a pawn)");
        List.Add(Squares With Pieces (Eval), counter for evaluation);
        PIECE EVAL (NO PAWNS) += current piece (eval);
        If (abs(current piece (eval)) < 99999)
        {
            Call // comment("not king");
            PIECE MATERIAL (NO PAWNS) (EVAL) += current piece type (eval);
            If (Current Board Position[counter for evaluation] < 0)
            {
                BLACK MATERIAL (NO PAWNS) += current piece type (eval);
            }
            Else
            {
                WHITE MATERIAL (NO PAWNS) += current piece type (eval);
            }
        }
        If (current piece (eval) == -99999)
        {
            List.ReplaceItem(Mobility Area Black, counter for evaluation, 0);
            blackKingID(eval) = counter for evaluation;
            Call get rank and file from square index:(counter for evaluation);
            BlackKingSide(ForEval) = "";
            If (file from square index > 5)
            {
                BlackKingSide(ForEval) = "king";
                If (file from square index == 8)
                {
                    Call add file to king flank()(6) (eval)();
                }
                Else
                {
                    Call add file to king flank((1 == 1))(5) (eval)();
                }
                Stop(this script);
            }
            If (file from square index < 4)
            {
                BlackKingSide(ForEval) = "queen";
                If (file from square index == 1)
                {
                    Call add file to king flank()(1) (eval)();
                }
                Else
                {
                    Call add file to king flank((1 == 1))(1) (eval)();
                }
                Stop(this script);
            }
            Call add file to king flank((1 == 1))(3) (eval)();
            Stop(this script);
        }
        If (current piece (eval) == 99999)
        {
            List.ReplaceItem(Mobility Area White, counter for evaluation, 0);
            whiteKingID(eval) = counter for evaluation;
            Call get rank and file from square index:(counter for evaluation);
            WhiteKingSide(ForEval) = "";
            If (file from square index > 5)
            {
                WhiteKingSide(ForEval) = "king";
                If (file from square index == 8)
                {
                    Call add file to king flank()(6) (eval)((1 == 1));
                }
                Else
                {
                    Call add file to king flank((1 == 1))(5) (eval)((1 == 1));
                }
                Stop(this script);
            }
            If (file from square index < 4)
            {
                WhiteKingSide(ForEval) = "queen";
                If (file from square index == 1)
                {
                    Call add file to king flank()(1) (eval)((1 == 1));
                }
                Else
                {
                    Call add file to king flank((1 == 1))(1) (eval)((1 == 1));
                }
                Stop(this script);
            }
            Call add file to king flank((1 == 1))(3) (eval)((1 == 1));
            Stop(this script);
        }
    }
    If (current piece (eval) == -100)
    {
        List.Add(Squares with Pawns (eval), counter for evaluation);
        If (abs(Current Board Position[(counter for evaluation + 8)]) > 0)
        {
            If ((file from square index > 2) And (file from square index < 7))
            {
                num fully blocked center pawns black (eval) += 1;
            }
        }
        If (rank from square index < most advanced black pawn rank (eval))
        {
            most advanced black pawn rank (eval) = rank from square index;
            most advanced black pawn file (eval) = file from square index;
        }
        If (Square Color[counter for evaluation] == "light")
        {
            num light pawns BLACK (eval) += 1;
        }
        Else
        {
            num dark pawns BLACK (eval) += 1;
        }
        If (file from square index < 5)
        {
            BLACK QUEEN SIDE PAWNS (EVAL) += 1;
        }
        Else
        {
            BLACK KING SIDE PAWNS (EVAL) += 1;
        }
        List.ReplaceItem(Open File? (eval), file from square index, 0);
        List.ReplaceItem(blackPawn(ForEval), List.Length(blackPawn(ForEval)), 1);
        If (rank from square index < Most Advanced Black Pawn[file from square index])
        {
            List.ReplaceItem(Most Advanced Black Pawn, file from square index, rank from square index);
        }
        If (rank from square index > Least Advanced Black Pawn[file from square index])
        {
            List.ReplaceItem(Least Advanced Black Pawn, file from square index, rank from square index);
        }
        If ((Current Board Position[(counter for evaluation + 8)] == 100) Or ((((Current Board Position[(counter for evaluation + 15)] == 100) And (file from square index > 1)) And ((Current Board Position[(counter for evaluation + 17)] == 100) And (file from square index < 8))) And (rank from square index > 3)))
        {
            pawn blocked black (eval) += 1;
        }
        If ((rank from square index > 5) Or (abs(Current Board Position[(counter for evaluation + 8)]) > 0))
        {
            List.ReplaceItem(Mobility Area Black, counter for evaluation, 0);
        }
        If (rank from square index > 5)
        {
            List.ReplaceItem(Mobility Area Black, counter for evaluation, 0);
        }
        If (file from square index > 1)
        {
            If ((Current Board Position[(counter for evaluation + 7)] + 0) > 0)
            {
                List.Add(Black Attacks (eval), (counter for evaluation + 7));
                List.Add(Black Attacks Source (eval), -100);
            }
            List.ReplaceItem(Black Pawn Attacks Square (eval), (counter for evaluation + 7), (Black Pawn Attacks Square (eval)[(counter for evaluation + 7)] + 1));
            List.ReplaceItem(Mobility Area White, (counter for evaluation + 7), 0);
        }
        If (file from square index < 8)
        {
            If ((Current Board Position[(counter for evaluation + 9)] + 0) > 0)
            {
                List.Add(Black Attacks (eval), (counter for evaluation + 9));
                List.Add(Black Attacks Source (eval), -100);
            }
            List.ReplaceItem(Black Pawn Attacks Square (eval), (counter for evaluation + 9), (Black Pawn Attacks Square (eval)[(counter for evaluation + 9)] + 1));
            List.ReplaceItem(Mobility Area White, (counter for evaluation + 9), 0);
        }
        pawn file average (eval) += file from square index;
        Stop(this script);
    }
    If (current piece (eval) == 100)
    {
        List.Add(Squares with Pawns (eval), counter for evaluation);
        If (abs(Current Board Position[(counter for evaluation - 8)]) > 0)
        {
            If ((file from square index > 2) And (file from square index < 7))
            {
                num fully blocked center pawns white (eval) += 1;
            }
        }
        If (rank from square index > most advanced white pawn rank (eval))
        {
            most advanced white pawn rank (eval) = rank from square index;
            most advanced white pawn file (eval) = file from square index;
        }
        If (Square Color[counter for evaluation] == "light")
        {
            num light pawns WHITE (eval) += 1;
        }
        Else
        {
            num dark pawns WHITE (eval) += 1;
        }
        If (file from square index < 5)
        {
            WHITE QUEEN SIDE PAWNS (EVAL) += 1;
        }
        Else
        {
            WHITE KING SIDE PAWNS (EVAL) += 1;
        }
        List.ReplaceItem(Open File? (eval), file from square index, 0);
        List.ReplaceItem(whitePawn(ForEval), List.Length(whitePawn(ForEval)), 1);
        If (rank from square index > Most Advanced White Pawn[file from square index])
        {
            List.ReplaceItem(Most Advanced White Pawn, file from square index, rank from square index);
        }
        If (rank from square index < Least Advanced White Pawn[file from square index])
        {
            List.ReplaceItem(Least Advanced White Pawn, file from square index, rank from square index);
        }
        If ((Current Board Position[(counter for evaluation - 8)] == -100) Or ((((Current Board Position[(counter for evaluation - 17)] == -100) And (file from square index > 1)) And ((Current Board Position[(counter for evaluation - 15)] == -100) And (file from square index < 8))) And (rank from square index < 6)))
        {
            pawn blocked white (eval) += 1;
        }
        If ((rank from square index < 4) Or (abs(Current Board Position[(counter for evaluation - 8)]) > 0))
        {
            List.ReplaceItem(Mobility Area White, counter for evaluation, 0);
        }
        If (rank from square index < 4)
        {
            List.ReplaceItem(Mobility Area White, counter for evaluation, 0);
        }
        If (file from square index < 8)
        {
            If ((Current Board Position[(counter for evaluation - 7)] + 0) < 0)
            {
                List.Add(White Attacks (eval), (counter for evaluation - 7));
                List.Add(White Attacks Source (eval), 100);
            }
            List.ReplaceItem(White Pawn Attacks Square (eval), (counter for evaluation - 7), (White Pawn Attacks Square (eval)[(counter for evaluation - 7)] + 1));
            List.ReplaceItem(Mobility Area Black, (counter for evaluation - 7), 0);
        }
        If (file from square index > 1)
        {
            If ((Current Board Position[(counter for evaluation - 9)] + 0) < 0)
            {
                List.Add(White Attacks (eval), (counter for evaluation - 9));
                List.Add(White Attacks Source (eval), 100);
            }
            List.ReplaceItem(White Pawn Attacks Square (eval), (counter for evaluation - 9), (White Pawn Attacks Square (eval)[(counter for evaluation - 9)] + 1));
            List.ReplaceItem(Mobility Area Black, (counter for evaluation - 9), 0);
        }
        pawn file average (eval) += file from square index;
        Stop(this script);
    }
    If (current piece (eval) == -500)
    {
        List.ReplaceItem(Black Rooks On File, file from square index, (Black Rooks On File[file from square index] + 1));
        List.Add(Squares With Rooks (eval), counter for evaluation);
        Stop(this script);
    }
    If (current piece (eval) == 500)
    {
        List.ReplaceItem(White Rooks on File, file from square index, (White Rooks on File[file from square index] + 1));
        List.Add(Squares With Rooks (eval), counter for evaluation);
        Stop(this script);
    }
    If (current piece (eval) == -900)
    {
        List.ReplaceItem(Mobility Area Black, counter for evaluation, 0);
        BlackQueenID(eval) = counter for evaluation;
        Stop(this script);
    }
    If (current piece (eval) == 900)
    {
        List.ReplaceItem(Mobility Area White, counter for evaluation, 0);
        WhiteQueenID(eval) = counter for evaluation;
        Stop(this script);
    }
    If ((current piece (eval) == -320) Or (current piece (eval) == -330))
    {
        Call black minor piece is developed?(counter for evaluation);
        Stop(this script);
    }
    If ((current piece (eval) == 320) Or (current piece (eval) == 330))
    {
        Call white minor piece is developed?(counter for evaluation);
    }
}

Define get king attack areas (eval) (warp=true)
{
    king attack area gen center idx temp (eval) = blackKingID(eval);
    If (BlackKingFile (eval) > 7)
    {
        king attack area gen center idx temp (eval) += -1;
    }
    If (BlackKingFile (eval) < 2)
    {
        king attack area gen center idx temp (eval) += 1;
    }
    If (BlackKingRank (eval) > 7)
    {
        king attack area gen center idx temp (eval) += 8;
    }
    If (BlackKingRank (eval) < 2)
    {
        king attack area gen center idx temp (eval) += -8;
    }
    Call add square:(((king attack area gen center idx temp (eval) + -1) + -8)) to king ring((0 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 0) + -8)) to king ring((0 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 1) + -8)) to king ring((0 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + -1) + 0)) to king ring((0 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 0) + 0)) to king ring((0 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 1) + 0)) to king ring((0 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + -1) + 8)) to king ring((0 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 0) + 8)) to king ring((0 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 1) + 8)) to king ring((0 == 1)) (eval);
    king attack area gen center idx temp (eval) = whiteKingID(eval);
    If (WhiteKingFile (eval) > 7)
    {
        king attack area gen center idx temp (eval) += -1;
    }
    If (WhiteKingFile (eval) < 2)
    {
        king attack area gen center idx temp (eval) += 1;
    }
    If (WhiteKingRank (eval) > 7)
    {
        king attack area gen center idx temp (eval) += 8;
    }
    If (WhiteKingRank (eval) < 2)
    {
        king attack area gen center idx temp (eval) += -8;
    }
    Call add square:(((king attack area gen center idx temp (eval) + -1) + -8)) to king ring((1 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 0) + -8)) to king ring((1 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 1) + -8)) to king ring((1 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + -1) + 0)) to king ring((1 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 0) + 0)) to king ring((1 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 1) + 0)) to king ring((1 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + -1) + 8)) to king ring((1 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 0) + 8)) to king ring((1 == 1)) (eval);
    Call add square:(((king attack area gen center idx temp (eval) + 1) + 8)) to king ring((1 == 1)) (eval);
}

Define get LMR reduction with depth:(string depth) move num:(string move num) move type:(string move type) max depth:(string max depth) (warp=true)
{
    LMRreductionsNumRes = (1.35 + (ln((max depth - depth)) * (ln(move num) / 2.75)));
    LMRreductionsNumRes = floor(LMRreductionsNumRes);
    If (LMRreductionsNumRes > 2)
    {
        LMRreductionsNumRes = 2;
    }
    If (depth == search starting depth)
    {
        If (LMRreductionsNumRes > 1)
        {
            LMRreductionsNumRes = 1;
        }
    }
}

Define get manhattan distance from square:(string square) to square 2:(string square 2) (warp=true)
{
    distance from square to square = Manhattan Distance To Square[((64 * (square - 1)) + square 2)];
}

Define get mobility in direction delta rank:(string delta rank) delta file:(string delta file) (max 7 mob.) start square:(string start square) ignore queens:(bool ignore queens) ignore rooks:(bool ignore rooks) white perspective:(bool white?) source is queen?(bool queen source) (warp=true)
{
    Call get rank and file from square index:(start square);
    mobility in direction res = 0;
    temp file for mob. calc (eval) = (file from square index + 0);
    temp rank for mob. calc (eval) = (rank from square index + 0);
    mobility calc idx (eval) = 0;
    mobility piece type (eval) = (current piece (eval) + 0);
    mobility passed through not queen piece? (eval) = 0;
    mobility num pieces passed (eval) = 0;
    mobility calc for piece stop (eval) = 0;
    Repeat (7)
    {
        mobility calc idx (eval) += 1;
        temp file for mob. calc (eval) += delta file;
        temp rank for mob. calc (eval) += delta rank;
        If ((temp file for mob. calc (eval) > 8) Or ((temp file for mob. calc (eval) < 1) Or ((temp rank for mob. calc (eval) > 8) Or (temp rank for mob. calc (eval) < 1))))
        {
            Stop(this script);
        }
        Call get square idx with rank:(temp rank for mob. calc (eval)) file:(temp file for mob. calc (eval));
        mobility current square piece (eval) = (Current Board Position[square idx from rank and file res] + 0);
        If ((square idx from rank and file res == 28) Or ((square idx from rank and file res == 29) Or ((square idx from rank and file res == 36) Or (square idx from rank and file res == 37))))
        {
            mobility check sees central squares (eval) += 1;
        }
        If white?
        {
            Call // comment("WHITE MOBILITY");
            If (mobility calc for piece stop (eval) == 0)
            {
                If ((square idx from rank and file res == blackKingID(eval)) And (mobility num pieces passed (eval) == 0))
                {
                    BlackKingisAttacked (eval) += 1;
                }
                List.ReplaceItem(num white attacks on square (eval), square idx from rank and file res, (num white attacks on square (eval)[square idx from rank and file res] + 1));
                If (mobility piece type (eval) == 900)
                {
                    List.ReplaceItem(White queen attacks on square (eval), square idx from rank and file res, (White queen attacks on square (eval)[square idx from rank and file res] + 1));
                }
                Call try to add flank attack black king with square:(square idx from rank and file res);
                If (Mobility Area White[square idx from rank and file res] == 1)
                {
                    mobility in direction res += 1;
                }
                If (Black King Ring (eval)[square idx from rank and file res] == 1)
                {
                    mobility check attacks their king ring (eval) += 1;
                    Call get chebyshev distance from square:(square idx from rank and file res) to square 2:(blackKingID(eval));
                    If (distance from square to square < 2)
                    {
                        num black king attacks (eval) += 1;
                    }
                }
                If (mobility current square piece (eval) < 1)
                {
                    Call // comment("empty square or black piece");
                    Call does piece type:(mobility piece type (eval)) on square:(square idx from rank and file res) check square:(blackKingID(eval)) ignore piece:(-900) ?;
                    If (mobility passed through not queen piece? (eval) == 0)
                    {
                        If (piece check square res (WD) == 1)
                        {
                            List.Add(White Checks (eval), square idx from rank and file res);
                            List.Add(White Checks Source (eval), mobility piece type (eval));
                            If (mobility piece type (eval) == 900)
                            {
                                List.ReplaceItem(White Queen Check Possible? (eval), square idx from rank and file res, 1);
                            }
                            If (mobility piece type (eval) == 500)
                            {
                                List.ReplaceItem(White Rook Check Possible? (eval), square idx from rank and file res, 1);
                            }
                        }
                    }
                    If (slider on queen threat white (eval)[square idx from rank and file res] == 0)
                    {
                        If (mobility piece type (eval) < 900)
                        {
                            If (Black Pawn Attacks Square (eval)[square idx from rank and file res] == 0)
                            {
                                Call does piece type:(mobility piece type (eval)) on square:(square idx from rank and file res) check square:(BlackQueenID(eval)) ignore piece:("") ?;
                                If (piece check square res (WD) == 1)
                                {
                                    mobility slider on queen counter (eval) += 1;
                                    List.ReplaceItem(slider on queen threat white (eval), square idx from rank and file res, 1);
                                    List.Add(Black Queen Threat Squares (eval), square idx from rank and file res);
                                    List.Add(Black Queen Threat Squares Source (eval), mobility piece type (eval));
                                }
                            }
                        }
                    }
                }
                If (Not ((mobility current square piece (eval) == 0)))
                {
                    Call // comment("target square has piece");
                    mobility num pieces passed (eval) += 1;
                    If (Not ((mobility current square piece (eval) == -900)))
                    {
                        mobility passed through not queen piece? (eval) = 1;
                    }
                    If (mobility current square piece (eval) < 0)
                    {
                        Call // comment("black piece");
                        List.Add(White Attacks (eval), square idx from rank and file res);
                        List.Add(White Attacks Source (eval), mobility piece type (eval));
                        mobility end square piece id (eval) = PIECE TYPE TO ID[(abs(mobility current square piece (eval)) + 100000)];
                        If (Black Pawn Attacks Square (eval)[square idx from rank and file res] == 0)
                        {
                            mobility check attacks weak piece? (eval) += abs((mobility current square piece (eval) / 100));
                            mobility rook threat mg (eval) += _Rook Threat mg[mobility end square piece id (eval)];
                            mobility rook threat eg (eval) += _Rook Threat eg[mobility end square piece id (eval)];
                        }
                        If ((Black Pawn Attacks Square (eval)[square idx from rank and file res] == 0) Or (Not ((mobility current square piece (eval) == -100))))
                        {
                            mobility minor threat mg (eval) += _Minor Threat mg[mobility end square piece id (eval)];
                            mobility minor threat eg (eval) += _Minor Threat eg[mobility end square piece id (eval)];
                        }
                    }
                    If (mobility current square piece (eval) < -400)
                    {
                        mobility check attacks major piece? (eval) += 1;
                        If (mobility current square piece (eval) == -900)
                        {
                            mobility check attacks queen? (eval) += 1;
                        }
                    }
                }
                Else
                {
                    Call // comment("target square has NO piece");
                }
            }
            Else
            {
                If ((mobility num pieces passed (eval) == 1) And queen source)
                {
                    If ((delta file == 0) Or (delta rank == 0))
                    {
                        If (mobility current square piece (eval) == -500)
                        {
                            Call change board eval with mg term:(-26) eg term:(-7.5);
                        }
                    }
                    Else
                    {
                        If (mobility current square piece (eval) == -330)
                        {
                            Call change board eval with mg term:(-26) eg term:(-7.5);
                        }
                    }
                }
                If (Not ((mobility current square piece (eval) == 0)))
                {
                    mobility num pieces passed (eval) += 1;
                }
            }
            If (Not ((mobility current square piece (eval) == 0)))
            {
                If (Not ((ignore rooks And (abs(mobility current square piece (eval)) == 500))))
                {
                    If (Not ((ignore queens And (abs(mobility current square piece (eval)) == 900))))
                    {
                        If (Not ((queen source And (mobility num pieces passed (eval) < 2))))
                        {
                            Stop(this script);
                        }
                        If (queen source And (mobility num pieces passed (eval) > 0))
                        {
                            mobility calc for piece stop (eval) = 1;
                        }
                    }
                }
            }
        }
        Else
        {
            Call // comment("BLACK MOBILITY");
            If (mobility calc for piece stop (eval) == 0)
            {
                If ((square idx from rank and file res == whiteKingID(eval)) And (mobility num pieces passed (eval) == 0))
                {
                    WhiteKingIsAttacked (eval) += 1;
                }
                List.ReplaceItem(num black attacks on square (eval), square idx from rank and file res, (num black attacks on square (eval)[square idx from rank and file res] + 1));
                If (mobility piece type (eval) == -900)
                {
                    List.ReplaceItem(Black queen attacks on square (eval), square idx from rank and file res, (Black queen attacks on square (eval)[square idx from rank and file res] + 1));
                }
                Call try to add flank attack white king with square:(square idx from rank and file res);
                If (Mobility Area Black[square idx from rank and file res] == 1)
                {
                    mobility in direction res += 1;
                }
                If (White King Ring (eval)[square idx from rank and file res] == 1)
                {
                    mobility check attacks their king ring (eval) += 1;
                    Call get chebyshev distance from square:(square idx from rank and file res) to square 2:(whiteKingID(eval));
                    If (distance from square to square < 2)
                    {
                        num white king attacks (eval) += 1;
                    }
                }
                If (mobility current square piece (eval) > -1)
                {
                    Call // comment("empty square or white piece");
                    If (mobility passed through not queen piece? (eval) == 0)
                    {
                        Call does piece type:(mobility piece type (eval)) on square:(square idx from rank and file res) check square:(whiteKingID(eval)) ignore piece:(900) ?;
                        If (piece check square res (WD) == 1)
                        {
                            List.Add(Black Checks (eval), square idx from rank and file res);
                            List.Add(Black Checks Source (eval), mobility piece type (eval));
                            If (mobility piece type (eval) == -900)
                            {
                                List.ReplaceItem(Black Queen Check Possible? (eval), square idx from rank and file res, 1);
                            }
                            If (mobility piece type (eval) == -500)
                            {
                                List.ReplaceItem(Black Rook Check Possible? (eval), square idx from rank and file res, 1);
                            }
                        }
                    }
                    If (slider on queen threat black (eval)[square idx from rank and file res] == 0)
                    {
                        If (mobility piece type (eval) > -900)
                        {
                            If (White Pawn Attacks Square (eval)[square idx from rank and file res] == 0)
                            {
                                Call does piece type:(mobility piece type (eval)) on square:(square idx from rank and file res) check square:(WhiteQueenID(eval)) ignore piece:("") ?;
                                If (piece check square res (WD) == 1)
                                {
                                    mobility slider on queen counter (eval) += 1;
                                    List.ReplaceItem(slider on queen threat black (eval), square idx from rank and file res, 1);
                                    List.Add(White Queen Threat Squares (eval), square idx from rank and file res);
                                    List.Add(White Queen Threat Squares Source (eval), mobility piece type (eval));
                                }
                            }
                        }
                    }
                }
                If (Not ((mobility current square piece (eval) == 0)))
                {
                    Call // comment("target square has piece");
                    mobility num pieces passed (eval) += 1;
                    If (Not ((mobility current square piece (eval) == 900)))
                    {
                        mobility passed through not queen piece? (eval) = 1;
                    }
                    If (mobility current square piece (eval) > 0)
                    {
                        Call // comment("white piece");
                        List.Add(Black Attacks (eval), square idx from rank and file res);
                        List.Add(Black Attacks Source (eval), mobility piece type (eval));
                        mobility end square piece id (eval) = PIECE TYPE TO ID[(abs(mobility current square piece (eval)) + 100000)];
                        If (White Pawn Attacks Square (eval)[square idx from rank and file res] == 0)
                        {
                            mobility check attacks weak piece? (eval) += abs((mobility current square piece (eval) / 100));
                            mobility rook threat mg (eval) += _Rook Threat mg[mobility end square piece id (eval)];
                            mobility rook threat eg (eval) += _Rook Threat eg[mobility end square piece id (eval)];
                        }
                        If ((White Pawn Attacks Square (eval)[square idx from rank and file res] == 0) Or (Not ((mobility current square piece (eval) == 100))))
                        {
                            mobility minor threat mg (eval) += _Minor Threat mg[mobility end square piece id (eval)];
                            mobility minor threat eg (eval) += _Minor Threat eg[mobility end square piece id (eval)];
                        }
                    }
                    If (mobility current square piece (eval) > 400)
                    {
                        mobility check attacks major piece? (eval) += 1;
                        If (mobility current square piece (eval) == 900)
                        {
                            mobility check attacks queen? (eval) += 1;
                        }
                    }
                }
                Else
                {
                    Call // comment("target square has NO piece");
                }
            }
            Else
            {
                If ((mobility num pieces passed (eval) == 1) And queen source)
                {
                    If ((delta file == 0) Or (delta rank == 0))
                    {
                        If (mobility current square piece (eval) == 500)
                        {
                            Call change board eval with mg term:(26) eg term:(7.5);
                        }
                    }
                    Else
                    {
                        If (mobility current square piece (eval) == 330)
                        {
                            Call change board eval with mg term:(26) eg term:(7.5);
                        }
                    }
                }
                If (Not ((mobility current square piece (eval) == 0)))
                {
                    mobility num pieces passed (eval) += 1;
                }
            }
            If (Not ((mobility current square piece (eval) == 0)))
            {
                If (Not ((ignore rooks And (abs(mobility current square piece (eval)) == 500))))
                {
                    If (Not ((ignore queens And (abs(mobility current square piece (eval)) == 900))))
                    {
                        If (Not ((queen source And (mobility num pieces passed (eval) < 2))))
                        {
                            Stop(this script);
                        }
                        If (queen source And (mobility num pieces passed (eval) > 0))
                        {
                            mobility calc for piece stop (eval) = 1;
                        }
                    }
                }
            }
        }
    }
}

Define get movegen piece(bool only captures?)(bool allow checks?)(string depth) (warp=true)
{
    Call get rank and file from square index:(movegen outer idx);
    If (abs(movegen current piece) == 100)
    {
        Call fast pawn push move gen(only captures?)(allow checks?)(depth);
        Call fast pawn capture movegen(depth);
        Stop(this script);
    }
    If (abs(movegen current piece) == 320)
    {
        Call fast knight movegen(only captures?)(allow checks?)(depth);
        Stop(this script);
    }
    Call get distance to edge with index:(movegen outer idx) //  MOVE GEN;
    If ((abs(movegen current piece) == 330) Or (abs(movegen current piece) == 900))
    {
        Call fast slider movegen with(only captures?)(allow checks?)(depth)(2)(4)(6)(8);
        If (abs(movegen current piece) == 330)
        {
            Stop(this script);
        }
    }
    If ((abs(movegen current piece) == 500) Or (abs(movegen current piece) == 900))
    {
        Call fast slider movegen with(only captures?)(allow checks?)(depth)(1)(3)(5)(7);
        Stop(this script);
    }
    If (abs(movegen current piece) == 99999)
    {
        Call fast king movegen(only captures?)(allow checks?)(depth);
        Stop(this script);
    }
}

Define get move score (for ordering) with index:(string index) with depth:(string depth) first search move:(string first search move) special check in move ordering?(string detect checks?) (warp=true)
{
    move ordering score (var) = 0;
    start square for move ordering temp = floor((ALL LEGAL MOVES FOR CPU CALCS[index] / 100));
    end square for move ordering temp = floor((ALL LEGAL MOVES FOR CPU CALCS[index] % 100));
    move ordering endsquare piece = Current Board Position[end square for move ordering temp];
    move ordering start square piece = Current Board Position[start square for move ordering temp];
    move ordering endsquare piece abs = abs(move ordering endsquare piece);
    move ordering start square piece abs = abs(move ordering start square piece);
    move ordering current move = ALL LEGAL MOVES FOR CPU CALCS[index];
    If (move ordering endsquare piece abs == 99999)
    {
        move ordering score (var) = 999999999;
        Stop(this script);
    }
    If (first search move == move ordering current move)
    {
        move ordering score (var) = 9999999;
        Stop(this script);
    }
    If (Hash Move[depth] == move ordering current move)
    {
        move ordering score (var) = 9999900;
        Stop(this script);
    }
    If ((depth % 2) == 1)
    {
        If (move ordering start square piece == -100)
        {
            If (end square for move ordering temp > 56)
            {
                Call // comment("promotion");
                move ordering score (var) += 990000;
            }
        }
    }
    Else
    {
        If (move ordering start square piece == 100)
        {
            If (end square for move ordering temp < 9)
            {
                Call // comment("promotion");
                move ordering score (var) += 990000;
            }
        }
    }
    If (Not ((move ordering endsquare piece == "")))
    {
        captureMaterialDelta = (move ordering endsquare piece abs - move ordering start square piece abs);
        move ordering score (var) += ((10 * move ordering endsquare piece abs) - move ordering start square piece abs);
        If (captureMaterialDelta > 50)
        {
            move ordering score (var) += 900000;
        }
        Else
        {
            If (abs(captureMaterialDelta) < 50)
            {
                If (# Opposing Attacks Square[end square for move ordering temp] == 0)
                {
                    move ordering score (var) += 900000;
                }
                Else
                {
                    move ordering score (var) += 800000;
                }
            }
            Else
            {
                If (captureMaterialDelta < 50)
                {
                    If (# Opposing Attacks Square[end square for move ordering temp] == 0)
                    {
                        move ordering score (var) += 900000;
                    }
                    Else
                    {
                        move ordering score (var) += 600000;
                    }
                }
            }
        }
        Stop(this script);
    }
    Else
    {
        move ordering killer moves id = List.IndexOf(CurrentKillerMoves, move ordering current move);
        If (move ordering killer moves id > 0)
        {
            move ordering score (var) += (move ordering killer moves id + 700000);
            Stop(this script);
        }
        If (detect checks? == 1)
        {
            Call does piece type:(move ordering start square piece) on square:(end square for move ordering temp) check square:(OP KING ID AT DEPTH[depth]) ignore piece:("") ?;
            If (piece check square res (WD) == 1)
            {
                Call // comment("checking move");
                Call // comment("these normally don't have to rank too high in move ordering as they get their own extensions anyways");
                move ordering score (var) += 1000;
            }
        }
        Call fast psqt read with piece type:(move ordering start square piece) square idx:(start square for move ordering temp) endgame:(Endgame Eval @ Search Start?);
        PST at Start Square (move ordering) = fast psqt read res;
        Call fast psqt read with piece type:(move ordering start square piece) square idx:(end square for move ordering temp) endgame:(Endgame Eval @ Search Start?);
        PST at End Square (move ordering) = fast psqt read res;
        If ((depth % 2) == 1)
        {
            move ordering score (var) += ((PST at End Square (move ordering) - PST at Start Square (move ordering)) * -500);
        }
        Else
        {
            move ordering score (var) += ((PST at End Square (move ordering) - PST at Start Square (move ordering)) * 500);
        }
        If (move ordering current move < 100)
        {
            Call // comment("castling");
            move ordering score (var) += 20000;
        }
        If (op pawn attack square[end square for move ordering temp] > 0)
        {
            Call // comment("pawn attacks end square");
            If (move ordering start square piece abs > 100)
            {
                move ordering score (var) += (-20000 * move ordering start square piece abs);
            }
            Else
            {
                move ordering score (var) += 15000;
            }
        }
        If (op pawn attack square[start square for move ordering temp] > 0)
        {
            If (move ordering start square piece abs > 100)
            {
                Call // comment("moving piece away if attacked by a pawn");
                move ordering score (var) += 30000;
            }
        }
        If (move ordering start square piece == -100)
        {
            Call move ordering if pawn fork with captures offsets:(7)(9)(-1);
        }
        If (move ordering start square piece == 100)
        {
            Call move ordering if pawn fork with captures offsets:(-7)(-9)(1);
        }
    }
}

Define get NN activation index with piece:(string piece) square:(string square) color perspective:(string color pers) (warp=true)
{
    If (color pers == "w")
    {
        WD_NNUE_act_idx_pieceToNNtype = piece to NN Input type[(piece + 1000)];
        If (piece == 99999)
        {
            WD_NNUE_act_idx_pieceToNNtype = 6;
        }
        Else
        {
            If (piece == -99999)
            {
                WD_NNUE_act_idx_pieceToNNtype = 12;
            }
        }
        NN activate true input idx = (((WD_NNUE_act_idx_pieceToNNtype - 1) * 64) + square);
    }
    Else
    {
        Call // comment("if updating the other perspective (black) flip the piece values and types");
        WD_NNUE_act_idx_pieceToNNtype = piece to NN Input type[((piece * -1) + 1000)];
        If (piece == 99999)
        {
            WD_NNUE_act_idx_pieceToNNtype = 12;
        }
        Else
        {
            If (piece == -99999)
            {
                WD_NNUE_act_idx_pieceToNNtype = 6;
            }
        }
        NN activate true input idx = (((WD_NNUE_act_idx_pieceToNNtype - 1) * 64) + White PST to Black PST (Vert Refl)[square]);
    }
}

Define get not passed condition(bool white) target file:(string target file) (eval) (warp=true)
{
    not passed cond. res (eval) = 0;
    If ((target file < 1) Or (target file > 8))
    {
        Stop(this script);
    }
    Call get their least advanced pawn on file:(target file) (eval)(white);
    If white
    {
        If (Not ((their least advanced blocker pawn (eval) < (rank from square index + 2))))
        {
            Call get square idx with rank:((rank from square index + 1)) file:(file from square index);
            If (Not ((((White Pawn Attacks Square (eval)[square idx from rank and file res] + 1) > Black Pawn Attacks Square (eval)[square idx from rank and file res]) And (their least advanced blocker pawn (eval) == (rank from square index + 2)))))
            {
                not passed cond. res (eval) = 1;
            }
        }
    }
    Else
    {
        If (Not ((their least advanced blocker pawn (eval) > (rank from square index - 2))))
        {
            Call get square idx with rank:((rank from square index - 1)) file:(file from square index);
            If (Not ((((Black Pawn Attacks Square (eval)[square idx from rank and file res] + 1) > White Pawn Attacks Square (eval)[square idx from rank and file res]) And (their least advanced blocker pawn (eval) == (rank from square index - 2)))))
            {
                not passed cond. res (eval) = 1;
            }
        }
    }
}

Define get num safe checks for perspective(bool white?) (eval) (warp=true)
{
    num safe checks finder idx (eval) = 0;
    num safe checks res (eval) = 0;
    If white?
    {
        unsafe checks total white (eval) = 0;
        Repeat (List.Length(White Checks (eval)))
        {
            num safe checks finder idx (eval) += 1;
            our check square in safe check (eval) = White Checks (eval)[num safe checks finder idx (eval)];
            num their attacks on square (eval) = (num black attacks on square (eval)[our check square in safe check (eval)] + Black Pawn Attacks Square (eval)[our check square in safe check (eval)]);
            If ((White Checks Source (eval)[num safe checks finder idx (eval)] < 900) And (num white attacks on square (eval)[our check square in safe check (eval)] > 1))
            {
                num their attacks on square (eval) += (-1 * Black queen attacks on square (eval)[our check square in safe check (eval)]);
            }
            If (White Checks Source (eval)[num safe checks finder idx (eval)] < 900)
            {
                unsafe checks total white (eval) += 1;
            }
            If (num their attacks on square (eval) == 0)
            {
                Call get chebyshev distance from square:(our check square in safe check (eval)) to square 2:(blackKingID(eval));
                If (distance from square to square == 1)
                {
                    If ((num white attacks on square (eval)[our check square in safe check (eval)] + White Pawn Attacks Square (eval)[our check square in safe check (eval)]) > 1)
                    {
                        Call add safe check with piece type:(White Checks Source (eval)[num safe checks finder idx (eval)]) square:(our check square in safe check (eval));
                    }
                }
                Else
                {
                    Call add safe check with piece type:(White Checks Source (eval)[num safe checks finder idx (eval)]) square:(our check square in safe check (eval));
                }
            }
        }
    }
    Else
    {
        unsafe checks total black (eval) = 0;
        Repeat (List.Length(Black Checks (eval)))
        {
            num safe checks finder idx (eval) += 1;
            our check square in safe check (eval) = Black Checks (eval)[num safe checks finder idx (eval)];
            num their attacks on square (eval) = (num white attacks on square (eval)[our check square in safe check (eval)] + White Pawn Attacks Square (eval)[our check square in safe check (eval)]);
            If ((Black Checks Source (eval)[num safe checks finder idx (eval)] > -900) And (num black attacks on square (eval)[our check square in safe check (eval)] > 1))
            {
                num their attacks on square (eval) += (-1 * White queen attacks on square (eval)[our check square in safe check (eval)]);
            }
            If (Black Checks Source (eval)[num safe checks finder idx (eval)] > -900)
            {
                unsafe checks total black (eval) += 1;
            }
            If (num their attacks on square (eval) == 0)
            {
                Call get chebyshev distance from square:(our check square in safe check (eval)) to square 2:(whiteKingID(eval));
                If (distance from square to square == 1)
                {
                    If ((num black attacks on square (eval)[our check square in safe check (eval)] + Black Pawn Attacks Square (eval)[our check square in safe check (eval)]) > 1)
                    {
                        Call add safe check with piece type:(Black Checks Source (eval)[num safe checks finder idx (eval)]) square:(our check square in safe check (eval));
                    }
                }
                Else
                {
                    Call add safe check with piece type:(Black Checks Source (eval)[num safe checks finder idx (eval)]) square:(our check square in safe check (eval));
                }
            }
        }
    }
}

Define get num their attacks on square(string square)(bool white?) (eval) (warp=true)
{
    If white?
    {
        num their attacks on square res (eval) = num white attacks on square (eval)[square idx from rank and file res];
        num our attacks on square res (eval) = num black attacks on square (eval)[square idx from rank and file res];
    }
    Else
    {
        num their attacks on square res (eval) = num black attacks on square (eval)[square idx from rank and file res];
        num their attacks on square res (eval) = num white attacks on square (eval)[square idx from rank and file res];
    }
}

Define get passed file with(string file) (for eval) (warp=true)
{
    If ((file - 1) < (8 - file))
    {
        passed file res (eval) = (file - 1);
    }
    Else
    {
        passed file res (eval) = (8 - file);
    }
}

Define get piece counts with perspective(bool white perspective?) (eval) (warp=true)
{
    List.DeleteAll(ImbalancePieceCounts (eval));
    If white perspective?
    {
        List.Add(ImbalancePieceCounts (eval), (1 * (NUM WHITE BISHOPS (EVAL) > 1)));
        List.Add(ImbalancePieceCounts (eval), NUM WHITE PAWNS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM WHITE KNIGHTS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM WHITE BISHOPS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM WHITE ROOKS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM WHITE QUEENS (EVAL));
        List.Add(ImbalancePieceCounts (eval), (1 * (NUM BLACK BISHOPS (EVAL) > 1)));
        List.Add(ImbalancePieceCounts (eval), NUM BLACK PAWNS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM BLACK KNIGHTS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM BLACK BISHOPS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM BLACK ROOKS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM BLACK QUEENS (EVAL));
    }
    Else
    {
        List.Add(ImbalancePieceCounts (eval), (1 * (NUM BLACK BISHOPS (EVAL) > 1)));
        List.Add(ImbalancePieceCounts (eval), NUM BLACK PAWNS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM BLACK KNIGHTS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM BLACK BISHOPS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM BLACK ROOKS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM BLACK QUEENS (EVAL));
        List.Add(ImbalancePieceCounts (eval), (1 * (NUM WHITE BISHOPS (EVAL) > 1)));
        List.Add(ImbalancePieceCounts (eval), NUM WHITE PAWNS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM WHITE KNIGHTS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM WHITE BISHOPS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM WHITE ROOKS (EVAL));
        List.Add(ImbalancePieceCounts (eval), NUM WHITE QUEENS (EVAL));
    }
}

Define get piece pos hash at pos:(string pos) piece:(string piece) (warp=true)
{
    piecePosHash = 0;
    If (abs(piece) > 0)
    {
        piecePosHash = PosPieceHashLookup[((64 * (PIECE TYPE TO ID[(piece + 100000)] - 1)) + pos)];
    }
}

Define get pv total res from info (warp=true)
{
    List.DeleteAll(PV to UCI Format Tokens);
    PV_total_res_temp = "";
    PV_uci_total_res_temp = "";
    pv_total_read_at_root _idx = search starting depth;
    Repeat ((PV_length[search starting depth] - (search starting depth - 1)))
    {
        Call read pv_val at depth:(search starting depth) pv_depth:(pv_total_read_at_root _idx);
        If (pv_val_read_res == "")
        {
            Call get UCI pv notation from tokens;
            Stop(this script);
        }
        PV_total_res_temp = Operator.Join(PV_total_res_temp, pv_val_read_res);
        PV_total_res_temp = Operator.Join(PV_total_res_temp, " ");
        List.Add(PV to UCI Format Tokens, pv_val_read_res);
        If (pv_val_read_res > 100)
        {
            List.ReplaceItem(PV to UCI Format Tokens, List.Length(PV to UCI Format Tokens), Operator.Join(A1 - H8 to #[Operator.Join(Operator.LetterOf(pv_val_read_res, 1), Operator.LetterOf(pv_val_read_res, 2))], A1 - H8 to #[Operator.Join(Operator.LetterOf(pv_val_read_res, 3), Operator.LetterOf(pv_val_read_res, 4))]));
        }
        Else
        {
            If (pv_val_read_res == BlackKingSideCastle)
            {
                List.ReplaceItem(PV to UCI Format Tokens, List.Length(PV to UCI Format Tokens), "O-O");
            }
            Else
            {
                If (pv_val_read_res == WhiteKingSideCastle)
                {
                    List.ReplaceItem(PV to UCI Format Tokens, List.Length(PV to UCI Format Tokens), "O-O");
                }
                Else
                {
                    If (pv_val_read_res == BlackQueenSideCastle)
                    {
                        List.ReplaceItem(PV to UCI Format Tokens, List.Length(PV to UCI Format Tokens), "O-O-O");
                    }
                    Else
                    {
                        If (pv_val_read_res == WhiteQueenSideCastle)
                        {
                            List.ReplaceItem(PV to UCI Format Tokens, List.Length(PV to UCI Format Tokens), "O-O-O");
                        }
                    }
                }
            }
        }
        pv_total_read_at_root _idx += 1;
    }
    Call get UCI pv notation from tokens;
}

Define get rank and file from square idx:(string square idx) background function (warp=true)
{
    Call // comment("this should be used in functions where the original "get rank and file from square index" function may be used");
    Call // comment("in other words, when using this function, do not depend on the returns being accurate later on");
    file from square idx background = File From Square Index[square idx];
    rank from square idx background = Rank From Square Index[square idx];
}

Define get rank and file from square index:(string square index) (warp=true)
{
    file from square index = File From Square Index[square index];
    rank from square index = Rank From Square Index[square index];
}

Define Get Special Info (PST + Pawn + Others) For Eval With Depth:(string depth) (warp=true)
{
    counter for evaluation (outer) = 0;
    Repeat (List.Length(Squares With Pieces (Eval)))
    {
        counter for evaluation (outer) += 1;
        counter for evaluation = (Squares With Pieces (Eval)[counter for evaluation (outer)] + 0);
        current piece (eval) = Current Board Position[counter for evaluation];
        Call get special info for eval inner with depth:(depth);
    }
    counter for evaluation (outer) = 0;
    Repeat (List.Length(Squares with Pawns (eval)))
    {
        counter for evaluation (outer) += 1;
        counter for evaluation = (Squares with Pawns (eval)[counter for evaluation (outer)] + 0);
        current piece (eval) = Current Board Position[counter for evaluation];
        Call get special info for eval inner with depth:(depth);
    }
    If (isEndgame? (for eval) == 1)
    {
        king pawn tropism total value (eval) += (3.5 * (king pawn tropism dist to black (eval) / king pawn tropism weights (eval)));
        king pawn tropism total value (eval) += (-1 * (3.5 * (king pawn tropism dist to white (eval) / king pawn tropism weights (eval))));
        king pawn tropism total value (eval) = Operator.Round(king pawn tropism total value (eval));
        king passer proximity total (eval) = Operator.Round((king passer proximity total (eval) * 0.5));
        Call change board eval with mg term:(0) eg term:(king passer proximity total (eval));
        Call change board eval with mg term:((-10 * (WhiteKingPawnlessFlank (eval) - BlackKingPawnlessFlank (eval)))) eg term:((-47.5 * (WhiteKingPawnlessFlank (eval) - BlackKingPawnlessFlank (eval))));
    }
    Else
    {
        king passer proximity total (eval) = 0;
    }
    MOBILITY TOTAL TAPERED (EVAL) = Operator.Round((((MOBILITY mg (eval) * EVAL PHASE (eval)) + (MOBILITY eg (eval) * (128 - EVAL PHASE (eval)))) / 128));
    BOARD EVAL += MOBILITY TOTAL TAPERED (EVAL);
    Call change board eval with mg term:((White PSTs Middle (eval) + Black PSTs Middle (eval))) eg term:((White PSTs End (eval) + Black PSTs End (eval)));
    Call change board eval with mg term:(king protector mg (eval)) eg term:(king protector eg (eval));
    Call add queen attacked threats (eval);
    Call // comment("SPACE calcs (SF idea)");
    counter for evaluation = 0;
    Repeat (64)
    {
        counter for evaluation += 1;
        Call change area counter (eval);
    }
    space weight black (eval) = ((NUM BLACK PAWNS (EVAL) + (NUM BLACK PIECES (NOT PAWNS) (EVAL) + 1)) - 3);
    If (9 < (pawn blocked black (eval) + pawn blocked white (eval)))
    {
        space weight black (eval) += 9;
    }
    Else
    {
        space weight black (eval) += (pawn blocked black (eval) + pawn blocked white (eval));
    }
    space weight white (eval) = ((NUM WHITE PAWNS (EVAL) + (NUM WHITE PIECES (NOT PAWNS) (EVAL) + 1)) - 3);
    If (9 < (pawn blocked black (eval) + pawn blocked white (eval)))
    {
        space weight white (eval) += 9;
    }
    Else
    {
        space weight white (eval) += (pawn blocked black (eval) + pawn blocked white (eval));
    }
    If (PIECE MATERIAL (NO PAWNS) (EVAL) > 5000)
    {
        space total res (eval) = ((area counter white (eval) * (space weight white (eval) * space weight white (eval))) / 16);
        space total res (eval) += ((-1 * (area counter black (eval) * (space weight black (eval) * space weight black (eval)))) / 16);
        space total res (eval) = Operator.Round((space total res (eval) / 2));
        Call change board eval with mg term:(space total res (eval)) eg term:(0);
    }
    Call get hanging states((1 == 1)) (eval);
    Call get hanging states((1 == 0)) (eval);
}

Define get special info for eval inner with depth:(string depth) (warp=true)
{
    mobility rook threat eg (eval) = 0;
    mobility rook threat mg (eval) = 0;
    mobility minor threat mg (eval) = 0;
    mobility minor threat eg (eval) = 0;
    mobility check attacks their king ring (eval) = 0;
    mobility check sees central squares (eval) = 0;
    mobility check attacks major piece? (eval) = 0;
    mobility check attacks weak piece? (eval) = 0;
    mobility check attacks queen? (eval) = 0;
    mobility slider on queen counter (eval) = 0;
    piece mobility counter (eval) = 0;
    piece is attacker? (eval) = 0;
    mobility stop pawn color (eval) = (((current piece (eval) < 0) - 0.5) * 2);
    Call // comment("initial setup and generalized data");
    piece in black king shield? = 0;
    piece in white king shield? = 0;
    piece is attacker? (eval) = 0;
    Call get rank and file from square index:(counter for evaluation);
    Call // comment("get PSTs data");
    Call fast psqt read with piece type:(current piece (eval)) square idx:(counter for evaluation) endgame:(0);
    Call change board eval from PSTs and game state (eval)(0) value:(fast psqt read res);
    Call fast psqt read with piece type:(current piece (eval)) square idx:(counter for evaluation) endgame:(1);
    Call change board eval from PSTs and game state (eval)(1) value:(fast psqt read res);
    Call king attacking piece threat (eval);
    If (abs(current piece (eval)) == 100)
    {
        Call is piece an attacker with type:(current piece (eval)) pos:(counter for evaluation);
        Call special pawn eval (for eval) with idx:(counter for evaluation) depth:(depth);
        Call passed block (SF idea) (eval);
        Call update king pawn tropism info;
        Call update king proximity to passer (eval);
        Call pawn push threat (eval);
        Stop(this script);
    }
    Call piece attacked by pawn (eval);
    If (abs(current piece (eval)) == 320)
    {
        Call special knight eval;
        Stop(this script);
    }
    If (abs(current piece (eval)) == 330)
    {
        Call special bishop eval;
        Stop(this script);
    }
    If (abs(current piece (eval)) == 500)
    {
        Call special rook eval;
        Stop(this script);
    }
    If (abs(current piece (eval)) == 900)
    {
        Call special queen eval;
        Stop(this script);
    }
}

Define get square idx of init square:(string init square) delta rank:(string delta rank) delta file:(string delta file) (warp=true)
{
    square with delta rank and file res = 0;
    Call get rank and file from square idx:(init square) background function;
    If ((file from square idx background + delta file) > 8)
    {
        Stop(this script);
    }
    If ((file from square idx background + delta file) < 1)
    {
        Stop(this script);
    }
    If ((rank from square idx background + delta rank) > 8)
    {
        Stop(this script);
    }
    If ((rank from square idx background + delta rank) < 1)
    {
        Stop(this script);
    }
    Call get square idx with rank:((rank from square idx background + delta rank)) file:((file from square idx background + delta file));
    square with delta rank and file res = square idx from rank and file res;
}

Define get square idx with rank:(string rank) file:(string file) (warp=true)
{
    If (((file > 8) Or (file < 1)) Or ((rank > 8) Or (rank < 1)))
    {
        square idx from rank and file res = 0;
        Stop(this script);
    }
    square idx from rank and file res = (((8 - rank) * 8) + file);
}

Define get their least advanced pawn on file:(string file) (eval)(bool white?) (warp=true)
{
    If white?
    {
        their least advanced blocker pawn (eval) = Least Advanced Black Pawn[(file + 0)];
    }
    Else
    {
        their least advanced blocker pawn (eval) = Least Advanced White Pawn[(file + 0)];
    }
}

Define get think time for search (warp=true)
{
    wd_timeman_no_increment? = (1 * (TIME CONTROL INCREMENT SECONDS < 0.75));
    If (TIME CONTROL MODE? == 1)
    {
        If (CPU COLOR == "b")
        {
            cpu clock time left = (BLACK CLOCK TIME - MOVE INPUT LAG TIME);
        }
        Else
        {
            cpu clock time left = (WHITE CLOCK TIME - MOVE INPUT LAG TIME);
        }
        TARGET THINK TIME = (cpu clock time left / 20);
        If (Not ((TARGET THINK TIME > 0)))
        {
            TARGET THINK TIME = 0.2;
        }
        REAL MAX THINK TIME = (cpu clock time left / 10);
        If (wd_timeman_no_increment? == 1)
        {
            REAL MAX THINK TIME = (cpu clock time left / 15);
        }
        If (cpu clock time left < 60)
        {
            REAL MAX THINK TIME = (cpu clock time left / 20);
            If ((TIME CONTROL INCREMENT SECONDS * 1.5) > REAL MAX THINK TIME)
            {
                REAL MAX THINK TIME = (TIME CONTROL INCREMENT SECONDS * 1.5);
            }
            If (cpu clock time left < 30)
            {
                REAL MAX THINK TIME = 0.75;
                If (TIME CONTROL INCREMENT SECONDS > 2)
                {
                    If ((TIME CONTROL INCREMENT SECONDS * 0.75) > REAL MAX THINK TIME)
                    {
                        REAL MAX THINK TIME = (TIME CONTROL INCREMENT SECONDS * 0.75);
                    }
                }
                Else
                {
                    If ((TIME CONTROL INCREMENT SECONDS * 0.35) > REAL MAX THINK TIME)
                    {
                        REAL MAX THINK TIME = (TIME CONTROL INCREMENT SECONDS * 0.35);
                    }
                }
                If (cpu clock time left < 15)
                {
                    REAL MAX THINK TIME = 0.2;
                    If (TIME CONTROL INCREMENT SECONDS > 2)
                    {
                        If ((TIME CONTROL INCREMENT SECONDS * 0.75) > REAL MAX THINK TIME)
                        {
                            REAL MAX THINK TIME = (TIME CONTROL INCREMENT SECONDS * 0.75);
                        }
                    }
                    Else
                    {
                        If ((TIME CONTROL INCREMENT SECONDS * 0.35) > REAL MAX THINK TIME)
                        {
                            REAL MAX THINK TIME = (TIME CONTROL INCREMENT SECONDS * 0.35);
                        }
                    }
                }
            }
        }
        If (REAL MAX THINK TIME > (cpu clock time left - 2))
        {
            REAL MAX THINK TIME = (cpu clock time left - 2);
        }
        If (REAL MAX THINK TIME < 0.1)
        {
            REAL MAX THINK TIME = 0.1;
        }
    }
    Else
    {
        TARGET THINK TIME = Performance Mode Think Time[Performance Mode:];
        REAL MAX THINK TIME = (TARGET THINK TIME * 5);
    }
}

Define get time for search (warp=true)
{
    WD_time for search = Operator.Join(((Sensing.DaysSince2000() - start time for search) * 86400), "");
    time for search display = (Operator.Round((WD_time for search * 10)) / 10);
}

Define get total imbalance of position (eval) (warp=true)
{
    Call // comment("calculate material imbalance and give bonuses/maluses (based on SF implementation)");
    IMBALANCE VALUE BONUS TOTAL (EVAL) = 0;
    Call get piece counts with perspective((1 == 1)) (eval);
    Call get imbalance from perspective (eval);
    IMBALANCE VALUE BONUS TOTAL (EVAL) += imbalance from perspective res (eval);
    Call get piece counts with perspective((0 == 1)) (eval);
    Call get imbalance from perspective (eval);
    IMBALANCE VALUE BONUS TOTAL (EVAL) += (0 - imbalance from perspective res (eval));
    IMBALANCE VALUE BONUS TOTAL (EVAL) = (IMBALANCE VALUE BONUS TOTAL (EVAL) / 16);
    Call // comment("WD eval is generally 2x smaller than SF eval, so scale down");
    IMBALANCE VALUE BONUS TOTAL (EVAL) = Operator.Round((IMBALANCE VALUE BONUS TOTAL (EVAL) / 2));
}

Define get UCI pv notation from tokens (warp=true)
{
    pv to uci format idx = 0;
    Repeat (List.Length(PV to UCI Format Tokens))
    {
        pv to uci format idx += 1;
        PV_uci_total_res_temp = Operator.Join(PV_uci_total_res_temp, PV to UCI Format Tokens[pv to uci format idx]);
        If (pv to uci format idx < List.Length(PV to UCI Format Tokens))
        {
            PV_uci_total_res_temp = Operator.Join(PV_uci_total_res_temp, " ");
        }
    }
}

Define imbalance ours with piece 1:(string piece 1) piece 2:(string piece 2) (eval) (warp=true)
{
    imbalance ours res (eval) = 0;
    If (piece 2 > piece 1)
    {
        Stop(this script);
    }
    imbalance ours res (eval) = ImbalanceQuadraticOurs[((((piece 1 * (piece 1 + 1)) / 2) + piece 2) + 1)];
}

Define imbalance theirs with piece 1:(string piece 1) piece 2:(string piece 2) (eval) (warp=true)
{
    imbalance theirs res (eval) = 0;
    If (piece 2 > piece 1)
    {
        Stop(this script);
    }
    imbalance theirs res (eval) = ImbalanceQuadraticTheirs[((((piece 1 * (piece 1 + 1)) / 2) + piece 2) + 1)];
}

Define init black pawns movement table (warp=true)
{
    List.DeleteAll(Black Pawn Movement Table);
    var to init pawn movement table = 0;
    Repeat (64)
    {
        var to init pawn movement table += 1;
        Call get rank and file from square index:(var to init pawn movement table);
        If ((rank from square index > 1) And (rank from square index < 8))
        {
            If (file from square index > 1)
            {
                List.Add(Black Pawn Movement Table, Operator.Join(Zero Before Single Digit Numbers (1 offset)[(var to init pawn movement table + 1)], Zero Before Single Digit Numbers (1 offset)[((var to init pawn movement table + 7) + 1)]));
            }
            Else
            {
                List.Add(Black Pawn Movement Table, "");
            }
            If (file from square index < 8)
            {
                List.Add(Black Pawn Movement Table, Operator.Join(Zero Before Single Digit Numbers (1 offset)[(var to init pawn movement table + 1)], Zero Before Single Digit Numbers (1 offset)[((var to init pawn movement table + 9) + 1)]));
            }
            Else
            {
                List.Add(Black Pawn Movement Table, "");
            }
            List.Add(Black Pawn Movement Table, Operator.Join(Zero Before Single Digit Numbers (1 offset)[(var to init pawn movement table + 1)], Zero Before Single Digit Numbers (1 offset)[((var to init pawn movement table + 8) + 1)]));
            If (rank from square index == 7)
            {
                List.Add(Black Pawn Movement Table, Operator.Join(Zero Before Single Digit Numbers (1 offset)[(var to init pawn movement table + 1)], Zero Before Single Digit Numbers (1 offset)[((var to init pawn movement table + 16) + 1)]));
            }
            Else
            {
                List.Add(Black Pawn Movement Table, "");
            }
        }
        Else
        {
            Repeat (4)
            {
                List.Add(Black Pawn Movement Table, "");
            }
        }
    }
}

Define init closest distance to edge with square (warp=true)
{
    List.DeleteAll(WD_distance_to_closest_edge);
    Repeat (64)
    {
        Call get rank and file from square index:((List.Length(WD_distance_to_closest_edge) + 1));
        If (rank from square index > 4)
        {
            distance to closest edge rank = (8 - rank from square index);
        }
        Else
        {
            distance to closest edge rank = (rank from square index - 1);
        }
        If (file from square index > 4)
        {
            distance to closest edge file = (8 - file from square index);
        }
        Else
        {
            distance to closest edge file = (file from square index - 1);
        }
        If (distance to closest edge file < distance to closest edge rank)
        {
            List.Add(WD_distance_to_closest_edge, distance to closest edge file);
        }
        Else
        {
            List.Add(WD_distance_to_closest_edge, distance to closest edge rank);
        }
    }
}

Define init dir from square to square (warp=true)
{
    Call // comment("use as (start square * 100) + endsquare");
    List.DeleteAll(dir from square to square);
    counter for first init dir from square to square = 0;
    Repeat (65)
    {
        Call get rank and file from square index:(counter for first init dir from square to square);
        file of first square (dir from square to square) = file from square index;
        rank of first square (dir from square to square) = rank from square index;
        counter for second init dir from square to square = 0;
        Repeat (100)
        {
            counter for second init dir from square to square += 1;
            Call get rank and file from square index:(counter for second init dir from square to square);
            If (((file of first square (dir from square to square) - file from square index) == 0) Or (((rank of first square (dir from square to square) - rank from square index) == 0) Or (abs((rank of first square (dir from square to square) - rank from square index)) == abs((file of first square (dir from square to square) - file from square index)))))
            {
                If ((rank of first square (dir from square to square) - rank from square index) == 0)
                {
                    If (file from square index > file of first square (dir from square to square))
                    {
                        List.Add(dir from square to square, 1);
                    }
                    Else
                    {
                        List.Add(dir from square to square, 5);
                    }
                }
                Else
                {
                    If ((file of first square (dir from square to square) - file from square index) == 0)
                    {
                        If (rank from square index > rank of first square (dir from square to square))
                        {
                            List.Add(dir from square to square, 3);
                        }
                        Else
                        {
                            List.Add(dir from square to square, 7);
                        }
                    }
                    Else
                    {
                        If (file from square index > file of first square (dir from square to square))
                        {
                            If (rank from square index > rank of first square (dir from square to square))
                            {
                                List.Add(dir from square to square, 2);
                            }
                            Else
                            {
                                List.Add(dir from square to square, 8);
                            }
                        }
                        Else
                        {
                            If (rank from square index > rank of first square (dir from square to square))
                            {
                                List.Add(dir from square to square, 4);
                            }
                            Else
                            {
                                List.Add(dir from square to square, 6);
                            }
                        }
                    }
                }
            }
            Else
            {
                List.Add(dir from square to square, "");
            }
        }
        counter for first init dir from square to square += 1;
    }
}

Define init fast pst reading (warp=true)
{
    List.DeleteAll(PSQTs fast read list);
    Repeat ((64 * (12 * 2)))
    {
        If ((List.Length(PSQTs fast read list) + 1) > (64 * 12))
        {
            piece type for gen fast psqt read = (ceiling(((List.Length(PSQTs fast read list) + 1) / 64)) - 12);
        }
        Else
        {
            piece type for gen fast psqt read = ceiling(((List.Length(PSQTs fast read list) + 1) / 64));
        }
        piece type for gen fast psqt read = PIECE ID TO TYPE (WD)[piece type for gen fast psqt read];
        Call piece square tables with index:((((List.Length(PSQTs fast read list) + 1) % 64) + (64 * (((List.Length(PSQTs fast read list) + 1) % 64) == 0)))) piece type:(piece type for gen fast psqt read) endgame?:((1 * ((List.Length(PSQTs fast read list) + 1) > (64 * 12))));
        List.Add(PSQTs fast read list, PST_read_res);
    }
}

Define init file & rank from square index & zeros before single digit numbers (warp=true)
{
    List.DeleteAll(Zero Before Single Digit Numbers (1 offset));
    List.DeleteAll(File From Square Index);
    List.DeleteAll(Rank From Square Index);
    counter to init file & rank from square index = 0;
    Repeat (100)
    {
        counter to init file & rank from square index += 1;
        Call init rank & file from square index math with index:(counter to init file & rank from square index);
        List.Add(File From Square Index, file from square index);
        List.Add(Rank From Square Index, rank from square index);
        If (Variable.Length((counter to init file & rank from square index - 1)) == 1)
        {
            List.Add(Zero Before Single Digit Numbers (1 offset), Operator.Join(0, (counter to init file & rank from square index - 1)));
        }
        Else
        {
            List.Add(Zero Before Single Digit Numbers (1 offset), (counter to init file & rank from square index - 1));
        }
    }
    List.DeleteAll(Zero Before 1-3 => 4 Digit Num (1 offset));
    counter to init file & rank from square index = 0;
    Repeat (10000)
    {
        counter to init file & rank from square index += 1;
        current val to init 0 padding for move = (counter to init file & rank from square index - 1);
        Repeat (4)
        {
            If (Variable.Length(current val to init 0 padding for move) < 4)
            {
                current val to init 0 padding for move = Operator.Join(0, current val to init 0 padding for move);
            }
        }
        List.Add(Zero Before 1-3 => 4 Digit Num (1 offset), current val to init 0 padding for move);
    }
}

Define InitHashLookup (warp=true)
{
    List.DeleteAll(PosPieceHashLookup);
    Repeat (1024)
    {
        List.Add(PosPieceHashLookup, Operator.Random((1 - (65536 * (65536 * 65536))) , (65536 * (65536 * 65536))));
    }
    WD_side key (hash table) = Operator.Random((1 - (65536 * (65536 * 65536))) , (65536 * (65536 * 65536)));
}

Define initialize distance to center & distance to square (warp=true)
{
    List.DeleteAll(Distance To Center);
    counter to get distance to center = 0;
    Repeat (64)
    {
        counter to get distance to center += 1;
        Call get rank and file from square index:(counter to get distance to center);
        If ((4 - file from square index) > (file from square index - 5))
        {
            distance to center temp1 = (4 - file from square index);
        }
        Else
        {
            distance to center temp1 = (file from square index - 5);
        }
        If ((4 - rank from square index) > (rank from square index - 5))
        {
            distance to center temp2 = (4 - rank from square index);
        }
        Else
        {
            distance to center temp2 = (rank from square index - 5);
        }
        List.Add(Distance To Center, (distance to center temp1 + distance to center temp2));
    }
    List.DeleteAll(Manhattan Distance To Square);
    List.DeleteAll(Chebyshev Distance to Square);
    counter to get distance to square 1 = 0;
    Repeat (64)
    {
        counter to get distance to square 1 += 1;
        Call get rank and file from square index:(counter to get distance to square 1);
        rank temp (for getting distance to square) = rank from square index;
        file temp (for getting distance to square) = file from square index;
        counter to get distance to square 2 = 0;
        Repeat (64)
        {
            counter to get distance to square 2 += 1;
            Call get rank and file from square index:(counter to get distance to square 2);
            List.Add(Manhattan Distance To Square, (abs((rank temp (for getting distance to square) - rank from square index)) + abs((file temp (for getting distance to square) - file from square index))));
            If (abs((rank temp (for getting distance to square) - rank from square index)) > abs((file temp (for getting distance to square) - file from square index)))
            {
                List.Add(Chebyshev Distance to Square, abs((rank temp (for getting distance to square) - rank from square index)));
            }
            Else
            {
                List.Add(Chebyshev Distance to Square, abs((file temp (for getting distance to square) - file from square index)));
            }
        }
    }
}

Define initialize engine with max real depth:(string max real depth) reset all data?(string reset all data) (warp=true)
{
    List.DeleteAll(Board Hash At Depth);
    List.DeleteAll(Best Move);
    List.DeleteAll(MaxEval);
    List.DeleteAll(MinEval);
    List.DeleteAll(MinMax Results);
    List.DeleteAll(Moves Count);
    List.DeleteAll(Moves Index);
    List.DeleteAll(Alphas);
    List.DeleteAll(Betas);
    List.DeleteAll(targetPieces);
    List.DeleteAll(StartsInCheck?);
    List.DeleteAll(sourcePiece);
    List.DeleteAll(BestMoveIndex);
    List.DeleteAll(TTentryUsed?);
    List.DeleteAll(ScoreTypes);
    List.DeleteAll(Is Futility Pruned?);
    List.DeleteAll(Stand-Pat);
    List.DeleteAll(Move Type (applying moves));
    List.DeleteAll(Moves Played In Search);
    List.DeleteAll(TTentryUsed (line));
    List.DeleteAll(Hash Move);
    List.DeleteAll(STATIC EVAL AT DEPTH);
    List.DeleteAll(Apply Num Extensions At Depth);
    List.DeleteAll(PutsInCheck?);
    List.DeleteAll(OP KING ID AT DEPTH);
    List.DeleteAll(Fully Legal Move Gen?);
    List.DeleteAll(BoardAttackedBySideToMovePieceSnapshot);
    List.DeleteAll(BoardAttackedBySideToMoveSnapshot);
    List.DeleteAll(BoardAttackedBySideToMovePieceSnapshot 2);
    List.DeleteAll(Search Node State:);
    List.DeleteAll(Real Search Depth For Move);
    List.DeleteAll(Large Positional in Static Eval at Depth);
    List.DeleteAll(Alphas Temp);
    List.DeleteAll(Betas Temp);
    List.DeleteAll(Best Score Temp);
    List.DeleteAll(Minmax Res Temp);
    List.DeleteAll(Moves Index Temp);
    List.DeleteAll(Exclude Move at Depth);
    List.DeleteAll(Real Moves Index at Depth);
    List.DeleteAll(TTread Score at Depth);
    List.DeleteAll(TTread Node Type at Depth);
    List.DeleteAll(TTread Horizon at Depth);
    List.DeleteAll(Next Ply Board Hash);
    If (reset all data == 1)
    {
        List.DeleteAll(WD_CastlingRights);
        List.DeleteAll(WD_EnPassantTarget);
        List.DeleteAll(ITERATIVE IDX BEST MOVE IN POS);
        List.DeleteAll(ITERATIVE IDX EVAL AT POS);
        List.DeleteAll(PV_length);
        List.DeleteAll(PV_moves);
        List.DeleteAll(PV Res At Depth);
    }
    Repeat (max real depth)
    {
        List.Add(Fully Legal Move Gen?, 0);
        List.Add(OP KING ID AT DEPTH, "");
        List.Add(PutsInCheck?, 0);
        List.Add(Board Hash At Depth, "");
        List.Add(Apply Num Extensions At Depth, "");
        List.Add(Best Move, "");
        List.Add(MaxEval, "");
        List.Add(MinEval, "");
        List.Add(MinMax Results, "");
        List.Add(Moves Count, "");
        List.Add(Moves Index, "");
        List.Add(Alphas, "");
        List.Add(Betas, "");
        List.Add(targetPieces, "");
        List.Add(StartsInCheck?, 0);
        List.Add(sourcePiece, "");
        List.Add(BestMoveIndex, "");
        List.Add(TTentryUsed?, "");
        List.Add(ScoreTypes, "");
        List.Add(Is Futility Pruned?, "");
        List.Add(Stand-Pat, "");
        List.Add(Move Type (applying moves), "");
        List.Add(Moves Played In Search, "");
        List.Add(TTentryUsed (line), "");
        List.Add(Hash Move, "");
        List.Add(STATIC EVAL AT DEPTH, "");
        List.Add(BoardAttackedBySideToMovePieceSnapshot, "");
        List.Add(BoardAttackedBySideToMovePieceSnapshot 2, "");
        List.Add(BoardAttackedBySideToMoveSnapshot, "");
        List.Add(Search Node State:, "");
        List.Add(Real Search Depth For Move, "");
        List.Add(Large Positional in Static Eval at Depth, "");
        List.Add(Alphas Temp, "");
        List.Add(Betas Temp, "");
        List.Add(Best Score Temp, "");
        List.Add(Minmax Res Temp, "");
        List.Add(Moves Index Temp, "");
        List.Add(Exclude Move at Depth, "");
        List.Add(Real Moves Index at Depth, "");
        List.Add(TTread Node Type at Depth, "");
        List.Add(TTread Score at Depth, "");
        List.Add(TTread Horizon at Depth, "");
        List.Add(Next Ply Board Hash, "");
        If (reset all data == 1)
        {
            List.Add(ITERATIVE IDX BEST MOVE IN POS, "");
            List.Add(WD_CastlingRights, "");
            List.Add(WD_EnPassantTarget, "");
            List.Add(ITERATIVE IDX EVAL AT POS, "");
            List.Add(PV_length, "");
            List.Add(PV Res At Depth, "");
            Repeat (max real depth)
            {
                List.Add(PV_moves, "");
            }
        }
    }
    List.Add(WD_EnPassantTarget, "");
    List.DeleteAll(KillerMoves);
    Repeat (200)
    {
        List.Add(KillerMoves, "");
    }
}

Define initialize squares until end of board (warp=true)
{
    List.DeleteAll(Squares Until End Of Board 1);
    List.DeleteAll(Squares Until End Of Board 3);
    List.DeleteAll(Squares Until End Of Board 5);
    List.DeleteAll(Squares Until End Of Board 7);
    List.DeleteAll(Squares Until End Of Board 2);
    List.DeleteAll(Squares Until End Of Board 4);
    List.DeleteAll(Squares Until End Of Board 6);
    List.DeleteAll(Squares Until End Of Board 8);
    counter to initialize squares until end of board = 0;
    Repeat (64)
    {
        counter to initialize squares until end of board += 1;
        Call get rank and file from square index:(counter to initialize squares until end of board);
        List.Add(Squares Until End Of Board 1, (8 - file from square index));
        List.Add(Squares Until End Of Board 3, (8 - rank from square index));
        List.Add(Squares Until End Of Board 5, (file from square index - 1));
        List.Add(Squares Until End Of Board 7, (rank from square index - 1));
        If (Squares Until End Of Board 1[counter to initialize squares until end of board] < Squares Until End Of Board 3[counter to initialize squares until end of board])
        {
            List.Add(Squares Until End Of Board 2, Squares Until End Of Board 1[counter to initialize squares until end of board]);
        }
        Else
        {
            List.Add(Squares Until End Of Board 2, Squares Until End Of Board 3[counter to initialize squares until end of board]);
        }
        If (Squares Until End Of Board 3[counter to initialize squares until end of board] < Squares Until End Of Board 5[counter to initialize squares until end of board])
        {
            List.Add(Squares Until End Of Board 4, Squares Until End Of Board 3[counter to initialize squares until end of board]);
        }
        Else
        {
            List.Add(Squares Until End Of Board 4, Squares Until End Of Board 5[counter to initialize squares until end of board]);
        }
        If (Squares Until End Of Board 5[counter to initialize squares until end of board] < Squares Until End Of Board 7[counter to initialize squares until end of board])
        {
            List.Add(Squares Until End Of Board 6, Squares Until End Of Board 5[counter to initialize squares until end of board]);
        }
        Else
        {
            List.Add(Squares Until End Of Board 6, Squares Until End Of Board 7[counter to initialize squares until end of board]);
        }
        If (Squares Until End Of Board 7[counter to initialize squares until end of board] < Squares Until End Of Board 1[counter to initialize squares until end of board])
        {
            List.Add(Squares Until End Of Board 8, Squares Until End Of Board 7[counter to initialize squares until end of board]);
        }
        Else
        {
            List.Add(Squares Until End Of Board 8, Squares Until End Of Board 1[counter to initialize squares until end of board]);
        }
    }
}

Define init knight movement table (warp=true)
{
    List.DeleteAll(Knight Movement Table);
    List.DeleteAll(Knight Movement Table Endsquare);
    var to init knight movement table = 0;
    Repeat (64)
    {
        var to init knight movement table += 1;
        Call get rank and file from square index:(var to init knight movement table);
        counter to find legal moves for knight = 0;
        Repeat (8)
        {
            counter to find legal moves for knight += 1;
            List.Add(Knight Movement Table, "");
            List.Add(Knight Movement Table Endsquare, "");
            total knight movement x = (file from square index + Knight Movement X Offsets[counter to find legal moves for knight]);
            total knight movement y = (rank from square index + Knight Movement Y Offsets[counter to find legal moves for knight]);
            If ((total knight movement x < 9) And (total knight movement x > 0))
            {
                If ((total knight movement y < 9) And (total knight movement y > 0))
                {
                    new square temp moving pieces = (var to init knight movement table + Knight Movement Offsets (Addition/Subtraction)[counter to find legal moves for knight]);
                    List.ReplaceItem(Knight Movement Table, List.Length(Knight Movement Table), Operator.Join(Zero Before Single Digit Numbers (1 offset)[(var to init knight movement table + 1)], Zero Before Single Digit Numbers (1 offset)[(new square temp moving pieces + 1)]));
                    List.ReplaceItem(Knight Movement Table Endsquare, List.Length(Knight Movement Table Endsquare), new square temp moving pieces);
                }
            }
        }
    }
}

Define init map white pst to black pst (warp=true)
{
    counter to map white pst to black pst = 0;
    List.DeleteAll(White PST to Black PST (Vert Refl));
    Repeat (64)
    {
        counter to map white pst to black pst += 1;
        Call get rank and file from square index:(counter to map white pst to black pst);
        List.Add(White PST to Black PST (Vert Refl), (counter to map white pst to black pst - (((4.5 - rank from square index) * 8) * 2)));
    }
}

Define init massive list to verify checks (warp=true)
{
    List.DeleteAll(MASSIVE LIST TO VERIFY CHECKS);
    counter to count chunk ID (massive list to verify checks) = 0;
    Repeat (6)
    {
        counter to count chunk ID (massive list to verify checks) += 1;
        piece type (massive list to verify checks) = (List.IndexOf(PIECE TYPE TO CHECK CHUNK, counter to count chunk ID (massive list to verify checks)) - 1000);
        start square (massive list to verify checks) = 0;
        Repeat (64)
        {
            start square (massive list to verify checks) += 1;
            target square (massive list to verify checks) = 0;
            Repeat (64)
            {
                target square (massive list to verify checks) += 1;
                Call TOOL - DON'T USE | does piece type:(piece type (massive list to verify checks)) on square:(start square (massive list to verify checks)) check square:(target square (massive list to verify checks)) TOOL USE THE OTHER FUNCTION INSTEAD, IT'S MUCH FASTER  |  ignore pieces(1);
                If (piece check square res (WD) == 1)
                {
                    If ((abs(piece type (massive list to verify checks)) == 100) Or (abs(piece type (massive list to verify checks)) == 320))
                    {
                        List.Add(MASSIVE LIST TO VERIFY CHECKS, 99);
                    }
                    Else
                    {
                        List.Add(MASSIVE LIST TO VERIFY CHECKS, potential check direction (for check gen));
                    }
                }
                Else
                {
                    List.Add(MASSIVE LIST TO VERIFY CHECKS, "");
                }
            }
        }
    }
}

Define init piece to NN input type (warp=true)
{
    List.DeleteAll(piece to NN Input type);
    counter to init piece to NN input type = 0;
    Repeat (2000)
    {
        counter to init piece to NN input type += 1;
        If ((100 + 1000) == counter to init piece to NN input type)
        {
            List.Add(piece to NN Input type, 1);
        }
        Else
        {
            If ((320 + 1000) == counter to init piece to NN input type)
            {
                List.Add(piece to NN Input type, 2);
            }
            Else
            {
                If ((330 + 1000) == counter to init piece to NN input type)
                {
                    List.Add(piece to NN Input type, 3);
                }
                Else
                {
                    If ((500 + 1000) == counter to init piece to NN input type)
                    {
                        List.Add(piece to NN Input type, 4);
                    }
                    Else
                    {
                        If ((900 + 1000) == counter to init piece to NN input type)
                        {
                            List.Add(piece to NN Input type, 5);
                        }
                        Else
                        {
                            If ((-100 + 1000) == counter to init piece to NN input type)
                            {
                                List.Add(piece to NN Input type, 7);
                            }
                            Else
                            {
                                If ((-320 + 1000) == counter to init piece to NN input type)
                                {
                                    List.Add(piece to NN Input type, 8);
                                }
                                Else
                                {
                                    If ((-330 + 1000) == counter to init piece to NN input type)
                                    {
                                        List.Add(piece to NN Input type, 9);
                                    }
                                    Else
                                    {
                                        If ((-500 + 1000) == counter to init piece to NN input type)
                                        {
                                            List.Add(piece to NN Input type, 10);
                                        }
                                        Else
                                        {
                                            If ((-900 + 1000) == counter to init piece to NN input type)
                                            {
                                                List.Add(piece to NN Input type, 11);
                                            }
                                            Else
                                            {
                                                List.Add(piece to NN Input type, "");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

Define init piece type to attacking king chunk (warp=true)
{
    List.DeleteAll(PIECE TYPE TO CHECK CHUNK);
    counter to init piece type to chunk (checks) = 0;
    Repeat (1900)
    {
        counter to init piece type to chunk (checks) += 1;
        If (counter to init piece type to chunk (checks) == (-100 + 1000))
        {
            List.Add(PIECE TYPE TO CHECK CHUNK, 1);
        }
        Else
        {
            If (counter to init piece type to chunk (checks) == (100 + 1000))
            {
                List.Add(PIECE TYPE TO CHECK CHUNK, 2);
            }
            Else
            {
                If ((counter to init piece type to chunk (checks) == (320 + 1000)) Or (counter to init piece type to chunk (checks) == (-320 + 1000)))
                {
                    List.Add(PIECE TYPE TO CHECK CHUNK, 3);
                }
                Else
                {
                    If ((counter to init piece type to chunk (checks) == (330 + 1000)) Or (counter to init piece type to chunk (checks) == (-330 + 1000)))
                    {
                        List.Add(PIECE TYPE TO CHECK CHUNK, 4);
                    }
                    Else
                    {
                        If ((counter to init piece type to chunk (checks) == (500 + 1000)) Or (counter to init piece type to chunk (checks) == (-500 + 1000)))
                        {
                            List.Add(PIECE TYPE TO CHECK CHUNK, 5);
                        }
                        Else
                        {
                            If ((counter to init piece type to chunk (checks) == (900 + 1000)) Or (counter to init piece type to chunk (checks) == (-900 + 1000)))
                            {
                                List.Add(PIECE TYPE TO CHECK CHUNK, 6);
                            }
                            Else
                            {
                                List.Add(PIECE TYPE TO CHECK CHUNK, "");
                            }
                        }
                    }
                }
            }
        }
    }
}

Define init piece type to id (warp=true)
{
    List.DeleteAll(PIECE ID TO TYPE (WD));
    List.Add(PIECE ID TO TYPE (WD), 100);
    List.Add(PIECE ID TO TYPE (WD), 320);
    List.Add(PIECE ID TO TYPE (WD), 330);
    List.Add(PIECE ID TO TYPE (WD), 500);
    List.Add(PIECE ID TO TYPE (WD), 900);
    List.Add(PIECE ID TO TYPE (WD), 99999);
    List.Add(PIECE ID TO TYPE (WD), -100);
    List.Add(PIECE ID TO TYPE (WD), -320);
    List.Add(PIECE ID TO TYPE (WD), -330);
    List.Add(PIECE ID TO TYPE (WD), -500);
    List.Add(PIECE ID TO TYPE (WD), -900);
    List.Add(PIECE ID TO TYPE (WD), -99999);
    List.DeleteAll(PIECE TYPE TO ID);
    Repeat (199999)
    {
        If (((100 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
        {
            List.Add(PIECE TYPE TO ID, 1);
        }
        Else
        {
            If (((320 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
            {
                List.Add(PIECE TYPE TO ID, 2);
            }
            Else
            {
                If (((330 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
                {
                    List.Add(PIECE TYPE TO ID, 3);
                }
                Else
                {
                    If (((500 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
                    {
                        List.Add(PIECE TYPE TO ID, 4);
                    }
                    Else
                    {
                        If (((900 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
                        {
                            List.Add(PIECE TYPE TO ID, 5);
                        }
                        Else
                        {
                            If (((99999 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
                            {
                                List.Add(PIECE TYPE TO ID, 6);
                            }
                            Else
                            {
                                If (((-100 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
                                {
                                    List.Add(PIECE TYPE TO ID, 7);
                                }
                                Else
                                {
                                    If (((-320 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
                                    {
                                        List.Add(PIECE TYPE TO ID, 8);
                                    }
                                    Else
                                    {
                                        If (((-330 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
                                        {
                                            List.Add(PIECE TYPE TO ID, 9);
                                        }
                                        Else
                                        {
                                            If (((-500 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
                                            {
                                                List.Add(PIECE TYPE TO ID, 10);
                                            }
                                            Else
                                            {
                                                If (((-900 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
                                                {
                                                    List.Add(PIECE TYPE TO ID, 11);
                                                }
                                                Else
                                                {
                                                    If (((-99999 + 100000) - 1) == List.Length(PIECE TYPE TO ID))
                                                    {
                                                        List.Add(PIECE TYPE TO ID, 12);
                                                    }
                                                    Else
                                                    {
                                                        List.Add(PIECE TYPE TO ID, 0);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

Define init rank & file from square index math with index:(string index) (warp=true)
{
    file from square index = ((index % 8) + (((index % 8) == 0) * 8));
    rank from square index = (9 - (floor(((index - 0.01) / 8)) + 1));
}

Define init WD_NNUE info (warp=true)
{
    List.DeleteAll(WD_NNUE_PrevRefreshBoard);
    Repeat (64)
    {
        List.Add(WD_NNUE_PrevRefreshBoard, "");
    }
    Call WD_NNUE reset accumulator info;
}

Define init white pawns movement table (warp=true)
{
    List.DeleteAll(White Pawn Movement Table);
    var to init pawn movement table = 0;
    Repeat (64)
    {
        var to init pawn movement table += 1;
        Call get rank and file from square index:(var to init pawn movement table);
        If ((rank from square index > 1) And (rank from square index < 8))
        {
            If (file from square index > 1)
            {
                List.Add(White Pawn Movement Table, Operator.Join(Zero Before Single Digit Numbers (1 offset)[(var to init pawn movement table + 1)], Zero Before Single Digit Numbers (1 offset)[((var to init pawn movement table - 9) + 1)]));
            }
            Else
            {
                List.Add(White Pawn Movement Table, "");
            }
            If (file from square index < 8)
            {
                List.Add(White Pawn Movement Table, Operator.Join(Zero Before Single Digit Numbers (1 offset)[(var to init pawn movement table + 1)], Zero Before Single Digit Numbers (1 offset)[((var to init pawn movement table - 7) + 1)]));
            }
            Else
            {
                List.Add(White Pawn Movement Table, "");
            }
            List.Add(White Pawn Movement Table, Operator.Join(Zero Before Single Digit Numbers (1 offset)[(var to init pawn movement table + 1)], Zero Before Single Digit Numbers (1 offset)[((var to init pawn movement table - 8) + 1)]));
            If (rank from square index == 2)
            {
                List.Add(White Pawn Movement Table, Operator.Join(Zero Before Single Digit Numbers (1 offset)[(var to init pawn movement table + 1)], Zero Before Single Digit Numbers (1 offset)[((var to init pawn movement table - 16) + 1)]));
            }
            Else
            {
                List.Add(White Pawn Movement Table, "");
            }
        }
        Else
        {
            Repeat (4)
            {
                List.Add(White Pawn Movement Table, "");
            }
        }
    }
}

Define is bad capture? with depth:(string depth) (warp=true)
{
    is bad capture? (q-search) = 0;
    If (Not ((Move Type (applying moves)[depth] == "capture")))
    {
        Stop(this script);
    }
    If ((StartsInCheck?[depth] == 1) Or (PutsInCheck?[depth] == 1))
    {
        Stop(this script);
    }
    If (abs(sourcePiece[depth]) == 100)
    {
        Stop(this script);
    }
    If (Not ((abs(targetPieces[depth]) < (abs(sourcePiece[depth]) - 50))))
    {
        Stop(this script);
    }
    Call get rank and file from square index:(floor((Moves Played In Search[depth] % 100)));
    If ((depth % 2) == 1)
    {
        If (((abs(targetPieces[depth]) + 200) - abs(sourcePiece[depth])) < 0)
        {
            If (((Current Board Position[(floor((Moves Played In Search[depth] % 100)) + 9)] == 100) And (file from square index < 8)) Or ((Current Board Position[(floor((Moves Played In Search[depth] % 100)) + 7)] == 100) And (file from square index > 1)))
            {
                is bad capture? (q-search) = 1;
                Stop(this script);
            }
        }
    }
    Else
    {
        If (((abs(targetPieces[depth]) + 200) - abs(sourcePiece[depth])) < 0)
        {
            If (((Current Board Position[(floor((Moves Played In Search[depth] % 100)) - 9)] == -100) And (file from square index > 1)) Or ((Current Board Position[(floor((Moves Played In Search[depth] % 100)) - 7)] == -100) And (file from square index < 8)))
            {
                is bad capture? (q-search) = 1;
                Stop(this script);
            }
        }
    }
}

Define isEndgame + Easy Draw Detection (eval) (warp=true)
{
    draw by material? (eval) = 0;
    isEndgame? (for eval) = 0;
    isSimpleEndgame? (for eval) = 0;
    BLACK IN ENDGAME? (EVAL) = 0;
    WHITE IN ENDGAME? (EVAL) = 0;
    If ((WHITE MATERIAL (NO PAWNS) < (ENDGAME MATERIAL THRESHOLD / 2)) Or ((NUM WHITE MAJOR PIECES (EVAL) + NUM WHITE MINOR PIECES (EVAL)) < 4))
    {
        WHITE IN ENDGAME? (EVAL) = 1;
    }
    If ((BLACK MATERIAL (NO PAWNS) < (ENDGAME MATERIAL THRESHOLD / 2)) Or ((NUM BLACK MAJOR PIECES (EVAL) + NUM BLACK MINOR PIECES (EVAL)) < 4))
    {
        BLACK IN ENDGAME? (EVAL) = 1;
    }
    If ((NUM WHITE MINOR PIECES (EVAL) + NUM BLACK MINOR PIECES (EVAL)) < 5)
    {
        If ((NUM WHITE MAJOR PIECES (EVAL) + NUM BLACK MAJOR PIECES (EVAL)) == 0)
        {
            Call // comment("simple endgame");
            isSimpleEndgame? (for eval) = 1;
        }
    }
    Call // comment("the goal of the following checks is to see if there is a "dead" draw by material");
    Call // comment("however, endgames like KRN vs KR can be a bit tricky, so simply scale down the eval in the "possible to win" section");
    If ((PIECE MATERIAL (NO PAWNS) (EVAL) < ENDGAME MATERIAL THRESHOLD) Or (((NUM WHITE MAJOR PIECES (EVAL) + NUM WHITE MINOR PIECES (EVAL)) < 4) And ((NUM BLACK MAJOR PIECES (EVAL) + NUM BLACK MINOR PIECES (EVAL)) < 4)))
    {
        isEndgame? (for eval) = 1;
        If (NUM TOTAL PAWNS (EVAL) == 0)
        {
            Call // comment("no pawns on board");
            If ((NUM WHITE MAJOR PIECES (EVAL) + NUM BLACK MAJOR PIECES (EVAL)) == 0)
            {
                Call // comment("no major pieces on board");
                If ((NUM BLACK MINOR PIECES (EVAL) < 2) And (NUM WHITE MINOR PIECES (EVAL) < 2))
                {
                    BOARD EVAL = CPU CONTEMPT VALUE;
                    draw by material? (eval) = 1;
                    Stop(this script);
                }
                If ((NUM BLACK MINOR PIECES (EVAL) == 0) And ((NUM WHITE MINOR PIECES (EVAL) == 2) And (NUM WHITE KNIGHTS (EVAL) == 2)))
                {
                    BOARD EVAL = CPU CONTEMPT VALUE;
                    draw by material? (eval) = 1;
                    Stop(this script);
                }
                If ((NUM WHITE MINOR PIECES (EVAL) == 0) And ((NUM BLACK MINOR PIECES (EVAL) == 2) And (NUM BLACK KNIGHTS (EVAL) == 2)))
                {
                    BOARD EVAL = CPU CONTEMPT VALUE;
                    draw by material? (eval) = 1;
                    Stop(this script);
                }
            }
            Call // comment("some major pieces");
            If (((NUM WHITE MINOR PIECES (EVAL) + NUM BLACK MINOR PIECES (EVAL)) == 0) And (((NUM BLACK MAJOR PIECES (EVAL) + NUM WHITE MAJOR PIECES (EVAL)) == 2) And ((NUM BLACK ROOKS (EVAL) == 1) And (NUM WHITE ROOKS (EVAL) == 1))))
            {
                BOARD EVAL = CPU CONTEMPT VALUE;
                draw by material? (eval) = 1;
                Stop(this script);
            }
            If (((NUM WHITE MINOR PIECES (EVAL) + NUM BLACK MINOR PIECES (EVAL)) == 0) And (((NUM BLACK MAJOR PIECES (EVAL) + NUM WHITE MAJOR PIECES (EVAL)) == 2) And ((NUM BLACK QUEENS (EVAL) == 1) And (NUM WHITE QUEENS (EVAL) == 1))))
            {
                BOARD EVAL = CPU CONTEMPT VALUE;
                draw by material? (eval) = 1;
                Stop(this script);
            }
        }
    }
}

Define is pawn passed? (eval) (warp=true)
{
    isPawnPassed (for eval)? = 0;
    If (current piece (eval) == 100)
    {
        Call get their least advanced pawn on file:((file from square index + 0)) (eval)((1 == 1));
        If (Not ((their least advanced blocker pawn (eval) < rank from square index)))
        {
            Stop(this script);
        }
        Call get not passed condition((1 == 1)) target file:((file from square index + -1)) (eval);
        If (not passed cond. res (eval) == 1)
        {
            Stop(this script);
        }
        Call get not passed condition((1 == 1)) target file:((file from square index + 1)) (eval);
        If (not passed cond. res (eval) == 1)
        {
            Stop(this script);
        }
        isPawnPassed (for eval)? = 1;
        Stop(this script);
    }
    If (current piece (eval) == -100)
    {
        Call get their least advanced pawn on file:((file from square index + 0)) (eval)((0 == 1));
        If (Not ((their least advanced blocker pawn (eval) > rank from square index)))
        {
            Stop(this script);
        }
        Call get not passed condition((0 == 1)) target file:((file from square index + 1)) (eval);
        If (not passed cond. res (eval) == 1)
        {
            Stop(this script);
        }
        Call get not passed condition((0 == 1)) target file:((file from square index + -1)) (eval);
        If (not passed cond. res (eval) == 1)
        {
            Stop(this script);
        }
        isPawnPassed (for eval)? = 1;
    }
}

Define is piece an attacker with type:(string type) pos:(string square idx) (warp=true)
{
    piece in black king shield? = 0;
    piece in white king shield? = 0;
    piece is attacker? (eval) = 0;
    If (((type + 0) == 0) Or (abs(type) == 99999))
    {
        Stop(this script);
    }
    If (Not ((abs(type) == 100)))
    {
        If (type > 0)
        {
            If (White King Ring (eval)[square idx] == 1)
            {
                piece in white king shield? = 1;
            }
        }
        Else
        {
            If (Black King Ring (eval)[square idx] == 1)
            {
                piece in black king shield? = 1;
            }
        }
    }
    Call get rank and file from square index:(counter for evaluation);
    If (type > 0)
    {
        Call // comment("WHITE PIECES");
        If (type == 100)
        {
            Call // comment("white pawn");
            If (rank from square index < BlackKingRank (eval))
            {
                If (abs((file from square index - BlackKingFile (eval))) == 1)
                {
                    If ((rank from square index - BlackKingRank (eval)) == -2)
                    {
                        num black king attackers (eval) += 1;
                        black king attacking force += 150;
                        piece is attacker? (eval) = 1;
                        Stop(this script);
                    }
                }
                If (abs((file from square index - BlackKingFile (eval))) < 3)
                {
                    If ((BlackKingRank (eval) - rank from square index) < 3)
                    {
                        num black king attackers (eval) += 1;
                        black king attacking force += 75;
                        piece is attacker? (eval) = 1;
                        Stop(this script);
                    }
                    If ((BlackKingRank (eval) - rank from square index) < 4)
                    {
                        If (BlackKingRank (eval) == 8)
                        {
                            num black king attackers (eval) += 1;
                            black king attacking force += 25;
                            piece is attacker? (eval) = 1;
                            Stop(this script);
                        }
                    }
                }
            }
            Stop(this script);
        }
        Stop(this script);
    }
    If (type < 0)
    {
        Call // comment("BLACK PIECES");
        If (type == -100)
        {
            Call // comment("black pawn");
            If (rank from square index > WhiteKingRank (eval))
            {
                If (abs((file from square index - WhiteKingFile (eval))) == 1)
                {
                    If ((rank from square index - WhiteKingRank (eval)) == 2)
                    {
                        piece is attacker? (eval) = 1;
                        num white king attackers (eval) += 1;
                        white king attacking force += 200;
                        Stop(this script);
                    }
                }
                If (abs((file from square index - WhiteKingFile (eval))) < 3)
                {
                    If ((rank from square index - WhiteKingRank (eval)) < 3)
                    {
                        piece is attacker? (eval) = 1;
                        num white king attackers (eval) += 1;
                        white king attacking force += 75;
                        Stop(this script);
                    }
                    If ((rank from square index - WhiteKingRank (eval)) < 4)
                    {
                        If (WhiteKingRank (eval) == 1)
                        {
                            piece is attacker? (eval) = 1;
                            num white king attackers (eval) += 1;
                            white king attacking force += 25;
                            Stop(this script);
                        }
                    }
                }
            }
            Stop(this script);
        }
    }
}

Define is piece on square:(string square idx) pinned to king:(string king type) king rank:(string king rank) king file:(string king file) (warp=true)
{
    piece is pinned res (eval) = 0;
    Call get rank and file from square index:(square idx);
    Call get square idx with rank:(king rank) file:(king file);
    Call get dir from square to square(square idx)(square idx from rank and file res);
    If (Not ((dir from square to square res > 0)))
    {
        Stop(this script);
    }
    piece pin detection delta rank = (((king rank - rank from square index) > 0) - ((king rank - rank from square index) < 0));
    piece pin detection delta file = (((king file - file from square index) > 0) - ((king file - file from square index) < 0));
    Call closest piece from square idx:(square idx) delta rank:((1 * piece pin detection delta rank)) delta file:((1 * piece pin detection delta file));
    If (Not ((closest piece from square res == king type)))
    {
        Stop(this script);
    }
    Call closest piece from square idx:(square idx) delta rank:((-1 * piece pin detection delta rank)) delta file:((-1 * piece pin detection delta file));
    If (king type == 99999)
    {
        If (closest piece from square res == -900)
        {
            piece is pinned res (eval) = 1;
        }
        If (closest piece from square res == -500)
        {
            If ((dir from square to square res % 2) == 1)
            {
                piece is pinned res (eval) = 1;
            }
        }
        If (closest piece from square res == -330)
        {
            If ((dir from square to square res % 2) == 0)
            {
                piece is pinned res (eval) = 1;
            }
        }
    }
    Else
    {
        If (closest piece from square res == 900)
        {
            piece is pinned res (eval) = 1;
        }
        If (closest piece from square res == 500)
        {
            If ((dir from square to square res % 2) == 1)
            {
                piece is pinned res (eval) = 1;
            }
        }
        If (closest piece from square res == 330)
        {
            If ((dir from square to square res % 2) == 0)
            {
                piece is pinned res (eval) = 1;
            }
        }
    }
}

Define is piece pinned (eval)(bool white?) (warp=true)
{
    If white?
    {
        Call is piece on square:(counter for evaluation) pinned to king:(99999) king rank:(WhiteKingRank (eval)) king file:(WhiteKingFile (eval));
    }
    Else
    {
        Call is piece on square:(counter for evaluation) pinned to king:(-99999) king rank:(BlackKingRank (eval)) king file:(BlackKingFile (eval));
    }
}

Define is square outpost?(string square idx)(bool white?) (eval) (warp=true)
{
    is square outpost res (eval) = 0;
    Call get rank and file from square idx:(square idx) background function;
    If white?
    {
        If (White Pawn Attacks Square (eval)[square idx] > 0)
        {
            If (Black Pawn Attacks Square (eval)[square idx] == 0)
            {
                If (((file from square idx background == 1) Or ((Least Advanced Black Pawn[(file from square idx background - 1)] < (rank from square idx background + 1)) Or ((White Pawn Attacks Square (eval)[(square idx - 9)] > 0) Or (Current Board Position[(square idx - 9)] == 100)))) And ((file from square idx background == 8) Or ((Least Advanced Black Pawn[(file from square idx background + 1)] < (rank from square idx background + 1)) Or ((White Pawn Attacks Square (eval)[(square idx - 7)] > 0) Or (Current Board Position[(square idx - 7)] == 100)))))
                {
                    If (rank from square idx background > 3)
                    {
                        is square outpost res (eval) = 1;
                        Stop(this script);
                    }
                }
            }
        }
    }
    Else
    {
        If (Black Pawn Attacks Square (eval)[square idx] > 0)
        {
            If (White Pawn Attacks Square (eval)[square idx] == 0)
            {
                If (((file from square idx background == 1) Or ((Least Advanced White Pawn[(file from square idx background - 1)] > (rank from square idx background - 1)) Or ((Black Pawn Attacks Square (eval)[(square idx + 7)] > 0) Or (Current Board Position[(square idx + 9)] == -100)))) And ((file from square idx background == 8) Or ((Least Advanced White Pawn[(file from square idx background + 1)] > (rank from square idx background - 1)) Or ((Black Pawn Attacks Square (eval)[(square idx + 9)] > 0) Or (Current Board Position[(square idx + 9)] == -100)))))
                {
                    If (rank from square idx background < 6)
                    {
                        is square outpost res (eval) = 1;
                        Stop(this script);
                    }
                }
            }
        }
    }
}

Define is uppercase?(string character) (warp=true)
{
    supported characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    i = 1;
    str = "";
    Repeat (Variable.Length(supported characters))
    {
        If (Operator.LetterOf(supported characters, i) == character)
        {
            str = Operator.Join(str, character);
        }
        Else
        {
            str = Operator.Join(str, Operator.LetterOf(supported characters, i));
        }
        i += 1;
    }
    Looks.SwitchCostumeTo(White1);
    Looks.SwitchCostumeTo(str);
    If (Costume.GetNumberName(number) == 1)
    {
        is upper case = 1;
    }
    Else
    {
        is upper case = 0;
    }
}

Define iterative deepening search (warp=true)
{
    _g engine evaluation = WD_DELTA_CI DISPLAY EVAL;
    _g engine pv = PV_uci_format_total_res;
    TTcurrentAge = ((TTcurrentAge - (TTcurrentAge % 100)) + 100);
    Call evaluation of current position with depth:(((Who To Move? (WD) == "b") * 1)) force HCE:(1) log debug:();
    Call // comment("Figure out if we should force hand crafted evaluation (HCE) during the search, regardless of NNUE settings");
    Call // comment("(additional verifications will be run in the eval function depending on the specific position)");
    FORCE HCE DURING SEARCH? (NN MODE) = 0;
    If (USE NN FOR EVAL? == 1)
    {
        If (ALLOW HCE FOR LATE ENDGAMES (NN MODE) == 1)
        {
            If (Used Mop-Up Eval? (evaluation) == 1)
            {
                Call // comment("if mop-up range (AKA, late ending, need to find mate), use HCE");
                Call // comment("as HCE is much better at this than NNUE");
                FORCE HCE DURING SEARCH? (NN MODE) = 1;
            }
            Else
            {
                If ((NUM BLACK MAJOR PIECES (EVAL) + (NUM BLACK MINOR PIECES (EVAL) + (NUM WHITE MAJOR PIECES (EVAL) + NUM WHITE MINOR PIECES (EVAL)))) < 5)
                {
                    Call // comment("force HCE for very late endings, as HCE seems to be better there");
                    FORCE HCE DURING SEARCH? (NN MODE) = 1;
                }
                Else
                {
                    FORCE HCE DURING SEARCH? (NN MODE) = 0;
                }
            }
        }
    }
    List.DeleteAll(Iterative Deepening DEBUG);
    Call get think time for search;
    If (PIECE MATERIAL (NO PAWNS) (EVAL) == 0)
    {
        TARGET THINK TIME = (TARGET THINK TIME * 1.4);
    }
    ALREADY INCREASED THINK TIME? = 0;
    last iterative deepening time = 0;
    first search move = "????";
    If (CPU COLOR == "b")
    {
        search starting depth = 1;
    }
    Else
    {
        search starting depth = 2;
    }
    iterative deepening Idx = 1;
    PV_total_res = "";
    PV_total_res_temp = "";
    ALPHA FOR ASPIRATION WINDOW = "-Infinity";
    BETA FOR ASPIRATION WINDOW = "Infinity";
    DISPLAY BEST MOVE = 0000;
    last sure best move eval (ID) = 0;
    WD_DELTA_CI DISPLAY EVAL = 0;
    minmax time exhausted? = 0;
    Call get all legal moves from current position depth:(((CPU COLOR == "w") + 1)) is quiet search?:(0) completely legal?(1) generate checks?("");
    LEGAL CPU MOVES IN POS = List.Length(ALL LEGAL MOVES FOR CPU CALCS);
    List.ReplaceItem(MinMax Results, search starting depth, "nothing (start of search)");
    Repeat Until ((minmax time exhausted? == 1) Or ((iterative deepening Idx > 27) Or ((iterative deepening Idx > 4) And ((abs(MinMax Results[search starting depth]) > 800000) And (SCORE OUTSIDE ASPIRATION WINDOW == 0)))))
    {
        iterative deepening Idx += 1;
        Call get time for search;
        Call evaluation of current position with depth:(((Who To Move? (WD) == "b") * 1)) force HCE:(1) log debug:();
        SCORE OUTSIDE ASPIRATION WINDOW = 0;
        Endgame Eval @ Search Start? = isEndgame? (for eval);
        Performance Settings: = Operator.Join("Mode: ", Performance Mode:);
        Depth of Search = Operator.Join(iterative deepening Idx, Operator.Join("+", "all"));
        last sure best move (ID) = ITERATIVE IDX BEST MOVE IN POS[(iterative deepening Idx - 1)];
        last sure best move eval (ID) = (ITERATIVE IDX EVAL AT POS[(iterative deepening Idx - 1)] / 100);
        WD_DELTA_CI DISPLAY EVAL = last sure best move eval (ID);
        first move not fully searched? (ID) = 0;
        first search move = ITERATIVE IDX BEST MOVE IN POS[(iterative deepening Idx - 1)];
        List.Add(Iterative Deepening DEBUG, Operator.Join("First Searched Move (pre): ", first search move));
        Call set progress bar with depth:(search starting depth);
        List.ReplaceItem(Moves Index, search starting depth, 1);
        List.ReplaceItem(Moves Count, search starting depth, LEGAL CPU MOVES IN POS);
        Event.BroadcastAndWait("update progress bar");
        Control.Wait(0);
        If is compiled?
        {
            Call search for iterative deepening with depth:(1) max depth:((iterative deepening Idx + (search starting depth - 1))) quiet search rounds:("all");
        }
        Else
        {
            Call search for iterative deepening with depth:(1) max depth:((iterative deepening Idx + (search starting depth - 1))) quiet search rounds:(8);
        }
        Call get pv total res from info;
        List.ReplaceItem(PV Res At Depth, iterative deepening Idx, PV_total_res_temp);
        List.ReplaceItem(ITERATIVE IDX EVAL AT POS, iterative deepening Idx, MinMax Results[search starting depth]);
        If (CPU COLOR == "b")
        {
            List.ReplaceItem(ITERATIVE IDX BEST MOVE IN POS, iterative deepening Idx, WD_best move);
        }
        Else
        {
            List.ReplaceItem(ITERATIVE IDX BEST MOVE IN POS, iterative deepening Idx, WHITE CPU BEST MOVE);
        }
        Call get time for search;
        NPS (nodes per second) = ((total nodes: + total q-search nodes:) / (WD_time for search - last iterative deepening time));
        Moves Generated Per Second (Search) = (Total Moves Generated / (WD_time for search - last iterative deepening time));
        Call log iterative debug info;
        last iterative deepening time = WD_time for search;
        If ((Not ((MinMax Results[search starting depth] > ALPHA FOR ASPIRATION WINDOW))) Or (Not ((MinMax Results[search starting depth] < BETA FOR ASPIRATION WINDOW))))
        {
            Call // comment("out of window (non-valid score, must do a re-search)");
            DISPLAY BEST MOVE = ITERATIVE IDX BEST MOVE IN POS[(iterative deepening Idx - 1)];
            SCORE OUTSIDE ASPIRATION WINDOW = 1;
            If (minmax time exhausted? == 0)
            {
                ALPHA FOR ASPIRATION WINDOW = "-Infinity";
                BETA FOR ASPIRATION WINDOW = "Infinity";
                iterative deepening Idx += -1;
            }
        }
        Else
        {
            Call // comment("in window (valid score)");
            PV_total_res = PV_total_res_temp;
            PV_uci_format_total_res = PV_uci_total_res_temp;
            DISPLAY BEST MOVE = WD_best move;
            SCORE OUTSIDE ASPIRATION WINDOW = 0;
            If (minmax time exhausted? == 0)
            {
                If (iterative deepening Idx > 5)
                {
                    ALPHA FOR ASPIRATION WINDOW = (MinMax Results[search starting depth] - 50);
                    BETA FOR ASPIRATION WINDOW = (MinMax Results[search starting depth] + 50);
                }
                Else
                {
                    If (iterative deepening Idx > 3)
                    {
                        ALPHA FOR ASPIRATION WINDOW = (MinMax Results[search starting depth] - 150);
                        BETA FOR ASPIRATION WINDOW = (MinMax Results[search starting depth] + 150);
                    }
                    Else
                    {
                        ALPHA FOR ASPIRATION WINDOW = "-Infinity";
                        BETA FOR ASPIRATION WINDOW = "Infinity";
                    }
                }
            }
        }
        _g engine evaluation = WD_DELTA_CI DISPLAY EVAL;
        _g engine pv = PV_uci_format_total_res;
    }
    If (iterative deepening Idx > 0)
    {
        If (SCORE OUTSIDE ASPIRATION WINDOW == 1)
        {
            If (CPU COLOR == "b")
            {
                WD_best move = ITERATIVE IDX BEST MOVE IN POS[(iterative deepening Idx - 1)];
            }
            Else
            {
                WD_best move = ITERATIVE IDX BEST MOVE IN POS[(iterative deepening Idx - 1)];
                WHITE CPU BEST MOVE = ITERATIVE IDX BEST MOVE IN POS[(iterative deepening Idx - 1)];
            }
        }
        Else
        {
            last sure best move eval (ID) = (ITERATIVE IDX EVAL AT POS[iterative deepening Idx] / 100);
            WD_DELTA_CI DISPLAY EVAL = last sure best move eval (ID);
        }
        Event.Broadcast("update progress bar");
        _g engine evaluation = WD_DELTA_CI DISPLAY EVAL;
        _g engine pv = PV_uci_format_total_res;
    }
    If (WD_best move == "????")
    {
        Call // comment("fail-safe just in case search has weird issues to prevent a bugged move from being played");
        If (CPU COLOR == "b")
        {
            WD_best move = MovesDepth 1[1];
        }
        Else
        {
            WD_best move = MovesDepth 2[1];
            WHITE CPU BEST MOVE = MovesDepth 2[1];
        }
        Call ​​warn​​("BEST MOVE BLANK - RESORTING TO MOVE 1 OF MOVE LIST");
    }
    DISPLAY BEST MOVE = WD_best move;
    _g engine evaluation = WD_DELTA_CI DISPLAY EVAL;
    _g engine pv = PV_uci_format_total_res;
    Call set progress with a:((Operator.Round((WD_time for search * 10)) / 10)) over b:((Operator.Round((WD_time for search * 10)) / 10));
}

Define king attacking piece threat (eval) (warp=true)
{
    If ((Current Board Position[counter for evaluation] + 0) > 0)
    {
        Call get chebyshev distance from square:(counter for evaluation) to square 2:(blackKingID(eval));
        If (distance from square to square == 1)
        {
            If (White Pawn Attacks Square (eval)[counter for evaluation] == 0)
            {
                Call change board eval with mg term:(-12) eg term:(-45);
            }
        }
    }
    Else
    {
        Call get chebyshev distance from square:(counter for evaluation) to square 2:(whiteKingID(eval));
        If (distance from square to square == 1)
        {
            If (Black Pawn Attacks Square (eval)[counter for evaluation] == 0)
            {
                Call change board eval with mg term:(12) eg term:(45);
            }
        }
    }
}

Define king moves with position index:(string pos index) color:(string color) depth:(string depth) add to legal move list?:(string add to legal move list?) is quiet search?:(string is quiet search?) (warp=true)
{
    Call get distance to edge with index:(pos index) //  MOVE GEN;
    counter to find legal king moves = 0;
    Repeat (8)
    {
        counter to find legal king moves += 1;
        If (Distance To Each Edge (movegen)[counter to find legal king moves] > 0)
        {
            new square temp moving pieces = (pos index + direction offsets for sliding pieces[counter to find legal king moves]);
            If ((Current Board Position[new square temp moving pieces] == 0) Or (Current Board Position[new square temp moving pieces] == ""))
            {
                Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(pos index) end square:(new square temp moving pieces) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
            }
            Else
            {
                If (color == "b")
                {
                    If (Current Board Position[new square temp moving pieces] > 0)
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(pos index) end square:(new square temp moving pieces) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    }
                    Else
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(pos index) end square:(new square temp moving pieces) isSlidingPiece?:("") piece moving direction:("") defending capture?(1) pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    }
                }
                Else
                {
                    If (Current Board Position[new square temp moving pieces] < 0)
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(pos index) end square:(new square temp moving pieces) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    }
                    Else
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(pos index) end square:(new square temp moving pieces) isSlidingPiece?:("") piece moving direction:("") defending capture?(1) pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    }
                }
            }
        }
    }
    If ((WD_CastlingRights[depth] > 0) Or ((depth == 0) And (White CASTLING RIGHTS (DEPTH 0) > 0)))
    {
        If (color == "b")
        {
            If (pos index == 5)
            {
                If (WD_CastlingRights[depth] == 11)
                {
                    If ((Current Board Position[6] == "") And ((Current Board Position[7] == "") And (Current Board Position[8] == -500)))
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(00) end square:(90) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:("") add to legal move list?:(add to legal move list?) is quiet search?:(0) debug str:("") enpassant?();
                    }
                    If ((Current Board Position[2] == "") And ((Current Board Position[3] == "") And ((Current Board Position[4] == "") And (Current Board Position[1] == -500))))
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(00) end square:(91) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:("") add to legal move list?:(add to legal move list?) is quiet search?:(0) debug str:("") enpassant?();
                    }
                }
                If (WD_CastlingRights[depth] == 10)
                {
                    If ((Current Board Position[6] == "") And ((Current Board Position[7] == "") And (Current Board Position[8] == -500)))
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(00) end square:(90) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:("") add to legal move list?:(add to legal move list?) is quiet search?:(0) debug str:("") enpassant?();
                    }
                }
                If (WD_CastlingRights[depth] == 01)
                {
                    If ((Current Board Position[2] == "") And ((Current Board Position[3] == "") And ((Current Board Position[4] == "") And (Current Board Position[1] == -500))))
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(00) end square:(91) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:("") add to legal move list?:(add to legal move list?) is quiet search?:(0) debug str:("") enpassant?();
                    }
                }
            }
        }
        Else
        {
            If (pos index == 61)
            {
                If ((WD_CastlingRights[depth] == 11) Or ((depth == 0) And (White CASTLING RIGHTS (DEPTH 0) == 11)))
                {
                    If ((Current Board Position[62] == "") And ((Current Board Position[63] == "") And (Current Board Position[64] == 500)))
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(00) end square:(92) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:("") add to legal move list?:(add to legal move list?) is quiet search?:(0) debug str:("") enpassant?();
                    }
                    If ((Current Board Position[58] == "") And ((Current Board Position[59] == "") And ((Current Board Position[60] == "") And (Current Board Position[57] == 500))))
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(00) end square:(93) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:("") add to legal move list?:(add to legal move list?) is quiet search?:(0) debug str:("") enpassant?();
                    }
                }
                If ((WD_CastlingRights[depth] == 10) Or ((depth == 0) And (White CASTLING RIGHTS (DEPTH 0) == 10)))
                {
                    If ((Current Board Position[62] == "") And ((Current Board Position[63] == "") And (Current Board Position[64] == 500)))
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(00) end square:(92) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:("") add to legal move list?:(add to legal move list?) is quiet search?:(0) debug str:("") enpassant?();
                    }
                }
                If ((WD_CastlingRights[depth] == 01) Or ((depth == 0) And (White CASTLING RIGHTS (DEPTH 0) == 01)))
                {
                    If ((Current Board Position[58] == "") And ((Current Board Position[59] == "") And ((Current Board Position[60] == "") And (Current Board Position[57] == 500))))
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(00) end square:(93) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:("") add to legal move list?:(add to legal move list?) is quiet search?:(0) debug str:("") enpassant?();
                    }
                }
            }
        }
    }
}

Define king on pawnless flank (eval) (warp=true)
{
    Call file has pawns?((BlackKingFile (eval) + -1)) (eval);
    BlackKingPawnlessFlank (eval) += file has pawns res (eval);
    Call file has pawns?((BlackKingFile (eval) + 0)) (eval);
    BlackKingPawnlessFlank (eval) += file has pawns res (eval);
    Call file has pawns?((BlackKingFile (eval) + 1)) (eval);
    BlackKingPawnlessFlank (eval) += file has pawns res (eval);
    If (BlackKingFile (eval) < 4)
    {
        Call file has pawns?(1) (eval);
        BlackKingPawnlessFlank (eval) += file has pawns res (eval);
    }
    Else
    {
        If (BlackKingFile (eval) < 6)
        {
            Call file has pawns?(3) (eval);
            BlackKingPawnlessFlank (eval) += file has pawns res (eval);
            Call file has pawns?(6) (eval);
            BlackKingPawnlessFlank (eval) += file has pawns res (eval);
        }
        Else
        {
            Call file has pawns?(8) (eval);
            BlackKingPawnlessFlank (eval) += file has pawns res (eval);
        }
    }
    If (BlackKingPawnlessFlank (eval) > 0)
    {
        BlackKingPawnlessFlank (eval) = 0;
    }
    Else
    {
        BlackKingPawnlessFlank (eval) = 1;
    }
    Call file has pawns?((WhiteKingFile (eval) + -1)) (eval);
    WhiteKingPawnlessFlank (eval) += file has pawns res (eval);
    Call file has pawns?((WhiteKingFile (eval) + 0)) (eval);
    WhiteKingPawnlessFlank (eval) += file has pawns res (eval);
    Call file has pawns?((WhiteKingFile (eval) + 1)) (eval);
    WhiteKingPawnlessFlank (eval) += file has pawns res (eval);
    If (WhiteKingFile (eval) < 4)
    {
        Call file has pawns?(1) (eval);
        WhiteKingPawnlessFlank (eval) += file has pawns res (eval);
    }
    Else
    {
        If (WhiteKingFile (eval) < 6)
        {
            Call file has pawns?(3) (eval);
            WhiteKingPawnlessFlank (eval) += file has pawns res (eval);
            Call file has pawns?(6) (eval);
            WhiteKingPawnlessFlank (eval) += file has pawns res (eval);
        }
        Else
        {
            Call file has pawns?(8) (eval);
            WhiteKingPawnlessFlank (eval) += file has pawns res (eval);
        }
    }
    If (WhiteKingPawnlessFlank (eval) > 0)
    {
        WhiteKingPawnlessFlank (eval) = 0;
    }
    Else
    {
        WhiteKingPawnlessFlank (eval) = 1;
    }
}

Define knight movement with ID:(string id) color:(string color) depth:(string depth) add to legal move list?:(string add to legal move list?) is quiet search?:(string is quiet search?) (warp=true)
{
    Will Attack King? (movegen) = 0;
    If ((List.Length(SquaresToBeCoveredForCheck) == 0) And (ArePseudoLegalMovesForOpposing? == 1))
    {
        List.Add(SquaresToBeCoveredForCheck, id);
        overwrite "SquaresToBeCovered" list? = 1;
    }
    Else
    {
        overwrite "SquaresToBeCovered" list? = 0;
    }
    If (color == "b")
    {
        counter to find legal moves for knight = 0;
        Repeat (8)
        {
            counter to find legal moves for knight += 1;
            new square temp moving pieces = floor((Knight Movement Table[(((id - 1) * 8) + counter to find legal moves for knight)] % 100));
            If (new square temp moving pieces > 0)
            {
                Call // comment("target square on board");
                If ((Current Board Position[new square temp moving pieces] + 0) > -1)
                {
                    Call // comment("valid move");
                    Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(id) end square:(new square temp moving pieces) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    If ((new square temp moving pieces == index of target king) And (ArePseudoLegalMovesForOpposing? == 1))
                    {
                        Will Attack King? (movegen) = 1;
                    }
                }
                Else
                {
                    Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(id) end square:(new square temp moving pieces) isSlidingPiece?:("") piece moving direction:("") defending capture?(1) pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                }
            }
        }
        If ((Will Attack King? (movegen) == 0) And (overwrite "SquaresToBeCovered" list? == 1))
        {
            List.DeleteAll(SquaresToBeCoveredForCheck);
        }
        Stop(this script);
    }
    If (color == "w")
    {
        counter to find legal moves for knight = 0;
        Repeat (8)
        {
            counter to find legal moves for knight += 1;
            new square temp moving pieces = floor((Knight Movement Table[(((id - 1) * 8) + counter to find legal moves for knight)] % 100));
            If (new square temp moving pieces > 0)
            {
                If ((Current Board Position[new square temp moving pieces] + 0) < 1)
                {
                    Call // comment("valid move");
                    Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(id) end square:(new square temp moving pieces) isSlidingPiece?:("") piece moving direction:("") defending capture?("") pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    If ((new square temp moving pieces == index of target king) And (ArePseudoLegalMovesForOpposing? == 1))
                    {
                        Will Attack King? (movegen) = 1;
                    }
                }
                Else
                {
                    Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(id) end square:(new square temp moving pieces) isSlidingPiece?:("") piece moving direction:("") defending capture?(1) pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                }
            }
        }
        If ((Will Attack King? (movegen) == 0) And (overwrite "SquaresToBeCovered" list? == 1))
        {
            List.DeleteAll(SquaresToBeCoveredForCheck);
        }
        Stop(this script);
    }
}

Define KPK special node code with depth:(string depth) (warp=true)
{
    is KPK draw? (in search) = 0;
    If (NOT PAWN MATERIAL (UPDATED) == 0)
    {
        If (NUM BLACK PAWNS (UPDATED) == 1)
        {
            If (NUM WHITE PAWNS (UPDATED) == 0)
            {
                Call // comment("black has the one pawn");
                Call get rank and file from square index:(List.IndexOf(Current Board Position, -100));
                rank of their pawn (KPK draw detection) = rank from square index;
                file of their pawn (KPK draw detection) = file from square index;
                Call get rank and file from square index:(BLACK KING ID (UPDATED));
                rank of their king (KPK draw detection) = rank from square index;
                file of their king (KPK draw detection) = file from square index;
                Call get rank and file from square index:(WHITE KING ID (UPDATED));
                rank of our king (KPK draw detection) = rank from square index;
                file of our king (KPK draw detection) = file from square index;
                Call check if file:(8) has piece:(-100);
                If (file has target piece res == 1)
                {
                    If (file of their king (KPK draw detection) == 1)
                    {
                        king stuck block square (KPK draw detection) = (BLACK KING ID (UPDATED) - 2);
                        Call get chebyshev distance from square:(king stuck block square (KPK draw detection)) to square 2:(WHITE KING ID (UPDATED));
                        If (distance from square to square < 1)
                        {
                            is KPK draw? (in search) = 1;
                            Stop(this script);
                        }
                        If (distance from square to square == 1)
                        {
                            If ((depth % 2) == 0)
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                    }
                    If ((WHITE KING ID (UPDATED) == 63) Or (WHITE KING ID (UPDATED) == 64))
                    {
                        is KPK draw? (in search) = 1;
                        Stop(this script);
                    }
                    If (rank of our king (KPK draw detection) < rank of their king (KPK draw detection))
                    {
                        If (rank of our king (KPK draw detection) < rank of their pawn (KPK draw detection))
                        {
                            If (abs((file of our king (KPK draw detection) - file of their pawn (KPK draw detection))) < 2)
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                    }
                }
                Call check if file:(1) has piece:(-100);
                If (file has target piece res == 1)
                {
                    If (file of their king (KPK draw detection) == 1)
                    {
                        king stuck block square (KPK draw detection) = (BLACK KING ID (UPDATED) + 2);
                        Call get chebyshev distance from square:(king stuck block square (KPK draw detection)) to square 2:(WHITE KING ID (UPDATED));
                        If (distance from square to square < 1)
                        {
                            is KPK draw? (in search) = 1;
                            Stop(this script);
                        }
                        If (distance from square to square == 1)
                        {
                            If ((depth % 2) == 0)
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                    }
                    If ((WHITE KING ID (UPDATED) == 57) Or (WHITE KING ID (UPDATED) == 58))
                    {
                        is KPK draw? (in search) = 1;
                        Stop(this script);
                    }
                    If (rank of our king (KPK draw detection) < rank of their king (KPK draw detection))
                    {
                        If (rank of our king (KPK draw detection) < rank of their pawn (KPK draw detection))
                        {
                            If (abs((file of our king (KPK draw detection) - file of their pawn (KPK draw detection))) < 2)
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                    }
                }
                If ((BLACK KING ID (UPDATED) + 16) == WHITE KING ID (UPDATED))
                {
                    If ((depth % 2) == 1)
                    {
                        If (BLACK KING ID (UPDATED) < 41)
                        {
                            If (Current Board Position[(BLACK KING ID (UPDATED) - 8)] == -100)
                            {
                                Call get rank and file from square index:((BLACK KING ID (UPDATED) - 8));
                                If ((file of our king (KPK draw detection) > 1) And (file of our king (KPK draw detection) < 8))
                                {
                                    is KPK draw? (in search) = 1;
                                    Stop(this script);
                                }
                            }
                        }
                        If (Current Board Position[(BLACK KING ID (UPDATED) - 1)] == -100)
                        {
                            Call get rank and file from square index:((BLACK KING ID (UPDATED) - 1));
                            If ((file of our king (KPK draw detection) > 1) And (file of our king (KPK draw detection) < 8))
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                        If (Current Board Position[(BLACK KING ID (UPDATED) + 1)] == -100)
                        {
                            Call get rank and file from square index:((BLACK KING ID (UPDATED) + 1));
                            If ((file of our king (KPK draw detection) > 1) And (file of our king (KPK draw detection) < 8))
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                    }
                }
            }
        }
        Call // comment("//");
        If (NUM WHITE PAWNS (UPDATED) == 1)
        {
            If (NUM BLACK PAWNS (UPDATED) == 0)
            {
                Call // comment("white has the one pawn");
                Call get rank and file from square index:(List.IndexOf(Current Board Position, 100));
                rank of their pawn (KPK draw detection) = rank from square index;
                file of their pawn (KPK draw detection) = file from square index;
                Call get rank and file from square index:(WHITE KING ID (UPDATED));
                rank of their king (KPK draw detection) = rank from square index;
                file of their king (KPK draw detection) = file from square index;
                Call get rank and file from square index:(BLACK KING ID (UPDATED));
                rank of our king (KPK draw detection) = rank from square index;
                file of our king (KPK draw detection) = file from square index;
                Call check if file:(8) has piece:(100);
                If (file has target piece res == 1)
                {
                    If (file of their king (KPK draw detection) == 8)
                    {
                        king stuck block square (KPK draw detection) = (WHITE KING ID (UPDATED) - 2);
                        Call get chebyshev distance from square:(king stuck block square (KPK draw detection)) to square 2:(BLACK KING ID (UPDATED));
                        If (distance from square to square < 1)
                        {
                            is KPK draw? (in search) = 1;
                            Stop(this script);
                        }
                        If (distance from square to square == 1)
                        {
                            If ((depth % 2) == 1)
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                    }
                    If ((BLACK KING ID (UPDATED) == 7) Or (BLACK KING ID (UPDATED) == 8))
                    {
                        is KPK draw? (in search) = 1;
                        Stop(this script);
                    }
                    If (rank of our king (KPK draw detection) > rank of their king (KPK draw detection))
                    {
                        If (rank of our king (KPK draw detection) > rank of their pawn (KPK draw detection))
                        {
                            If (abs((file of our king (KPK draw detection) - file of their pawn (KPK draw detection))) < 2)
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                    }
                }
                Call check if file:(1) has piece:(100);
                If (file has target piece res == 1)
                {
                    If (file of their king (KPK draw detection) == 1)
                    {
                        king stuck block square (KPK draw detection) = (WHITE KING ID (UPDATED) + 2);
                        Call get chebyshev distance from square:(king stuck block square (KPK draw detection)) to square 2:(BLACK KING ID (UPDATED));
                        If (distance from square to square < 1)
                        {
                            is KPK draw? (in search) = 1;
                            Stop(this script);
                        }
                        If (distance from square to square == 1)
                        {
                            If ((depth % 2) == 1)
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                    }
                    If ((BLACK KING ID (UPDATED) == 1) Or (BLACK KING ID (UPDATED) == 2))
                    {
                        is KPK draw? (in search) = 1;
                        Stop(this script);
                    }
                    If (rank of our king (KPK draw detection) > rank of their king (KPK draw detection))
                    {
                        If (rank of our king (KPK draw detection) > rank of their pawn (KPK draw detection))
                        {
                            If (abs((file of our king (KPK draw detection) - file of their pawn (KPK draw detection))) < 2)
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                    }
                }
                If ((WHITE KING ID (UPDATED) - 16) == BLACK KING ID (UPDATED))
                {
                    If ((depth % 2) == 0)
                    {
                        If (WHITE KING ID (UPDATED) > 24)
                        {
                            If (Current Board Position[(WHITE KING ID (UPDATED) + 8)] == 100)
                            {
                                Call get rank and file from square index:((WHITE KING ID (UPDATED) + 8));
                                If ((file of our king (KPK draw detection) > 1) And (file of our king (KPK draw detection) < 8))
                                {
                                    is KPK draw? (in search) = 1;
                                    Stop(this script);
                                }
                            }
                        }
                        If (Current Board Position[(WHITE KING ID (UPDATED) + 1)] == 100)
                        {
                            Call get rank and file from square index:((WHITE KING ID (UPDATED) + 1));
                            If ((file of our king (KPK draw detection) > 1) And (file of our king (KPK draw detection) < 8))
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                        If (Current Board Position[(WHITE KING ID (UPDATED) - 1)] == 100)
                        {
                            Call get rank and file from square index:((WHITE KING ID (UPDATED) - 1));
                            If ((file of our king (KPK draw detection) > 1) And (file of our king (KPK draw detection) < 8))
                            {
                                is KPK draw? (in search) = 1;
                                Stop(this script);
                            }
                        }
                    }
                }
            }
        }
    }
}

Define lazy eval with depth:(string depth) (warp=true)
{
    Call reset info for eval function;
    BOARD EVAL = (MATERIAL BALANCE (UPDATED) + ((((depth % 2) - 0.5) * 2) * -15));
}

Define limit book length:(string limit) current line:(string current line) (warp=true)
{
    limited book line = "";
    counter to limit book line length = 0;
    Repeat (limit)
    {
        counter to limit book line length += 1;
        limited book line = Operator.Join(limited book line, Operator.LetterOf(current line, counter to limit book line length));
    }
}

Define load board state (book finder) (warp=true)
{
    List.DeleteAll(Current Board Position);
    Repeat (64)
    {
        List.Add(Current Board Position, saved board state (book finder)[(List.Length(Current Board Position) + 1)]);
    }
}

Define load data for imported FEN (warp=true)
{
    Call createCurrentBoardHash with depth:(((1 * (Who To Move? (WD) == "b")) + 2));
    STARTING POSITION HASH = currentBoardHash;
    GAME STARTING COLOR = Who To Move? (WD);
    full move counter at start (WD) = full move counter (WD);
    LAST NOT REVERSIBLE MOVE = full move counter (WD);
    If (Castling Rights (Load FEN)[1] == "K")
    {
        If (Castling Rights (Load FEN)[2] == "Q")
        {
            White CASTLING RIGHTS (DEPTH 0) = 11;
        }
        Else
        {
            White CASTLING RIGHTS (DEPTH 0) = 10;
        }
    }
    Else
    {
        If (Castling Rights (Load FEN)[2] == "Q")
        {
            White CASTLING RIGHTS (DEPTH 0) = 01;
        }
        Else
        {
            White CASTLING RIGHTS (DEPTH 0) = 00;
        }
    }
    If (Castling Rights (Load FEN)[3] == "k")
    {
        If (Castling Rights (Load FEN)[4] == "q")
        {
            List.ReplaceItem(WD_CastlingRights, 1, 11);
        }
        Else
        {
            List.ReplaceItem(WD_CastlingRights, 1, 10);
        }
    }
    Else
    {
        If (Castling Rights (Load FEN)[4] == "q")
        {
            List.ReplaceItem(WD_CastlingRights, 1, 01);
        }
        Else
        {
            List.ReplaceItem(WD_CastlingRights, 1, 00);
        }
    }
}

Define load FEN:(string FEN) (warp=true)
{
    Call make board's data;
    LOADING FEN = FEN;
    List.DeleteAll(Castling Rights (Load FEN));
    Repeat (4)
    {
        List.Add(Castling Rights (Load FEN), "");
    }
    FEN Stage = 1;
    counter to load FEN = 0;
    counter to load FEN (Board Position ID) = 0;
    en Passant Square (from import) = "";
    en Passant # (from import) = "";
    half move counter = "";
    full move counter (WD) = "";
    Who To Move? (WD) = "";
    Repeat (Variable.Length(FEN))
    {
        counter to load FEN += 1;
        If (Operator.LetterOf(FEN, counter to load FEN) == " ")
        {
            FEN Stage += 1;
        }
        Else
        {
            If (((FEN Stage < 4) And (Not ((FEN Stage == 2)))) And ((Operator.LetterOf(FEN, counter to load FEN) == "r") Or ((Operator.LetterOf(FEN, counter to load FEN) == "n") Or ((Operator.LetterOf(FEN, counter to load FEN) == "b") Or ((Operator.LetterOf(FEN, counter to load FEN) == "q") Or ((Operator.LetterOf(FEN, counter to load FEN) == "k") Or (Operator.LetterOf(FEN, counter to load FEN) == "p")))))))
            {
                If (FEN Stage == 1)
                {
                    counter to load FEN (Board Position ID) += 1;
                    Call is uppercase?(Operator.LetterOf(FEN, counter to load FEN));
                    If (is upper case == 1)
                    {
                        List.ReplaceItem(Current Board Position, counter to load FEN (Board Position ID), Pieces ID[List.IndexOf(Pieces ID FEN/PGN Name, Operator.LetterOf(FEN, counter to load FEN))]);
                    }
                    Else
                    {
                        List.ReplaceItem(Current Board Position, counter to load FEN (Board Position ID), Operator.Join("-", Pieces ID[List.IndexOf(Pieces ID FEN/PGN Name, Operator.LetterOf(FEN, counter to load FEN))]));
                    }
                }
                Else
                {
                    Call is uppercase?(Operator.LetterOf(FEN, counter to load FEN));
                    If (Operator.LetterOf(FEN, counter to load FEN) == "k")
                    {
                        If (is upper case == 1)
                        {
                            List.ReplaceItem(Castling Rights (Load FEN), 1, "K");
                        }
                        Else
                        {
                            List.ReplaceItem(Castling Rights (Load FEN), 3, "k");
                        }
                    }
                    Else
                    {
                        If (is upper case == 1)
                        {
                            List.ReplaceItem(Castling Rights (Load FEN), 2, "Q");
                        }
                        Else
                        {
                            List.ReplaceItem(Castling Rights (Load FEN), 4, "q");
                        }
                    }
                }
            }
            Else
            {
                If (((Operator.LetterOf(FEN, counter to load FEN) == "w") Or (Operator.LetterOf(FEN, counter to load FEN) == "b")) And (FEN Stage == 2))
                {
                    Who To Move? (WD) = Operator.LetterOf(FEN, counter to load FEN);
                }
                Else
                {
                    If (Operator.LetterOf(FEN, counter to load FEN) == "/")
                    {
                        counter to load FEN (Board Position ID) += 0;
                    }
                    Else
                    {
                        If Operator.Contains(supported characters, Operator.LetterOf(FEN, counter to load FEN))
                        {
                            If (en Passant Square (from import) == "")
                            {
                                en Passant Square (from import) = Operator.Join(Operator.LetterOf(FEN, counter to load FEN), Operator.LetterOf(FEN, (counter to load FEN + 1)));
                                en Passant # (from import) = List.IndexOf(A1 - H8 to #, en Passant Square (from import));
                                counter to load FEN += 2;
                            }
                        }
                        Else
                        {
                            If (Operator.LetterOf(FEN, counter to load FEN) == "-")
                            {
                            }
                            Else
                            {
                                If (Not (Operator.Contains(supported characters, Operator.LetterOf(FEN, counter to load FEN))))
                                {
                                    If (FEN Stage == 1)
                                    {
                                        counter to load FEN (Board Position ID) += Operator.LetterOf(FEN, counter to load FEN);
                                    }
                                    Else
                                    {
                                        If (FEN Stage == 5)
                                        {
                                            Repeat Until ((Operator.LetterOf(FEN, (counter to load FEN + 0)) == " ") Or (counter to load FEN > 500))
                                            {
                                                half move counter = Operator.Join(half move counter, Operator.LetterOf(FEN, counter to load FEN));
                                                counter to load FEN += 1;
                                            }
                                            FEN Stage += 1;
                                        }
                                        Else
                                        {
                                            Repeat Until ((counter to load FEN > (Variable.Length(FEN) - 0)) Or (counter to load FEN > 500))
                                            {
                                                full move counter (WD) = Operator.Join(full move counter (WD), Operator.LetterOf(FEN, counter to load FEN));
                                                counter to load FEN += 1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    If (Who To Move? (WD) == "b")
    {
        List.ReplaceItem(WD_EnPassantTarget, 1, en Passant # (from import));
        List.ReplaceItem(WD_EnPassantTarget, 3, en Passant # (from import));
        WHITE MOVE EN PASSANT TARGET = 00;
        List.ReplaceItem(WD_EnPassantTarget, 2, 00);
    }
    Else
    {
        WHITE MOVE EN PASSANT TARGET = en Passant # (from import);
        List.ReplaceItem(WD_EnPassantTarget, 2, en Passant # (from import));
        List.ReplaceItem(WD_EnPassantTarget, 1, 00);
        List.ReplaceItem(WD_EnPassantTarget, 3, 00);
    }
    Call load data for imported FEN;
}

Define log debug data (warp=false)
{
    If (WD_time for search > MaxMoveSearchTime)
    {
        MaxMoveSearchTime = WD_time for search;
    }
    Call add to full game debug with label:(Operator.Join(GAME MOVES[List.Length(GAME MOVES)], Operator.Join(" (", Operator.Join(CPU COLOR, ")"))))("")(-1);
    Call add to full game debug with label:("time for search: ")(WD_time for search)(-1);
    Call add to full game debug with label:("Max Search Time: ")(MaxMoveSearchTime)(1);
    Call add to full game debug with label:("Avg. Best Move Idx: ")((BestMoveIdxSum(Profiler) / BestMoveTotal#(Profiler)))(2);
    Call add to full game debug with label:("Avg. Q-Best Move Idx: ")((BestMoveIdxSum (q) (profiler) / BestMoveTotal# (q) (profiler)))(3);
}

Define log export data (warp=true)
{
    List.ReplaceItem(EXPORT DATA, 4, "");
    PGN File = "";
    counter to make PGN file = 0;
    Repeat (List.Length(GAME MOVES))
    {
        counter to make PGN file += 1;
        current move (for PGN file making) = GAME MOVES[counter to make PGN file];
        If ((counter to make PGN file % 2) == 1)
        {
            If (ceiling((counter to make PGN file / 2)) > 1)
            {
                PGN File = Operator.Join(PGN File, Operator.Join(" ", Operator.Join(ceiling((counter to make PGN file / 2)), ".")));
            }
            Else
            {
                PGN File = Operator.Join(PGN File, Operator.Join(ceiling((counter to make PGN file / 2)), "."));
            }
        }
        If (abs(GAME MOVES (PIECES MOVED)[counter to make PGN file]) > 100)
        {
            current moving piece (for PGN file making) = Pieces ID PGN/FEN Capital[List.IndexOf(Pieces ID, abs(GAME MOVES (PIECES MOVED)[counter to make PGN file]))];
        }
        Else
        {
            current moving piece (for PGN file making) = "";
        }
        If (current move (for PGN file making) > 100)
        {
            PGN File = Operator.Join(PGN File, Operator.Join(" ", Operator.Join(current moving piece (for PGN file making), Operator.Join(A1 - H8 to #[floor((current move (for PGN file making) / 100))], A1 - H8 to #[floor((current move (for PGN file making) % 100))]))));
            If (abs(GAME MOVES (PIECES MOVED)[counter to make PGN file]) == 100)
            {
                If ((floor((current move (for PGN file making) % 100)) < 9) Or (floor((current move (for PGN file making) % 100)) > 56))
                {
                    PGN File = Operator.Join(PGN File, "=Q");
                }
            }
        }
        Else
        {
            If ((current move (for PGN file making) == BlackKingSideCastle) Or (current move (for PGN file making) == WhiteKingSideCastle))
            {
                PGN File = Operator.Join(PGN File, " O-O");
            }
            Else
            {
                PGN File = Operator.Join(PGN File, " O-O-O");
            }
        }
    }
    If (SELF PLAY? == 0)
    {
        If (CPU COLOR == "b")
        {
            Call update export data with new txt:(Operator.Join(Operator.Join("[Black "", WD_UCI register name), ""] "));
            Call update export data with new txt:("[White "Player"]");
        }
        Else
        {
            Call update export data with new txt:("[Black "Player"]");
            Call update export data with new txt:(Operator.Join(Operator.Join("[White "", WD_UCI register name), ""] "));
        }
    }
    Else
    {
        Call update export data with new txt:(Operator.Join(Operator.Join("[Black "", WD_UCI register name), " selfplay"] "));
        Call update export data with new txt:(Operator.Join(Operator.Join("[White "", WD_UCI register name), " selfplay"] "));
    }
    If (Not ((Imported FEN Code: == "")))
    {
        Call update export data with new txt:(Operator.Join(Operator.Join("[FEN "", Imported FEN Code:), ""] "));
    }
    Call update export data with new txt:(PGN File);
}

Define log iterative debug info (warp=true)
{
    List.Add(Iterative Deepening DEBUG, Operator.Join(Operator.Join("Depth: ", Depth of Search), Operator.Join("  //  ID Idx: ", iterative deepening Idx)));
    List.Add(Iterative Deepening DEBUG, Operator.Join(Operator.Join("Beta Bound: ", BETA FOR ASPIRATION WINDOW), Operator.Join(" // Alpha Bound: ", ALPHA FOR ASPIRATION WINDOW)));
    List.Add(Iterative Deepening DEBUG, Operator.Join("Time: ", WD_time for search));
    List.Add(Iterative Deepening DEBUG, Operator.Join(Operator.Join("Best Move: ", WD_best move), Operator.Join("  //  Eval: ", (MinMax Results[search starting depth] / 100))));
    List.Add(Iterative Deepening DEBUG, Operator.Join("PV: ", PV Res At Depth[iterative deepening Idx]));
    List.Add(Iterative Deepening DEBUG, Operator.Join(Operator.Join("Avg. Best Move Idx: ", (Operator.Round(((BestMoveIdxSum(Profiler) / BestMoveTotal#(Profiler)) * 100)) / 100)), Operator.Join("  // (q): ", (Operator.Round(((BestMoveIdxSum (q) (profiler) / BestMoveTotal# (q) (profiler)) * 100)) / 100))));
    List.Add(Iterative Deepening DEBUG, Operator.Join("Num Futility Pruned: ", Operator.Join(num futility pruned, Operator.Join(" (", Operator.Join((Operator.Round(((num futility pruned / 1000) * 100)) / 100), "K)")))));
    List.Add(Iterative Deepening DEBUG, Operator.Join("Normal Nodes: ", Operator.Join(total nodes:, Operator.Join(" (", Operator.Join((Operator.Round(((total nodes: / 1000) * 100)) / 100), "K)")))));
    List.Add(Iterative Deepening DEBUG, Operator.Join("Q-Search Nodes: ", Operator.Join(total q-search nodes:, Operator.Join(" (", Operator.Join((Operator.Round(((total q-search nodes: / 1000) * 100)) / 100), "K)")))));
    List.Add(Iterative Deepening DEBUG, Operator.Join("Moves Generated: ", Operator.Join(Total Moves Generated, Operator.Join(" (", Operator.Join((Operator.Round(((Total Moves Generated / 1000) * 100)) / 100), "K)")))));
    List.Add(Iterative Deepening DEBUG, Operator.Join("MGPS: ", Operator.Join(Operator.Round(Moves Generated Per Second (Search)), Operator.Join(" (", Operator.Join((Operator.Round(((Moves Generated Per Second (Search) / 1000) * 100)) / 100), "K)")))));
    List.Add(Iterative Deepening DEBUG, Operator.Join("Delta Pruned: ", Operator.Join(num delta pruned, Operator.Join(" (", Operator.Join((Operator.Round(((num delta pruned / 1000) * 100)) / 100), "K)")))));
    List.Add(Iterative Deepening DEBUG, Operator.Join("NPS: ", Operator.Join(Operator.Round(NPS (nodes per second)), Operator.Join(" (", Operator.Join((Operator.Round(((NPS (nodes per second) / 1000) * 100)) / 100), "K)")))));
    List.Add(Iterative Deepening DEBUG, Operator.Join("TT Hits: ", # TT Hits));
    List.Add(Iterative Deepening DEBUG, Operator.Join("TT Attempt Writes: ", # TT Attempt Writes));
    List.Add(Iterative Deepening DEBUG, Operator.Join("TT Overwrites: ", # TT Overwrites));
    List.Add(Iterative Deepening DEBUG, Operator.Join("TT Successful Writes: ", # TT Successful Writes));
    List.Add(Iterative Deepening DEBUG, Operator.Join(Operator.Join("NMP pruned: ", num null move pruned), Operator.Join("  //  Tried NMP: ", num tried null move)));
    List.Add(Iterative Deepening DEBUG, "--------------------------------------------------------------------");
}

Define loop for sliding pieces inner with depth:(string depth) add to legal move list?:(string add to legal move list?) is quiet search?(string is quiet search?) caller type:(string caller type) (warp=true)
{
    If (Not ((Distance To Each Edge (movegen)[moves for sliding pieces direction] > 0)))
    {
        Stop(this script);
    }
    If ((List.Length(SquaresToBeCoveredForCheck) == 0) And (ArePseudoLegalMovesForOpposing? == 1))
    {
        List.Add(SquaresToBeCoveredForCheck, start square for moving pieces);
        overwrite "SquaresToBeCovered" list? = 1;
    }
    Else
    {
        overwrite "SquaresToBeCovered" list? = 0;
    }
    countOfBlockingPieces = 0;
    countOfBlockingPiecesToKing = 0;
    Will X-Ray King? (movegen) = 0;
    Will Attack King? (movegen) = 0;
    updatedPinnedPiece? = 0;
    blockingPieceID = "";
    blockingPieceColor = "";
    If (add to legal move list? == 1)
    {
        Call // comment("adding to legal move list means that we're using pseudo-legal move gen here");
        Call // comment("so, we can afford to not do things needed by fully legal move gen (e.g. pin detection, king attacks, etc.)");
        counter to find legal moves for sliding pieces 2 = 0;
        Repeat (Distance To Each Edge (movegen)[moves for sliding pieces direction])
        {
            counter to find legal moves for sliding pieces 2 += 1;
            new square temp moving pieces = (start square for moving pieces + (direction offsets for sliding pieces[moves for sliding pieces direction] * counter to find legal moves for sliding pieces 2));
            If (Current Board Position[new square temp moving pieces] == "")
            {
                Call // comment("empty square");
                Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(0) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
            }
            Else
            {
                Call // comment("square with piece");
                If (color of piece == "b")
                {
                    If (Current Board Position[new square temp moving pieces] > 0)
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(0) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    }
                    Else
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(1) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    }
                }
                Else
                {
                    If (Current Board Position[new square temp moving pieces] < 0)
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(0) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    }
                    Else
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(1) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    }
                }
                Stop(this script);
            }
        }
        Stop(this script);
    }
    Call // comment("fully legal move gen");
    counter to find legal moves for sliding pieces 2 = 0;
    Repeat (Distance To Each Edge (movegen)[moves for sliding pieces direction])
    {
        counter to find legal moves for sliding pieces 2 += 1;
        new square temp moving pieces = (start square for moving pieces + (direction offsets for sliding pieces[moves for sliding pieces direction] * counter to find legal moves for sliding pieces 2));
        If ((overwrite "SquaresToBeCovered" list? == 1) And (Will Attack King? (movegen) == 0))
        {
            List.Add(SquaresToBeCoveredForCheck, new square temp moving pieces);
        }
        If (Current Board Position[new square temp moving pieces] == "")
        {
            If (countOfBlockingPieces == 0)
            {
                Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(0) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
            }
        }
        Else
        {
            If (countOfBlockingPieces == 0)
            {
                If (color of piece == "b")
                {
                    If (Current Board Position[new square temp moving pieces] > 0)
                    {
                        If (Not ((new square temp moving pieces == opKingIndex (For Pseudo-Legal Move Gen))))
                        {
                            Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(0) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                            blockingPieceID = new square temp moving pieces;
                            blockingPieceColor = "w";
                        }
                    }
                    Else
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(1) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                        If ((Will Attack King? (movegen) == 0) And (overwrite "SquaresToBeCovered" list? == 1))
                        {
                            List.DeleteAll(SquaresToBeCoveredForCheck);
                        }
                        If (((Will X-Ray King? (movegen) == 0) Or (countOfBlockingPiecesToKing > 1)) And (updatedPinnedPiece? == 1))
                        {
                            List.ReplaceItem(PiecePinnedDirection, blockingPieceID, "");
                        }
                        Stop(this script);
                    }
                }
                Else
                {
                    If (Current Board Position[new square temp moving pieces] < 0)
                    {
                        If (Not ((new square temp moving pieces == opKingIndex (For Pseudo-Legal Move Gen))))
                        {
                            Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(0) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                            blockingPieceID = new square temp moving pieces;
                            blockingPieceColor = "b";
                        }
                    }
                    Else
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(1) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                        If ((Will Attack King? (movegen) == 0) And (overwrite "SquaresToBeCovered" list? == 1))
                        {
                            List.DeleteAll(SquaresToBeCoveredForCheck);
                        }
                        If (((Will X-Ray King? (movegen) == 0) Or (countOfBlockingPiecesToKing > 1)) And (updatedPinnedPiece? == 1))
                        {
                            List.ReplaceItem(PiecePinnedDirection, blockingPieceID, "");
                        }
                        Stop(this script);
                    }
                }
            }
            If (Not ((new square temp moving pieces == opKingIndex (For Pseudo-Legal Move Gen))))
            {
                countOfBlockingPieces += 1;
                If (Will X-Ray King? (movegen) == 0)
                {
                    countOfBlockingPiecesToKing += 1;
                    If ((countOfBlockingPiecesToKing > 1) And (Will Attack King? (movegen) == 0))
                    {
                        If (overwrite "SquaresToBeCovered" list? == 1)
                        {
                            List.DeleteAll(SquaresToBeCoveredForCheck);
                        }
                        If (updatedPinnedPiece? == 1)
                        {
                            List.ReplaceItem(PiecePinnedDirection, blockingPieceID, "");
                        }
                        Stop(this script);
                    }
                }
                If (ArePseudoLegalMovesForOpposing? == 1)
                {
                    If ((countOfBlockingPiecesToKing == 1) And ((Not ((color of piece == blockingPieceColor))) And (PiecePinnedDirection[blockingPieceID] == "")))
                    {
                        updatedPinnedPiece? = 1;
                        List.ReplaceItem(PiecePinnedDirection, blockingPieceID, moves for sliding pieces direction);
                    }
                }
            }
            If (new square temp moving pieces == opKingIndex (For Pseudo-Legal Move Gen))
            {
                Will X-Ray King? (movegen) = 1;
                If (countOfBlockingPieces == 0)
                {
                    Will Attack King? (movegen) = 1;
                    Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(start square for moving pieces) end square:(new square temp moving pieces) isSlidingPiece?:(1) piece moving direction:(moves for sliding pieces direction) defending capture?(0) pawn push?(0) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                }
            }
        }
    }
    If ((Will Attack King? (movegen) == 0) And (overwrite "SquaresToBeCovered" list? == 1))
    {
        List.DeleteAll(SquaresToBeCoveredForCheck);
    }
    If (((Will X-Ray King? (movegen) == 0) Or (countOfBlockingPiecesToKing > 1)) And (updatedPinnedPiece? == 1))
    {
        List.ReplaceItem(PiecePinnedDirection, blockingPieceID, "");
    }
}

Define make board (warp=true)
{
    List.DeleteAll(Square Color);
    board rank = 0;
    board file = 0;
    board piece ID = 0;
    Motion.GoToXY((-140 + BOARD X OFFSET), 180);
    Looks.SetEffectTo(BRIGHTNESS, 0);
    Repeat (8)
    {
        board rank = 0;
        board file += 1;
        Motion.SetX((-140 + BOARD X OFFSET));
        Motion.ChangeYBy(-40);
        Repeat (8)
        {
            board piece ID += 1;
            board rank += 1;
            If (((board file + board rank) % 2) == 0)
            {
                Looks.SwitchCostumeTo(White1);
                List.Add(Square Color, "light");
            }
            Else
            {
                Looks.SwitchCostumeTo(Green1);
                List.Add(Square Color, "dark");
            }
            If (WD_DELTA_CI MODE ACTIVE? == 0)
            {
                Control.CreateCloneOf(_myself_);
            }
            Motion.ChangeXBy(40);
        }
    }
    board piece ID = 0;
}

Define make board's data (warp=true)
{
    List.DeleteAll(Current Board Position);
    List.DeleteAll(Depth 0 (save for others));
    List.DeleteAll(A1 - H8 to #);
    Repeat (64)
    {
        List.Add(Current Board Position, "");
        List.Add(Depth 0 (save for others), "");
        List.Add(A1 - H8 to #, Operator.Join(Operator.LetterOf("abcdefgh", ((List.Length(A1 - H8 to #) % 8) + 1)), (8 - floor(((List.Length(A1 - H8 to #) / 64) * 8)))));
    }
}

Define make book finder book (warp=true)
{
    List.DeleteAll(book finder current book);
    book finder maker idx = 0;
    Repeat (List.Length(Neutral Opening Book))
    {
        book finder maker idx += 1;
        List.Add(book finder current book, Neutral Opening Book[book finder maker idx]);
    }
    If (CPU COLOR == "b")
    {
        book finder maker idx = 0;
        Repeat (List.Length(Better for Black Opening Book))
        {
            book finder maker idx += 1;
            List.Add(book finder current book, Better for Black Opening Book[book finder maker idx]);
        }
    }
    Else
    {
        book finder maker idx = 0;
        Repeat (List.Length(Better for White Opening Book))
        {
            book finder maker idx += 1;
            List.Add(book finder current book, Better for White Opening Book[book finder maker idx]);
        }
    }
}

Define make fen from position (board) (warp=true)
{
    FEN FROM CURRENT BOARD POS = "";
    counter to make FEN outer = 0;
    counter to make FEN = 0;
    Repeat (65)
    {
        counter to make FEN outer += 1;
        If (((counter to make FEN outer % 8) == 1) And (counter to make FEN outer > 1))
        {
            If (counter to make FEN > 0)
            {
                FEN FROM CURRENT BOARD POS = Operator.Join(FEN FROM CURRENT BOARD POS, counter to make FEN);
            }
            If (counter to make FEN outer < 65)
            {
                FEN FROM CURRENT BOARD POS = Operator.Join(FEN FROM CURRENT BOARD POS, "/");
                counter to make FEN = 0;
            }
        }
        If (Current Board Position[counter to make FEN outer] == "")
        {
            counter to make FEN += 1;
        }
        Else
        {
            If (counter to make FEN == 0)
            {
                FEN FROM CURRENT BOARD POS = Operator.Join(FEN FROM CURRENT BOARD POS, Pieces ID to UCI Name[(List.IndexOf(Pieces ID to UCI Name, Current Board Position[counter to make FEN outer]) + 12)]);
            }
            Else
            {
                FEN FROM CURRENT BOARD POS = Operator.Join(FEN FROM CURRENT BOARD POS, Operator.Join(counter to make FEN, Pieces ID to UCI Name[(List.IndexOf(Pieces ID to UCI Name, Current Board Position[counter to make FEN outer]) + 12)]));
            }
            counter to make FEN = 0;
        }
    }
}

Define minmax depth:(string depth) max depth:(string max depth) rounds of quiet search?(string rounds of quiet search) numExtensions:(string numExtensions) num SE:(string num SE) (warp=true)
{
    Call // comment("set the PV length to 0 (i.e. no PV yet), because we might end this prematurely (before a "best move" is found)");
    List.ReplaceItem(BoardAttackedBySideToMoveSnapshot, depth, "none");
    List.ReplaceItem(BoardAttackedBySideToMovePieceSnapshot, depth, "none");
    List.ReplaceItem(BoardAttackedBySideToMovePieceSnapshot 2, depth, "none");
    List.ReplaceItem(Large Positional in Static Eval at Depth, depth, 0);
    List.ReplaceItem(PV_length, depth, 0);
    List.ReplaceItem(Real Search Depth For Move, depth, -1);
    List.ReplaceItem(Search Node State:, depth, "start");
    List.ReplaceItem(MaxEval, depth, "-Infinity");
    List.ReplaceItem(MinEval, depth, "Infinity");
    If ((depth % 2) == 1)
    {
        List.ReplaceItem(MinMax Results, depth, "Infinity");
        List.ReplaceItem(OP KING ID AT DEPTH, depth, WHITE KING ID (UPDATED));
    }
    Else
    {
        List.ReplaceItem(MinMax Results, depth, "-Infinity");
        List.ReplaceItem(OP KING ID AT DEPTH, depth, BLACK KING ID (UPDATED));
    }
    List.ReplaceItem(Best Move, depth, "???");
    List.ReplaceItem(Moves Played In Search, depth, "");
    List.ReplaceItem(Moves Index, depth, 0);
    List.ReplaceItem(STATIC EVAL AT DEPTH, depth, "");
    List.ReplaceItem(Apply Num Extensions At Depth, depth, "");
    List.ReplaceItem(Is Futility Pruned?, depth, 0);
    List.ReplaceItem(Board Hash At Depth, depth, "");
    List.ReplaceItem(TTread Node Type at Depth, depth, "");
    List.ReplaceItem(TTread Score at Depth, depth, "");
    If (depth == search starting depth)
    {
        List.ReplaceItem(Fully Legal Move Gen?, depth, 1);
    }
    Else
    {
        List.ReplaceItem(Fully Legal Move Gen?, depth, "no move gen");
    }
    Call // comment("if king captured, an illegal move must have been made");
    If (targetPieces[(depth - 1)] == 99999)
    {
        List.ReplaceItem(MinMax Results, depth, (-9999999 + depth));
        List.ReplaceItem(Search Node State:, depth, "depth - 1 took white king");
        Stop(this script);
    }
    If (targetPieces[(depth - 1)] == -99999)
    {
        List.ReplaceItem(MinMax Results, depth, (9999999 - depth));
        List.ReplaceItem(Search Node State:, depth, "depth - 1 took black king");
        Stop(this script);
    }
    Call // comment("mate distance pruning");
    If (depth > search starting depth)
    {
        If ((depth % 2) == 1)
        {
            If (Alphas[depth] > (-9999999 + depth))
            {
                List.ReplaceItem(Alphas, depth, Alphas[depth]);
            }
            Else
            {
                List.ReplaceItem(Alphas, depth, (-9999999 + depth));
            }
            If (Betas[depth] < (9999999 - (depth + 1)))
            {
                List.ReplaceItem(Betas, depth, Betas[depth]);
            }
            Else
            {
                List.ReplaceItem(Betas, depth, (9999999 - (depth + 1)));
            }
            If (Not ((Alphas[depth] < Betas[depth])))
            {
                List.ReplaceItem(MinMax Results, depth, Alphas[depth]);
                Stop(this script);
            }
        }
        Else
        {
            If (Alphas[depth] > (-9999999 + depth))
            {
                List.ReplaceItem(Alphas, depth, Alphas[depth]);
            }
            Else
            {
                List.ReplaceItem(Alphas, depth, (-9999999 + depth));
            }
            If (Betas[depth] < (9999999 - (depth + 1)))
            {
                List.ReplaceItem(Betas, depth, Betas[depth]);
            }
            Else
            {
                List.ReplaceItem(Betas, depth, (9999999 - (depth + 1)));
            }
            If (Not ((Alphas[depth] < Betas[depth])))
            {
                List.ReplaceItem(MinMax Results, depth, Alphas[depth]);
                Stop(this script);
            }
        }
    }
    Call verify insufficient material draw (search) depth:(depth);
    If (insufficient material draw res (search) == 1)
    {
        Call fast pseudo-legal move gen with depth:(depth)((1 == 1))((0 == 1))();
        If (opponent king hanging res (move gen) == 1)
        {
            If ((depth % 2) == 1)
            {
                List.ReplaceItem(MinMax Results, depth, (-9999999 + depth));
            }
            Else
            {
                List.ReplaceItem(MinMax Results, depth, (9999999 - depth));
            }
            List.ReplaceItem(Search Node State:, depth, "illegal king move d-1 exit");
            insufficient material draw res (search) = 0;
            Stop(this script);
        }
        Else
        {
            List.ReplaceItem(MinMax Results, depth, CPU CONTEMPT VALUE);
            List.ReplaceItem(Search Node State:, depth, "insufficient mat. draw exit");
            Stop(this script);
        }
    }
    List.ReplaceItem(Hash Move, depth, "????");
    List.ReplaceItem(ScoreTypes, depth, "E");
    If ((depth % 2) == 1)
    {
        List.ReplaceItem(ScoreTypes, depth, "B");
    }
    Else
    {
        List.ReplaceItem(ScoreTypes, depth, "A");
    }
    If (depth < (search starting depth + 1))
    {
        Call createCurrentBoardHash with depth:(depth);
        List.ReplaceItem(Board Hash At Depth, depth, currentBoardHash);
    }
    Else
    {
        List.ReplaceItem(Board Hash At Depth, depth, Next Ply Board Hash[(depth - 1)]);
    }
    If ((((((depth % 2) == 1) And (NUM BLACK PAWNS (UPDATED) == 0)) Or (((depth % 2) == 0) And (NUM WHITE PAWNS (UPDATED) == 0))) Or (depth < (search starting depth + 2))) And (depth > search starting depth))
    {
        Call // comment("if very shallow depth, do full move gen to see if position is stalemate / checkmate before reading TT");
        Call get all legal moves from current position depth:(depth) is quiet search?:(0) completely legal?(1) generate checks?("");
        List.ReplaceItem(Fully Legal Move Gen?, depth, 1);
        If (opponent king hanging res (move gen) == 1)
        {
            If ((depth % 2) == 1)
            {
                List.ReplaceItem(MinMax Results, depth, (-9999999 + depth));
            }
            Else
            {
                List.ReplaceItem(MinMax Results, depth, (9999999 - depth));
            }
            List.ReplaceItem(Search Node State:, depth, "illegal king move d-1 exit");
            Stop(this script);
        }
        If (GameState: == 3)
        {
            List.ReplaceItem(MinMax Results, depth, CPU CONTEMPT VALUE);
            List.ReplaceItem(Search Node State:, depth, "stalemate verification exit");
            Stop(this script);
        }
        If (GameState: == 2)
        {
            If ((depth % 2) == 1)
            {
                List.ReplaceItem(MinMax Results, depth, (9999999 - depth));
                List.ReplaceItem(Search Node State:, depth, "white checkmate exit");
            }
            Else
            {
                List.ReplaceItem(MinMax Results, depth, (-9999999 + depth));
                List.ReplaceItem(Search Node State:, depth, "black checkmate exit");
            }
            Stop(this script);
        }
        Call move ordering with depth:(depth) search this move first:("") include checks in ordering?(0);
    }
    eval is draw (repetition) = 0;
    Call repetition detection (in search) with depth:(depth);
    If (eval is draw (repetition) == 1)
    {
        List.ReplaceItem(MinMax Results, depth, CPU CONTEMPT VALUE);
        List.ReplaceItem(Search Node State:, depth, "repetition exit");
        Stop(this script);
    }
    Call // comment("probe position from transposition table");
    TTentryUsed? = 0;
    List.ReplaceItem(TTentryUsed?, depth, "N/A");
    List.ReplaceItem(TTentryUsed (line), depth, "N/A");
    Call TTprobeNode with board hash:(Board Hash At Depth[depth]) depth:(depth);
    If (TTprobeRes (WD) == 1)
    {
        Call // comment("if there is an entry for this position, set the hash move for this depth to be used later");
        List.ReplaceItem(Hash Move, depth, TTprobeBestMoveRes);
        List.ReplaceItem(TTread Node Type at Depth, depth, TTprobeNodeType);
        List.ReplaceItem(TTread Score at Depth, depth, TTprobeNodeScoreRes);
        List.ReplaceItem(TTread Horizon at Depth, depth, TTprobeHorizonRes);
        List.ReplaceItem(BoardAttackedBySideToMoveSnapshot, depth, TTprobeNodeBoardAttacked);
        List.ReplaceItem(BoardAttackedBySideToMovePieceSnapshot, depth, TTprobeNodeBoardAttackedSource1);
        List.ReplaceItem(BoardAttackedBySideToMovePieceSnapshot 2, depth, TTprobeNodeBoardAttackedSource2);
    }
    If (depth > search starting depth)
    {
        If ((TTprobeRes (WD) == 1) And (Not ((TTprobeHorizonRes < (max depth - depth)))))
        {
            If ((TTprobeNodeType == "E") Or (((TTprobeNodeType == "A") And (Not ((TTprobeNodeScoreRes > Alphas[depth])))) Or ((TTprobeNodeType == "B") And (Not ((TTprobeNodeScoreRes < Betas[depth]))))))
            {
                If ((Not ((depth < (search starting depth + 3)))) Or (abs(TTprobeNodeScoreRes) < 9990000))
                {
                    Call // comment("if the score is a mate, do not allow entries from too early as it could fall into a stalemate trap due to incorrect TT value");
                    If (abs(TTprobeNodeScoreRes) > 9990000)
                    {
                        If (TTprobeNodeScoreRes > 0)
                        {
                            List.ReplaceItem(MinMax Results, depth, (TTprobeNodeScoreRes - (depth * 1)));
                        }
                        Else
                        {
                            List.ReplaceItem(MinMax Results, depth, (TTprobeNodeScoreRes + (depth * 1)));
                        }
                    }
                    Else
                    {
                        List.ReplaceItem(MinMax Results, depth, TTprobeNodeScoreRes);
                    }
                    TTentryUsed? = 1;
                    List.ReplaceItem(TTentryUsed?, depth, Operator.Join(Operator.Join(Operator.Join(Operator.Join(Operator.Join(Operator.Join(Operator.Join(TTprobeNodeType, Operator.Join(" TT hrz: ", TTprobeHorizonRes)), " hrz: "), (max depth - depth)), " dpt: "), depth), " TT dpt & max: "), Operator.Join(Operator.Join(TTprobeNodeDepth, Operator.Join(" | ", TTprobeNodeMaxDepth (WD))), Operator.Join(Operator.Join(" TT ID idx: ", TTprobeNodeIDidx (WD)), Operator.Join(" TT age: ", TTprobeNodeAgeRes)))));
                    List.ReplaceItem(TTentryUsed (line), depth, TTprobeNodeLine (WD));
                    List.ReplaceItem(Search Node State:, depth, "hash entry used exit");
                    Stop(this script);
                }
            }
        }
    }
    If (depth > search starting depth)
    {
        Call KPK special node code with depth:(depth);
        If (is KPK draw? (in search) == 1)
        {
            Call fast pseudo-legal move gen with depth:(depth)((1 == 1))((0 == 1))();
            If (opponent king hanging res (move gen) == 1)
            {
                If ((depth % 2) == 1)
                {
                    List.ReplaceItem(MinMax Results, depth, (-9999999 + depth));
                }
                Else
                {
                    List.ReplaceItem(MinMax Results, depth, (9999999 - depth));
                }
                List.ReplaceItem(Search Node State:, depth, "illegal king move d-1 exit");
                is KPK draw? (in search) = 0;
                Stop(this script);
            }
            Else
            {
                List.ReplaceItem(MinMax Results, depth, CPU CONTEMPT VALUE);
                List.ReplaceItem(Search Node State:, depth, "is KP vs K draw exit");
                Stop(this script);
            }
        }
    }
    If ((depth == max depth) Or (depth > (List.Length(Moves Index) - 5)))
    {
        Call // comment("if at max depth, or a the maximum depth supported by engine, go into q-search / evaluation (not used anymore)");
        List.ReplaceItem(Search Node State:, depth, "max depth reached exit");
        If (rounds of quiet search == "all")
        {
            Call quiet search with depth:(depth) max depth:(29) q-search started depth:(depth) (q-search / quiescence search);
        }
        Else
        {
            If (rounds of quiet search > 0)
            {
                Call quiet search with depth:(depth) max depth:((depth + rounds of quiet search)) q-search started depth:(depth) (q-search / quiescence search);
            }
            Else
            {
                Call evaluation of current position with depth:(depth) force HCE:("") log debug:();
                List.ReplaceItem(MinMax Results, depth, BOARD EVAL);
            }
        }
        Stop(this script);
    }
    If (PutsInCheck?[(depth - 1)] == 1)
    {
        List.ReplaceItem(StartsInCheck?, depth, 1);
    }
    Call // comment("the first depth's moves are generated and sorted at the root, so no need to do it again here");
    If ((depth > search starting depth) And (Fully Legal Move Gen?[depth] == "no move gen"))
    {
        Call // comment("Lower depths will use fully legal move gen for easy stalemate / checkmate detection, but deeper depths will use pseudo-legal move gen for speed");
        Call // comment("(the exception being pawn endgames, as stalemate can often play a crucial role in determining game outcome)");
        If ((depth < (search starting depth + 2)) Or ((StartsInCheck?[depth] == 1) Or (NOT PAWN MATERIAL (UPDATED) == 0)))
        {
            Call get all legal moves from current position depth:(depth) is quiet search?:(0) completely legal?(1) generate checks?("");
            List.ReplaceItem(Fully Legal Move Gen?, depth, 1);
        }
        Else
        {
            Call fast pseudo-legal move gen with depth:(depth)((1 == 0))((1 == 0))((BoardAttackedBySideToMoveSnapshot[depth] == "none"));
            List.ReplaceItem(Fully Legal Move Gen?, depth, 0);
        }
        If (opponent king hanging res (move gen) == 1)
        {
            If ((depth % 2) == 1)
            {
                List.ReplaceItem(MinMax Results, depth, (-9999999 + depth));
            }
            Else
            {
                List.ReplaceItem(MinMax Results, depth, (9999999 - depth));
            }
            List.ReplaceItem(Search Node State:, depth, "illegal king move d-1 exit (after move gen)");
            Stop(this script);
        }
        Call move ordering with depth:(depth) search this move first:("") include checks in ordering?(0);
    }
    List.ReplaceItem(StartsInCheck?, depth, startsInCheck? (var));
    If (Not ((depth < search starting depth)))
    {
        List.ReplaceItem(WD_EnPassantTarget, (depth + 1), "null move");
    }
    Call // comment("null move pruning");
    If ((((depth > search starting depth) And (GameState: == 1)) And (Not ((Moves Played In Search[(depth - 1)] == "null move")))) And (Not ((StartsInCheck?[depth] == 1))))
    {
        If ((Moves Count[depth] > 1) And (Not ((NOT PAWN MATERIAL (UPDATED) < 2500))))
        {
            If (max depth > 6)
            {
                If ((max depth - depth) > 6)
                {
                    R (null move reduction) = 3;
                }
                Else
                {
                    R (null move reduction) = 2;
                }
                If ((max depth - depth) > R (null move reduction))
                {
                    num tried null move += 1;
                    List.ReplaceItem(targetPieces, depth, "");
                    List.ReplaceItem(WD_CastlingRights, (depth + 2), WD_CastlingRights[depth]);
                    List.ReplaceItem(Moves Played In Search, depth, "null move");
                    If ((depth % 2) == 1)
                    {
                        List.ReplaceItem(Next Ply Board Hash, depth, (Board Hash At Depth[depth] - WD_side key (hash table)));
                        List.ReplaceItem(Alphas, (depth + 1), Alphas[depth]);
                        List.ReplaceItem(Betas, (depth + 1), (Alphas[depth] + 1));
                        Call minmax depth:((depth + 1)) max depth:((max depth - R (null move reduction))) rounds of quiet search?(rounds of quiet search) numExtensions:(numExtensions) num SE:(num SE);
                        GameState: = 1;
                        If (Not ((MinMax Results[(depth + 1)] > Alphas[depth])))
                        {
                            num null move pruned += 1;
                            List.ReplaceItem(MinMax Results, depth, MinMax Results[(depth + 1)]);
                            List.ReplaceItem(Search Node State:, depth, "NMP black exit");
                            Stop(this script);
                        }
                    }
                    Else
                    {
                        List.ReplaceItem(Next Ply Board Hash, depth, (Board Hash At Depth[depth] + WD_side key (hash table)));
                        List.ReplaceItem(Alphas, (depth + 1), (Betas[depth] - 1));
                        List.ReplaceItem(Betas, (depth + 1), Betas[depth]);
                        Call minmax depth:((depth + 1)) max depth:((max depth - R (null move reduction))) rounds of quiet search?(rounds of quiet search) numExtensions:(numExtensions) num SE:(num SE);
                        GameState: = 1;
                        If (Not ((MinMax Results[(depth + 1)] < Betas[depth])))
                        {
                            num null move pruned += 1;
                            List.ReplaceItem(MinMax Results, depth, MinMax Results[(depth + 1)]);
                            List.ReplaceItem(Search Node State:, depth, "NMP white exit");
                            Stop(this script);
                        }
                    }
                }
            }
        }
    }
    Call // comment("futility pruning (can be disabled by changing the statement below to be "if 0 = 1")");
    If (1 == 1)
    {
        If (depth > (search starting depth + 4))
        {
            If (depth < max depth)
            {
                If ((max depth - depth) < (List.Length(FUTILITY PRUNING MARGIN) + 1))
                {
                    If (StartsInCheck?[depth] == 0)
                    {
                        If (Moves Count[depth] > 0)
                        {
                            If ((depth % 2) == 1)
                            {
                                If (Betas[depth] > -990000)
                                {
                                    Call evaluation of current position with depth:(depth) force HCE:("") log debug:();
                                    If (BlackKingisAttacked (eval) == 0)
                                    {
                                        If (Not (((BOARD EVAL - FUTILITY PRUNING MARGIN[(max depth - depth)]) < Betas[depth])))
                                        {
                                            List.ReplaceItem(Is Futility Pruned?, depth, 1);
                                        }
                                    }
                                }
                            }
                            Else
                            {
                                If (Alphas[depth] < 990000)
                                {
                                    Call evaluation of current position with depth:(depth) force HCE:("") log debug:();
                                    If (WhiteKingIsAttacked (eval) == 0)
                                    {
                                        If (Not (((BOARD EVAL + FUTILITY PRUNING MARGIN[(max depth - depth)]) > Alphas[depth])))
                                        {
                                            List.ReplaceItem(Is Futility Pruned?, depth, 1);
                                        }
                                    }
                                }
                            }
                            If ((eval used HCE res == 1) And ((abs(Black King Attacked Val) + abs(White King Attacked Val)) > 400))
                            {
                                List.ReplaceItem(Large Positional in Static Eval at Depth, depth, 1);
                            }
                        }
                    }
                }
            }
        }
    }
    Call // comment("if at max depth, or checkmate / stalemate, figure out what's happened (mostly just used for checkmate / stalemate now)");
    If ((depth == max depth) Or ((Moves Count[depth] == 0) Or (depth > (List.Length(Moves Index) - 5))))
    {
        If (Moves Count[depth] == 0)
        {
            Call // comment("Terminal Game State (game has ended)");
            If (GameState: == 2)
            {
                Call // comment("Checkmate");
                If ((depth % 2) == 1)
                {
                    BOARD EVAL = (9999999 - depth);
                }
                Else
                {
                    BOARD EVAL = (-9999999 + depth);
                }
            }
            Else
            {
                Call // comment("Draw");
                If ((depth % 2) == 1)
                {
                    BOARD EVAL = BLACK CONTEMPT VALUE;
                }
                Else
                {
                    BOARD EVAL = WHITE CONTEMPT VALUE;
                }
            }
            List.ReplaceItem(MinMax Results, depth, BOARD EVAL);
        }
        Else
        {
            Call // comment("game is still going, must be a max depth condition then");
            If (rounds of quiet search == "all")
            {
                Call quiet search with depth:(depth) max depth:(29) q-search started depth:(depth) (q-search / quiescence search);
            }
            Else
            {
                If (rounds of quiet search > 0)
                {
                    Call quiet search with depth:(depth) max depth:((depth + rounds of quiet search)) q-search started depth:(depth) (q-search / quiescence search);
                }
                Else
                {
                    Call evaluation of current position with depth:(depth) force HCE:("") log debug:();
                    List.ReplaceItem(MinMax Results, depth, BOARD EVAL);
                }
            }
        }
        evaluated positions (WD) += 1;
        List.ReplaceItem(Search Node State:, depth, "non-search qualified exit");
    }
    Else
    {
        List.ReplaceItem(PV_length, depth, depth);
        Call // comment("if we are entering the search/move loop, a min. of one best move is guaranteed, so we can safely know there is a PV continuation");
        Repeat (Moves Count[depth])
        {
            Call // comment("loop over all of the moves in the move list (the general info is reset at the top of this function)");
            List.ReplaceItem(Moves Index, depth, (Moves Index[depth] + 1));
            List.ReplaceItem(Real Moves Index at Depth, depth, Moves Index[depth]);
            List.ReplaceItem(Exclude Move at Depth, depth, "none");
            Call get current applying move with depth:(depth);
            SE extension res = 0;
            If ((((depth > search starting depth) And ((((max depth - depth) > 3) And (num SE < 1)) And ((Moves Count[depth] > 1) And (depth < (iterative deepening Idx * 2))))) And ((Hash Move[depth] == current move (computer)) And (((((depth % 2) == 1) And (TTread Node Type at Depth[depth] == "A")) Or (((depth % 2) == 0) And (TTread Node Type at Depth[depth] == "B"))) Or (TTread Node Type at Depth[depth] == "E")))) And (TTread Horizon at Depth[depth] > ((max depth - depth) - 3)))
            {
                Call // comment("Singular Extensions (SE)");
                List.ReplaceItem(Exclude Move at Depth, depth, current move (computer));
                List.ReplaceItem(Moves Index Temp, depth, 0);
                List.ReplaceItem(Minmax Res Temp, depth, "none");
                If ((depth % 2) == 1)
                {
                    List.ReplaceItem(Best Score Temp, depth, "Infinity");
                }
                Else
                {
                    List.ReplaceItem(Best Score Temp, depth, "-Infinity");
                }
                Call after makemove minmax temp with depth:(depth)(floor((max depth - (((max depth - depth) + 1) / 2))))(rounds of quiet search)(numExtensions)((num SE + 1));
                List.ReplaceItem(Exclude Move at Depth, depth, "none");
                If ((depth % 2) == 1)
                {
                    If (Minmax Res Temp[depth] > (TTread Score at Depth[depth] + 100))
                    {
                        SE extension res = 1;
                    }
                }
                Else
                {
                    If (Minmax Res Temp[depth] < (TTread Score at Depth[depth] - 100))
                    {
                        SE extension res = 1;
                    }
                }
            }
            List.ReplaceItem(Moves Index, depth, Real Moves Index at Depth[depth]);
            Call apply move with depth:(depth) manual override:("") full search:((1 == 1));
            List.ReplaceItem(Alphas, (depth + 1), Alphas[depth]);
            List.ReplaceItem(Betas, (depth + 1), Betas[depth]);
            Call should futility prune move at depth(depth);
            If (should futility prune? == 0)
            {
                Call get chebyshev distance from square:(OP KING ID AT DEPTH[depth]) to square 2:(end square for applying moves);
                Call search extensions with depth:(depth) num extensions:(numExtensions);
                List.ReplaceItem(Apply Num Extensions At Depth, depth, searchExtension);
                Call // comment("late move reductions (LMR)");
                If ((Moves Index[depth] == 1) Or ((Apply Num Extensions At Depth[depth] > 0) Or ((max depth - depth) < 3)))
                {
                    Call // comment("No LMR");
                    Call minmax depth:((depth + 1)) max depth:((max depth + Apply Num Extensions At Depth[depth])) rounds of quiet search?(rounds of quiet search) numExtensions:((numExtensions + Apply Num Extensions At Depth[depth])) num SE:(num SE);
                    List.ReplaceItem(Real Search Depth For Move, depth, (max depth + Apply Num Extensions At Depth[depth]));
                }
                Else
                {
                    Call special no LMR conditions with depth:(depth) move type:(move type (for applying moves));
                    If ((Moves Index[depth] > 3) And ((Not ((StartsInCheck?[depth] == 1))) And ((Not ((distance from square to square < 3))) And ((PutsInCheck?[depth] == 0) And (specialNoLmrCond Res == 0)))))
                    {
                        Call // comment("OK to reduce for LMR");
                        Call get LMR reduction with depth:(depth) move num:(Moves Index[depth]) move type:(move type (for applying moves)) max depth:(max depth);
                        Call minmax depth:((depth + 1)) max depth:(((max depth + Apply Num Extensions At Depth[depth]) - LMRreductionsNumRes)) rounds of quiet search?(rounds of quiet search) numExtensions:((numExtensions + Apply Num Extensions At Depth[depth])) num SE:(num SE);
                        List.ReplaceItem(Real Search Depth For Move, depth, ((max depth + Apply Num Extensions At Depth[depth]) - LMRreductionsNumRes));
                    }
                    Else
                    {
                        If ((depth % 2) == 1)
                        {
                            List.ReplaceItem(MinMax Results, (depth + 1), (Betas[depth] - 1));
                        }
                        Else
                        {
                            List.ReplaceItem(MinMax Results, (depth + 1), (Alphas[depth] + 1));
                        }
                    }
                    Call // comment("do a re-search if the move is the new best move, we have to re-update the alpha and beta values of the next ply");
                    Call // comment("because they could have been changed in the previous LMR search");
                    List.ReplaceItem(Alphas, (depth + 1), Alphas[depth]);
                    List.ReplaceItem(Betas, (depth + 1), Betas[depth]);
                    If ((depth % 2) == 1)
                    {
                        If (MinMax Results[(depth + 1)] < Betas[depth])
                        {
                            Call minmax depth:((depth + 1)) max depth:((max depth + Apply Num Extensions At Depth[depth])) rounds of quiet search?(rounds of quiet search) numExtensions:((numExtensions + Apply Num Extensions At Depth[depth])) num SE:(num SE);
                            List.ReplaceItem(Real Search Depth For Move, depth, (max depth + Apply Num Extensions At Depth[depth]));
                        }
                    }
                    Else
                    {
                        If (MinMax Results[(depth + 1)] > Alphas[depth])
                        {
                            Call minmax depth:((depth + 1)) max depth:((max depth + Apply Num Extensions At Depth[depth])) rounds of quiet search?(rounds of quiet search) numExtensions:((numExtensions + Apply Num Extensions At Depth[depth])) num SE:(num SE);
                            List.ReplaceItem(Real Search Depth For Move, depth, (max depth + Apply Num Extensions At Depth[depth]));
                        }
                    }
                }
                Eval/Score = MinMax Results[(depth + 1)];
                Call revert moves with depth:(depth) manual override:("");
                If (depth < search starting depth)
                {
                    Stop(this script);
                }
                Call minmax time exhausted?;
                If (minmax time exhausted? == 1)
                {
                    Call // comment("if the time is up, we must stop this script before it starts affecting other search data");
                    Call // comment("this is because it is very very likely that we did not completely search this move, resulting in a bad score");
                    Stop(this script);
                }
                If ((depth % 2) == 1)
                {
                    If (Eval/Score < MinEval[depth])
                    {
                        List.ReplaceItem(Best Move, depth, current reverting move);
                        List.ReplaceItem(BestMoveIndex, depth, Moves Index[depth]);
                        List.ReplaceItem(MinEval, depth, Eval/Score);
                        List.ReplaceItem(MinMax Results, depth, Eval/Score);
                        If ((depth == 1) And (CPU COLOR == "b"))
                        {
                            WD_best move = MovesDepth 1[Moves Index[depth]];
                            EST EVAL (WD) = Eval/Score;
                            List.Add(BEST MOVES (LOG), WD_best move);
                            List.Add(BEST MOVES EVAL (LOG), MinEval[depth]);
                        }
                        Call pv_table add best move:(current reverting move) depth:(depth);
                    }
                    If (Eval/Score < Betas[depth])
                    {
                        List.ReplaceItem(Betas, depth, Eval/Score);
                        List.ReplaceItem(ScoreTypes, depth, "E");
                    }
                    If ((Betas[depth] < Alphas[depth]) Or (Betas[depth] == Alphas[depth]))
                    {
                        Call // comment("cutoff");
                        If (Current Board Position[end square for reverting moves] == "")
                        {
                            Call store killer move with depth:(depth) move:(current reverting move);
                        }
                        Call TTstoreNode with board hash:(Board Hash At Depth[depth]) depth:(depth) score:(MinMax Results[depth]) horizon:((max depth - depth)) best move:(Best Move[depth]) node type:("A") max depth:(max depth) q-search start depth:(-1) board atk:(BoardAttackedBySideToMoveSnapshot[depth]) atk source:(BoardAttackedBySideToMovePieceSnapshot[depth]) atk source 2:(BoardAttackedBySideToMovePieceSnapshot 2[depth]);
                        branches pruned (normal search) += 1;
                        BestMoveTotal#(Profiler) += 1;
                        BestMoveIdxSum(Profiler) += BestMoveIndex[depth];
                        List.ReplaceItem(Search Node State:, depth, "cutoff black exit");
                        Stop(this script);
                    }
                }
                Else
                {
                    If (Eval/Score > MaxEval[depth])
                    {
                        List.ReplaceItem(Best Move, depth, current reverting move);
                        List.ReplaceItem(BestMoveIndex, depth, Moves Index[depth]);
                        List.ReplaceItem(MaxEval, depth, Eval/Score);
                        List.ReplaceItem(MinMax Results, depth, Eval/Score);
                        If (depth == 2)
                        {
                            bestMoveDepth2temp = MovesDepth 2[Moves Index[2]];
                        }
                        If ((depth == 2) And (CPU COLOR == "w"))
                        {
                            WHITE CPU BEST MOVE = MovesDepth 2[Moves Index[depth]];
                            WD_best move = WHITE CPU BEST MOVE;
                        }
                        Call pv_table add best move:(current reverting move) depth:(depth);
                    }
                    If (Eval/Score > Alphas[depth])
                    {
                        List.ReplaceItem(Alphas, depth, Eval/Score);
                        List.ReplaceItem(ScoreTypes, depth, "E");
                    }
                    If ((Betas[depth] < Alphas[depth]) Or (Betas[depth] == Alphas[depth]))
                    {
                        Call // comment("cutoff");
                        If (Current Board Position[end square for reverting moves] == "")
                        {
                            Call store killer move with depth:(depth) move:(current reverting move);
                        }
                        Call TTstoreNode with board hash:(Board Hash At Depth[depth]) depth:(depth) score:(MinMax Results[depth]) horizon:((max depth - depth)) best move:(Best Move[depth]) node type:("B") max depth:(max depth) q-search start depth:(-1) board atk:(BoardAttackedBySideToMoveSnapshot[depth]) atk source:(BoardAttackedBySideToMovePieceSnapshot[depth]) atk source 2:(BoardAttackedBySideToMovePieceSnapshot 2[depth]);
                        branches pruned (normal search) += 1;
                        BestMoveTotal#(Profiler) += 1;
                        BestMoveIdxSum(Profiler) += BestMoveIndex[depth];
                        List.ReplaceItem(Search Node State:, depth, "cutoff white exit");
                        Stop(this script);
                    }
                }
                Call minmax time exhausted?;
                If (minmax time exhausted? == 1)
                {
                    Stop(this script);
                }
            }
            Else
            {
                Call // comment("if futility pruned, revert the applied move, log the debug data, and stop the search if necessary");
                Call // comment("(normally, "continue" would be used, however, Scratch/TW does not have this keyword/condition)");
                Call revert moves with depth:(depth) manual override:("");
                num futility pruned += 1;
                Call minmax time exhausted?;
                If (minmax time exhausted? == 1)
                {
                    Stop(this script);
                }
            }
        }
        BestMoveTotal#(Profiler) += 1;
        BestMoveIdxSum(Profiler) += BestMoveIndex[depth];
        Call TTstoreNode with board hash:(Board Hash At Depth[depth]) depth:(depth) score:(MinMax Results[depth]) horizon:((max depth - depth)) best move:(Best Move[depth]) node type:(ScoreTypes[depth]) max depth:(max depth) q-search start depth:(-1) board atk:(BoardAttackedBySideToMoveSnapshot[depth]) atk source:(BoardAttackedBySideToMovePieceSnapshot[depth]) atk source 2:(BoardAttackedBySideToMovePieceSnapshot 2[depth]);
        List.ReplaceItem(Search Node State:, depth, "full exit");
    }
    Call get all legal moves from current position depth:(depth) is quiet search?:(0) completely legal?(0) generate checks?("");
    movegen tester var = List.Length(ALL LEGAL MOVES FOR CPU CALCS);
    If (Not ((List.Length(ALL LEGAL MOVES FOR CPU CALCS) == movegen tester var)))
    {
        Call ​​warn​​("movegen error in q-search");
        Call ​​log​​(q-search depth);
        Call ​​log​​(Moves Played In Search);
        Call ​​log​​(movegen tester var);
        Call ​​log​​(List.Length(ALL LEGAL MOVES FOR CPU CALCS));
        Call ​​log​​(gen checks in q-search res);
    }
}

Define minmax time exhausted? (warp=true)
{
    If (minmax time exhausted? == 1)
    {
        Stop(this script);
    }
    If (((Sensing.DaysSince2000() - start time for search) * 86400) > REAL MAX THINK TIME)
    {
        Call // comment("fail-safe to end search if ongoing for too long");
        minmax time exhausted? = 1;
        Stop(this script);
    }
    If (((Sensing.DaysSince2000() - start time for search) * 86400) > TARGET THINK TIME)
    {
        If (ALREADY INCREASED THINK TIME? == 0)
        {
            If (TIME CONTROL MODE? == 0)
            {
                If is compiled?
                {
                    WD_min_search_depth = 6;
                }
                Else
                {
                    WD_min_search_depth = 3;
                }
            }
            Else
            {
                If is compiled?
                {
                    WD_min_search_depth = Performance Mode Depth[Performance Mode:];
                }
                Else
                {
                    WD_min_search_depth = S3 Performance Depth[Performance Mode:];
                }
            }
            If (iterative deepening Idx < (WD_min_search_depth + 1))
            {
                ALREADY INCREASED THINK TIME? = 1;
                TARGET THINK TIME = ((TARGET THINK TIME * 1.6) + 4);
                Stop(this script);
            }
            If (Moves Index[search starting depth] > 1)
            {
                If (CPU COLOR == "w")
                {
                    If ((MinMax Results[search starting depth] - (last sure best move eval (ID) * 100)) < -75)
                    {
                        If ((last sure best move eval (ID) * 100) > -600)
                        {
                            ALREADY INCREASED THINK TIME? = 1;
                            TARGET THINK TIME += (Performance Mode Think Time[Performance Mode:] * 1);
                            Stop(this script);
                        }
                    }
                    If ((abs((last sure best move eval (ID) * 100)) < 70) And (MinMax Results[search starting depth] < -70))
                    {
                        ALREADY INCREASED THINK TIME? = 1;
                        TARGET THINK TIME += (Performance Mode Think Time[Performance Mode:] * 0.6);
                        Stop(this script);
                    }
                }
                Else
                {
                    If ((MinMax Results[search starting depth] - (last sure best move eval (ID) * 100)) > 75)
                    {
                        If ((last sure best move eval (ID) * 100) < 600)
                        {
                            ALREADY INCREASED THINK TIME? = 1;
                            TARGET THINK TIME += (Performance Mode Think Time[Performance Mode:] * 1);
                            Stop(this script);
                        }
                    }
                    If ((abs((last sure best move eval (ID) * 100)) < 70) And (MinMax Results[search starting depth] > 70))
                    {
                        ALREADY INCREASED THINK TIME? = 1;
                        TARGET THINK TIME += (Performance Mode Think Time[Performance Mode:] * 0.6);
                        Stop(this script);
                    }
                }
            }
            If ((Not ((ITERATIVE IDX BEST MOVE IN POS[(iterative deepening Idx - 1)] == ITERATIVE IDX BEST MOVE IN POS[(iterative deepening Idx - 2)]))) Or ((Not ((WD_best move == ITERATIVE IDX BEST MOVE IN POS[(iterative deepening Idx - 1)]))) And (Moves Index[search starting depth] > 1)))
            {
                Call // comment("last few iterations best move not the same");
                ALREADY INCREASED THINK TIME? = 1;
                TARGET THINK TIME = (TARGET THINK TIME * 1.55);
                Stop(this script);
            }
            If (SCORE OUTSIDE ASPIRATION WINDOW == 1)
            {
                Call // comment("increase think time if aspiration window failed");
                ALREADY INCREASED THINK TIME? = 1;
                TARGET THINK TIME = (TARGET THINK TIME * 1.45);
                Stop(this script);
            }
        }
        minmax time exhausted? = 1;
        If (Moves Index[search starting depth] == 1)
        {
            first move not fully searched? (ID) = 1;
        }
    }
}

Define mop-up EVAL // perspective is white?(bool perspective is white) (warp=true)
{
    Used Mop-Up Eval? (evaluation) = 1;
    If perspective is white
    {
        idx of king (mop-up eval) = whiteKingID(eval);
        idx of other king (mop-up eval) = blackKingID(eval);
    }
    Else
    {
        idx of king (mop-up eval) = blackKingID(eval);
        idx of other king (mop-up eval) = whiteKingID(eval);
    }
    opKingDistFromCenter = Distance To Center[idx of other king (mop-up eval)];
    kingEndGameEval = (opKingDistFromCenter * 5);
    dstBetweenKings = Manhattan Distance To Square[((64 * (idx of king (mop-up eval) - 1)) + idx of other king (mop-up eval))];
    kingEndGameEval += ((14 - dstBetweenKings) * 2);
    If (Not (perspective is white))
    {
        kingEndGameEval = (0 - kingEndGameEval);
    }
    kingEndGameEval = (kingEndGameEval * 10);
    BOARD EVAL += kingEndGameEval;
}

Define move ordering if pawn fork with captures offsets:(string cap. offset1)(string cap. offset2)(string multiplier) (warp=true)
{
    If (((multiplier * Current Board Position[(end square for move ordering temp + cap. offset1)]) < -100) And ((multiplier * Current Board Position[(end square for move ordering temp + cap. offset2)]) < -100))
    {
        Call get rank and file from square index:(end square for move ordering temp);
        If ((file from square index > 1) And (file from square index < 8))
        {
            Call // comment("pawn fork");
            move ordering score (var) += 10000;
        }
    }
}

Define move ordering with depth:(string depth) search this move first:(string first search move) include checks in ordering?(string include checks?) (warp=true)
{
    Call PrepareCurrentKillerMoves with depth:(depth);
    List.DeleteAll(Moves Score Guess);
    counter to order moves = 0;
    Repeat (List.Length(ALL LEGAL MOVES FOR CPU CALCS))
    {
        counter to order moves += 1;
        List.Add(Moves Score Guess, "");
        Call get move score (for ordering) with index:(counter to order moves) with depth:(depth) first search move:(first search move) special check in move ordering?(include checks?);
        List.ReplaceItem(Moves Score Guess, counter to order moves, (0 - move ordering score (var)));
    }
    List.DeleteAll(Moves for Ordering (Temp For Sorting));
    Repeat (List.Length(Moves Score Guess))
    {
        List.Add(Moves for Ordering (Temp For Sorting), ALL LEGAL MOVES FOR CPU CALCS[(List.Length(Moves for Ordering (Temp For Sorting)) + 1)]);
    }
    Call quicksort for move ordering;
    Call delete depth:(depth) for move storage | clear move count?((1 == 2));
    counter to order moves = 0;
    Repeat (List.Length(Moves for Ordering (Temp For Sorting)))
    {
        counter to order moves += 1;
        Call add move:(Moves for Ordering (Temp For Sorting)[counter to order moves]) with depth:(depth) to real move lists;
    }
}

Define NNUE activation value:(string value) (warp=true)
{
    Call // comment("leaky relu with slope 0.01");
    If (value > 0)
    {
        activation value res = value;
    }
    Else
    {
        activation value res = (value * 0.01);
    }
}

Define NNUE activation value derivative with value:(string value) (warp=true)
{
    Call // comment("derivative for leaky relu with slope 0.01");
    If (value > 0)
    {
        WD_NNUE_activation_derivative = 1;
    }
    Else
    {
        WD_NNUE_activation_derivative = 0.01;
    }
}

Define NN update accumulator with board idx(string board idx) piece(string piece) addition?(bool add) runtime usage?(string is runtime) (warp=true)
{
    Call // comment("loop over all accumulator nodes from the "perspective" of the input");
    Call // comment(""normal" weights are referenced from the n+1 layer to the n layer, but the accumulator weights are special");
    Call // comment("this is to make the indexing easier");
    WD_NNUE_acc_update_side = 0;
    Repeat (2)
    {
        Call // comment("loop over both sides (white and black)");
        If (WD_NNUE_acc_update_side == 0)
        {
            Call get NN activation index with piece:(piece) square:(board idx) color perspective:("w");
        }
        Else
        {
            Call get NN activation index with piece:(piece) square:(board idx) color perspective:("b");
        }
        counter for NN activate = 1;
        WD_NNUE_acc_update_weightIdx = ((WD_NNUE_Hidden_Size * (NN activate true input idx - 1)) + counter for NN activate);
        WD_NNUE_acc_update_idx = (counter for NN activate + (WD_NNUE_acc_update_side * WD_NNUE_Hidden_Size));
        If add
        {
            Repeat ((WD_NNUE_Hidden_Size / 8))
            {
                Call WD_NNUE_Accumulator_Add8 // acc idx:(WD_NNUE_acc_update_idx) weight idx:(WD_NNUE_acc_update_weightIdx);
                counter for NN activate += 8;
                WD_NNUE_acc_update_weightIdx += 8;
                WD_NNUE_acc_update_idx += 8;
            }
        }
        Else
        {
            Repeat ((WD_NNUE_Hidden_Size / 8))
            {
                Call WD_NNUE_Accumulator_Sub8 // acc idx:(WD_NNUE_acc_update_idx) weight idx:(WD_NNUE_acc_update_weightIdx);
                counter for NN activate += 8;
                WD_NNUE_acc_update_weightIdx += 8;
                WD_NNUE_acc_update_idx += 8;
            }
        }
        WD_NNUE_acc_update_side += 1;
    }
}

Define passed block (SF idea) (eval) (warp=true)
{
    passed block defended (eval) = 0;
    passed block attacked (eval) = 0;
    passed block w attacked (eval) = 0;
    passed block defended block (eval) = 0;
    passed block attacked block (eval) = 0;
    If (isPawnPassed (for eval)? == 0)
    {
        Stop(this script);
    }
    If (current piece (eval) == 100)
    {
        Call passed blocker inner with perspective:(rank from square index)(rank from square index)(file from square index)((counter for evaluation - 8))(blackKingID(eval))(whiteKingID(eval))(1)((1 == 1));
    }
    Else
    {
        Call passed blocker inner with perspective:(rank from square index)((9 - rank from square index))(file from square index)((counter for evaluation + 8))(whiteKingID(eval))(blackKingID(eval))(-1)((0 == 1));
    }
    If ((passed block attacked (eval) == 0) And (passed block w attacked (eval) == 0))
    {
        passed block temp val (eval) = 35;
    }
    Else
    {
        If (passed block attacked (eval) == 0)
        {
            passed block temp val (eval) = 20;
        }
        Else
        {
            If (passed block attacked block (eval) == 0)
            {
                passed block temp val (eval) = 9;
            }
            Else
            {
                passed block temp val (eval) = 0;
            }
        }
    }
    passed block temp val (eval) += (5 * (passed block defended block (eval) > 0));
    BOARD EVAL += (0.5 * (passed block temp val (eval) * passed block weight (eval)));
}

Define passed blocker inner with perspective:(string rank)(string rel rank)(string file)(string block square)(string their king id)(string our king id)(string multiplier for flip)(bool white?) (warp=true)
{
    Call // comment("written from white perspective");
    If (rel rank < 4)
    {
        Stop(this script);
    }
    If (abs(Current Board Position[block square]) > 0)
    {
        Stop(this script);
    }
    passed block weight (eval) = (multiplier for flip * ((5 * (rel rank - 1)) - 13));
    passed block rank (eval) = rank;
    Repeat (6)
    {
        passed block rank (eval) += (1 * multiplier for flip);
        If ((passed block rank (eval) > 0) And (passed block rank (eval) < 9))
        {
            Call get square idx with rank:(passed block rank (eval)) file:(file);
            Call does king id:(our king id) attack square:(square idx from rank and file res) (eval);
            Call get num their attacks on square(square idx from rank and file res)(white?) (eval);
            If ((num our attacks on square res (eval) > 0) Or (king id attacks square res (eval) == 1))
            {
                passed block defended (eval) += 1;
            }
            Call get square idx with rank:(passed block rank (eval)) file:(file);
            Call get num their attacks on square(square idx from rank and file res)(white?) (eval);
            If ((num their attacks on square res (eval) > 0) Or (king id attacks square res (eval) == 1))
            {
                passed block attacked (eval) += 1;
            }
            Call get square idx with rank:(passed block rank (eval)) file:((file - 1));
            Call get num their attacks on square(square idx from rank and file res)(white?) (eval);
            If ((num their attacks on square res (eval) > 0) Or (king id attacks square res (eval) == 1))
            {
                passed block w attacked (eval) += 1;
            }
            Call get square idx with rank:(passed block rank (eval)) file:((file + 1));
            Call does king id:(their king id) attack square:(square idx from rank and file res) (eval);
            If ((num their attacks on square res (eval) > 0) Or (king id attacks square res (eval) == 1))
            {
                passed block w attacked (eval) += 1;
            }
            If (passed block rank (eval) == (rank + (1 * multiplier for flip)))
            {
                passed block attacked block (eval) = passed block attacked (eval);
                passed block defended block (eval) = passed block defended (eval);
            }
        }
    }
    passed block rank (eval) = rank from square index;
    Repeat ((rel rank - 1))
    {
        passed block rank (eval) += (-1 * multiplier for flip);
        Call get square idx with rank:(passed block rank (eval)) file:(file);
        If ((Current Board Position[square idx from rank and file res] == (500 * multiplier for flip)) Or (Current Board Position[square idx from rank and file res] == (900 * multiplier for flip)))
        {
            passed block defended (eval) = 1;
            passed block defended block (eval) = 1;
        }
        If ((Current Board Position[square idx from rank and file res] == (-500 * multiplier for flip)) Or (Current Board Position[square idx from rank and file res] == (-900 * multiplier for flip)))
        {
            passed block attacked (eval) = 1;
            passed block attacked block (eval) = 1;
        }
    }
}

Define pawn capture verification(string multiplier)(string square offset)(string depth) (warp=true)
{
    movegen endsquare = (movegen outer idx + square offset);
    Call fast movegen add attack on square:(movegen outer idx)(movegen endsquare);
    If ((((Current Board Position[movegen endsquare] + 0) * multiplier) < 0) Or (movegen endsquare == movegen enpassant target))
    {
        Call add move(movegen outer idx)(movegen endsquare) movegen(depth);
    }
}

Define pawn movement with position index:(string position index) piece color:(string piece color) depth:(string depth) add to legal move list?:(string add to legal move list?) is quiet search?:(string is quiet search?) (warp=true)
{
    If ((List.Length(SquaresToBeCoveredForCheck) == 0) And (ArePseudoLegalMovesForOpposing? == 1))
    {
        List.Add(SquaresToBeCoveredForCheck, position index);
        overwrite "SquaresToBeCovered" list? = 1;
    }
    Else
    {
        overwrite "SquaresToBeCovered" list? = 0;
    }
    Will Attack King? (movegen) = 0;
    Call get rank and file from square index:(position index);
    If (depth == 0)
    {
        pawn movement used enpassant = WHITE MOVE EN PASSANT TARGET;
    }
    Else
    {
        pawn movement used enpassant = WD_EnPassantTarget[depth];
    }
    pawn can push 1? (pawn move gen) = 0;
    counter to find legal moves for pawns = 0;
    If (piece color == "b")
    {
        Repeat (4)
        {
            counter to find legal moves for pawns += 1;
            current move (pawn move gen) = (Black Pawn Movement Table[(((position index - 1) * 4) + (counter to find legal moves for pawns + 0))] + 0);
            current move target (pawn move gen) = floor((current move (pawn move gen) % 100));
            If (current move (pawn move gen) > 0)
            {
                Call // comment("valid move");
                If (counter to find legal moves for pawns < 3)
                {
                    If (((Not ((Current Board Position[current move target (pawn move gen)] == ""))) Or (current move target (pawn move gen) == pawn movement used enpassant)) And ((ArePseudoLegalMovesForOpposing? == 0) Or (depth > 0)))
                    {
                        Call // comment("capture / enpassant");
                        If ((Current Board Position[current move target (pawn move gen)] > 0) Or (current move target (pawn move gen) == pawn movement used enpassant))
                        {
                            Call // comment("valid capture");
                            Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(position index) end square:(current move target (pawn move gen)) isSlidingPiece?:(2) piece moving direction:(Old Black Pawn Direction -> New[counter to find legal moves for pawns]) defending capture?("") pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?((current move target (pawn move gen) == pawn movement used enpassant));
                            If (current move target (pawn move gen) == index of target king)
                            {
                                Will Attack King? (movegen) = 1;
                            }
                        }
                        Else
                        {
                            Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(position index) end square:(current move target (pawn move gen)) isSlidingPiece?:(2) piece moving direction:(Old Black Pawn Direction -> New[counter to find legal moves for pawns]) defending capture?(1) pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                        }
                    }
                    Else
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(position index) end square:(current move target (pawn move gen)) isSlidingPiece?:(2) piece moving direction:(Old Black Pawn Direction -> New[counter to find legal moves for pawns]) defending capture?(1) pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    }
                }
                Else
                {
                    Call // comment("push");
                    If (counter to find legal moves for pawns == 3)
                    {
                        If (Current Board Position[current move target (pawn move gen)] == "")
                        {
                            Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(position index) end square:(current move target (pawn move gen)) isSlidingPiece?:(2) piece moving direction:(Old Black Pawn Direction -> New[counter to find legal moves for pawns]) defending capture?("") pawn push?(1) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                            pawn can push 1? (pawn move gen) = 1;
                        }
                    }
                    Else
                    {
                        If (pawn can push 1? (pawn move gen) == 1)
                        {
                            If (Current Board Position[current move target (pawn move gen)] == "")
                            {
                                Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(position index) end square:(current move target (pawn move gen)) isSlidingPiece?:(2) piece moving direction:(Old Black Pawn Direction -> New[counter to find legal moves for pawns]) defending capture?("") pawn push?(1) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                            }
                        }
                    }
                }
            }
        }
        If ((Will Attack King? (movegen) == 0) And (overwrite "SquaresToBeCovered" list? == 1))
        {
            List.DeleteAll(SquaresToBeCoveredForCheck);
        }
        Stop(this script);
    }
    If (piece color == "w")
    {
        Repeat (4)
        {
            counter to find legal moves for pawns += 1;
            current move (pawn move gen) = (White Pawn Movement Table[(((position index - 1) * 4) + (counter to find legal moves for pawns + 0))] + 0);
            current move target (pawn move gen) = floor((current move (pawn move gen) % 100));
            If (current move (pawn move gen) > 0)
            {
                Call // comment("valid move");
                If (counter to find legal moves for pawns < 3)
                {
                    If (((Not ((Current Board Position[current move target (pawn move gen)] == ""))) Or (current move target (pawn move gen) == pawn movement used enpassant)) And ((ArePseudoLegalMovesForOpposing? == 0) Or (depth > 0)))
                    {
                        Call // comment("capture / enpassant");
                        If ((Current Board Position[current move target (pawn move gen)] < 0) Or (current move target (pawn move gen) == pawn movement used enpassant))
                        {
                            Call // comment("valid capture or enpassant");
                            Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(position index) end square:(current move target (pawn move gen)) isSlidingPiece?:(2) piece moving direction:(Old White Pawn Direction -> New[counter to find legal moves for pawns]) defending capture?("") pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?((current move target (pawn move gen) == pawn movement used enpassant));
                            If (current move target (pawn move gen) == index of target king)
                            {
                                Will Attack King? (movegen) = 1;
                            }
                        }
                        Else
                        {
                            Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(position index) end square:(current move target (pawn move gen)) isSlidingPiece?:(2) piece moving direction:(Old White Pawn Direction -> New[counter to find legal moves for pawns]) defending capture?(1) pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                        }
                    }
                    Else
                    {
                        Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(position index) end square:(current move target (pawn move gen)) isSlidingPiece?:(2) piece moving direction:(Old White Pawn Direction -> New[counter to find legal moves for pawns]) defending capture?(1) pawn push?("") depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                    }
                }
                Else
                {
                    Call // comment("push");
                    If (counter to find legal moves for pawns == 3)
                    {
                        If ((Current Board Position[current move target (pawn move gen)] + 0) == 0)
                        {
                            Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(position index) end square:(current move target (pawn move gen)) isSlidingPiece?:(2) piece moving direction:(Old White Pawn Direction -> New[counter to find legal moves for pawns]) defending capture?("") pawn push?(1) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                            pawn can push 1? (pawn move gen) = 1;
                        }
                    }
                    Else
                    {
                        If (pawn can push 1? (pawn move gen) == 1)
                        {
                            If ((Current Board Position[current move target (pawn move gen)] + 0) == 0)
                            {
                                Call add move to pseudo-legal move list:(ArePseudoLegalMovesForOpposing?) start square:(position index) end square:(current move target (pawn move gen)) isSlidingPiece?:(2) piece moving direction:(Old White Pawn Direction -> New[counter to find legal moves for pawns]) defending capture?("") pawn push?(1) depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?:(is quiet search?) debug str:("") enpassant?();
                            }
                        }
                    }
                }
            }
        }
        If ((Will Attack King? (movegen) == 0) And (overwrite "SquaresToBeCovered" list? == 1))
        {
            List.DeleteAll(SquaresToBeCoveredForCheck);
        }
        Stop(this script);
    }
}

Define pawn push threat (eval) (warp=true)
{
    If (current piece (eval) == 100)
    {
        Call // comment("white pawn");
        If (((White Pawn Attacks Square (eval)[(counter for evaluation - 8)] + num white attacks on square (eval)[(counter for evaluation - 8)]) > 0) Or (num black attacks on square (eval)[(counter for evaluation - 8)] == 0))
        {
            If (Black Pawn Attacks Square (eval)[(counter for evaluation - 8)] == 0)
            {
                If (abs(Current Board Position[(counter for evaluation - 8)]) == 0)
                {
                    If (file from square index < 8)
                    {
                        If ((Current Board Position[(counter for evaluation - 15)] + 0) < -100)
                        {
                            Call change board eval with mg term:(25) eg term:(20);
                        }
                    }
                    If (file from square index > 1)
                    {
                        If ((Current Board Position[(counter for evaluation - 17)] + 0) < -100)
                        {
                            Call change board eval with mg term:(25) eg term:(20);
                            Stop(this script);
                        }
                    }
                }
            }
        }
        If (rank from square index == 2)
        {
            If (((White Pawn Attacks Square (eval)[(counter for evaluation - 16)] + num white attacks on square (eval)[(counter for evaluation - 16)]) > 0) Or (num black attacks on square (eval)[(counter for evaluation - 16)] == 0))
            {
                If (Black Pawn Attacks Square (eval)[(counter for evaluation - 16)] == 0)
                {
                    If (abs(Current Board Position[(counter for evaluation - 8)]) == 0)
                    {
                        If (abs(Current Board Position[(counter for evaluation - 16)]) == 0)
                        {
                            If (file from square index < 8)
                            {
                                If ((Current Board Position[(counter for evaluation - 23)] + 0) < -100)
                                {
                                    Call change board eval with mg term:(25) eg term:(20);
                                }
                            }
                            If (file from square index > 1)
                            {
                                If ((Current Board Position[(counter for evaluation - 25)] + 0) < -100)
                                {
                                    Call change board eval with mg term:(25) eg term:(20);
                                }
                            }
                            Stop(this script);
                        }
                    }
                }
            }
        }
    }
    If (current piece (eval) == -100)
    {
        Call // comment("black pawn");
        If (((Black Pawn Attacks Square (eval)[(counter for evaluation + 8)] + num black attacks on square (eval)[(counter for evaluation + 8)]) > 0) Or (num white attacks on square (eval)[(counter for evaluation + 8)] == 0))
        {
            If (White Pawn Attacks Square (eval)[(counter for evaluation + 8)] == 0)
            {
                If (abs(Current Board Position[(counter for evaluation + 8)]) == 0)
                {
                    If (file from square index > 1)
                    {
                        If ((Current Board Position[(counter for evaluation + 15)] + 0) > 100)
                        {
                            Call change board eval with mg term:(-25) eg term:(-20);
                        }
                    }
                    If (file from square index < 8)
                    {
                        If ((Current Board Position[(counter for evaluation + 17)] + 0) > 100)
                        {
                            Call change board eval with mg term:(-25) eg term:(-20);
                            Stop(this script);
                        }
                    }
                }
            }
        }
        If (rank from square index == 7)
        {
            If (((Black Pawn Attacks Square (eval)[(counter for evaluation + 16)] + num black attacks on square (eval)[(counter for evaluation + 8)]) > 0) Or (num white attacks on square (eval)[(counter for evaluation + 16)] == 0))
            {
                If (White Pawn Attacks Square (eval)[(counter for evaluation + 16)] == 0)
                {
                    If (abs(Current Board Position[(counter for evaluation + 8)]) == 0)
                    {
                        If (abs(Current Board Position[(counter for evaluation + 16)]) == 0)
                        {
                            If (file from square index > 1)
                            {
                                If ((Current Board Position[(counter for evaluation + 23)] + 0) > 100)
                                {
                                    Call change board eval with mg term:(-25) eg term:(-20);
                                }
                            }
                            If (file from square index < 8)
                            {
                                If ((Current Board Position[(counter for evaluation + 25)] + 0) > 100)
                                {
                                    Call change board eval with mg term:(-25) eg term:(-20);
                                    Stop(this script);
                                }
                            }
                            Stop(this script);
                        }
                    }
                }
            }
        }
    }
}

Define piece attacked by pawn (eval) (warp=true)
{
    If (current piece (eval) > 0)
    {
        If (Black Pawn Attacks Square (eval)[counter for evaluation] > 0)
        {
            Call change board eval with mg term:(-90) eg term:(-50);
        }
    }
    Else
    {
        If (White Pawn Attacks Square (eval)[counter for evaluation] > 0)
        {
            Call change board eval with mg term:(90) eg term:(50);
        }
    }
}

Define piece combo bonus/penalty (for eval) (warp=true)
{
    If (NUM BLACK BISHOPS (EVAL) == 2)
    {
        BOARD EVAL += -45;
    }
    If (NUM WHITE BISHOPS (EVAL) == 2)
    {
        BOARD EVAL += 45;
    }
    If (NUM WHITE PAWNS (EVAL) == 0)
    {
        BOARD EVAL += -35;
    }
    If (NUM BLACK PAWNS (EVAL) == 0)
    {
        BOARD EVAL += 35;
    }
}

Define piece square tables with index:(string index) piece type:(string piece type) endgame?:(string endgame) (warp=true)
{
    PST_read_res = "";
    If (Not ((piece type == "")))
    {
        If (piece type < 0)
        {
            Call // comment("black piece");
            If (piece type == -100)
            {
                If (endgame == 0)
                {
                    PST_read_res += (_PawnPieceSquare[index] * PieceSquareMultiplier[6]);
                    Stop(this script);
                }
                If (endgame == 1)
                {
                    PST_read_res += (_PawnPieceSquare(End)[index] * PieceSquareMultiplier[6]);
                    Stop(this script);
                }
                Stop(this script);
            }
            If (piece type == -320)
            {
                If (endgame == 0)
                {
                    PST_read_res += (_KnightPieceSquare[index] * PieceSquareMultiplier[5]);
                    Stop(this script);
                }
                If (endgame == 1)
                {
                    PST_read_res += (_KnightPieceSquares (End)[index] * PieceSquareMultiplier[5]);
                    Stop(this script);
                }
                Stop(this script);
            }
            If (piece type == -330)
            {
                If (endgame == 0)
                {
                    PST_read_res += (_BishopPieceSquares[index] * PieceSquareMultiplier[4]);
                    Stop(this script);
                }
                If (endgame == 1)
                {
                    PST_read_res += (_BishopPieceSquares(End)[index] * PieceSquareMultiplier[4]);
                    Stop(this script);
                }
                Stop(this script);
            }
            If (piece type == -500)
            {
                If (endgame == 0)
                {
                    PST_read_res += (_RookPieceSquares[index] * PieceSquareMultiplier[3]);
                    Stop(this script);
                }
                If (endgame == 1)
                {
                    PST_read_res += (_RookPieceSquares(Endgame)[index] * PieceSquareMultiplier[3]);
                    Stop(this script);
                }
                Stop(this script);
            }
            If (piece type == -900)
            {
                If (endgame == 0)
                {
                    PST_read_res += (_Queen Piece Squares[index] * PieceSquareMultiplier[2]);
                    Stop(this script);
                }
                If (endgame == 1)
                {
                    PST_read_res += (_QueenPieceSquares(End)[index] * PieceSquareMultiplier[2]);
                    Stop(this script);
                }
                Stop(this script);
            }
            If (piece type == -99999)
            {
                If (endgame == 0)
                {
                    PST_read_res += (_KingPieceSquares(Middle)[index] * PieceSquareMultiplier[1]);
                    Stop(this script);
                }
                If (endgame == 1)
                {
                    PST_read_res += (_KingPieceSquares(End)[index] * PieceSquareMultiplier[1]);
                    Stop(this script);
                }
                Stop(this script);
            }
            Stop(this script);
        }
        Call // comment("white pieces");
        If (piece type == 100)
        {
            If (endgame == 0)
            {
                PST_read_res += ((_PawnPieceSquare[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[6]) * -1);
                Stop(this script);
            }
            If (endgame == 1)
            {
                PST_read_res += ((_PawnPieceSquare(End)[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[6]) * -1);
                Stop(this script);
            }
            Stop(this script);
        }
        If (piece type == 320)
        {
            If (endgame == 0)
            {
                PST_read_res += ((_KnightPieceSquare[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[5]) * -1);
                Stop(this script);
            }
            If (endgame == 1)
            {
                PST_read_res += ((_KnightPieceSquares (End)[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[5]) * -1);
                Stop(this script);
            }
            Stop(this script);
        }
        If (piece type == 330)
        {
            If (endgame == 0)
            {
                PST_read_res += ((_BishopPieceSquares[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[4]) * -1);
                Stop(this script);
            }
            If (endgame == 1)
            {
                PST_read_res += ((_BishopPieceSquares(End)[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[4]) * -1);
                Stop(this script);
            }
            Stop(this script);
        }
        If (piece type == 500)
        {
            If (endgame == 0)
            {
                PST_read_res += ((_RookPieceSquares[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[3]) * -1);
                Stop(this script);
            }
            If (endgame == 1)
            {
                PST_read_res += ((_RookPieceSquares(Endgame)[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[3]) * -1);
                Stop(this script);
            }
            Stop(this script);
        }
        If (piece type == 900)
        {
            If (endgame == 0)
            {
                PST_read_res += ((_Queen Piece Squares[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[2]) * -1);
                Stop(this script);
            }
            If (endgame == 1)
            {
                PST_read_res += ((_QueenPieceSquares(End)[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[2]) * -1);
                Stop(this script);
            }
            Stop(this script);
        }
        If (piece type == 99999)
        {
            If (endgame == 0)
            {
                PST_read_res += ((_KingPieceSquares(Middle)[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[1]) * -1);
                Stop(this script);
            }
            If (endgame == 1)
            {
                PST_read_res += ((_KingPieceSquares(End)[White PST to Black PST (Vert Refl)[index]] * PieceSquareMultiplier[1]) * -1);
                Stop(this script);
            }
            Stop(this script);
        }
        Stop(this script);
    }
}

Define possible to win (eval) (warp=true)
{
    possible to win finished (eval) = 0;
    kings in opposition res (eval) = (1 * (((WhiteKingFile (eval) == BlackKingFile (eval)) And (abs((WhiteKingRank (eval) - BlackKingRank (eval))) == 2)) Or ((WhiteKingRank (eval) == BlackKingRank (eval)) And (abs((WhiteKingFile (eval) - BlackKingFile (eval))) == 2))));
    Call easy winning position (eval);
    If (possible to win finished (eval) == 1)
    {
        Stop(this script);
    }
    Call scale down rook vs minor (eval);
    If (possible to win finished (eval) == 1)
    {
        Stop(this script);
    }
    If (((NUM BLACK MINOR PIECES (EVAL) == 1) And (NUM WHITE MINOR PIECES (EVAL) == 1)) And ((NUM BLACK MAJOR PIECES (EVAL) + NUM WHITE MAJOR PIECES (EVAL)) == 0))
    {
        If ((ABS PAWN DIFF (EVAL) == 0) And (NUM BLACK PAWNS (EVAL) < 4))
        {
            If ((most advanced white pawn rank (eval) < 6) And (most advanced black pawn rank (eval) > 3))
            {
                Call scale down eval value:(0.65);
            }
        }
    }
    If (PIECE MATERIAL (NO PAWNS) (EVAL) == 0)
    {
        Call // comment("pawn endgame");
        If ((num black passers (eval) + num white passers (eval)) == 0)
        {
            BOARD EVAL += ((NUM WHITE PAWNS (EVAL) - NUM BLACK PAWNS (EVAL)) * 50);
        }
        If (num white passers (eval) == 0)
        {
            If (num black outside passers (eval) > 0)
            {
                BOARD EVAL += -125;
            }
        }
        If (num black passers (eval) == 0)
        {
            If (num white outside passers (eval) > 0)
            {
                BOARD EVAL += 125;
            }
        }
    }
    If ((is rook endgame? (eval) == 1) And (NUM BLACK ROOKS (EVAL) == NUM WHITE ROOKS (EVAL)))
    {
        Call // comment("special rook endgame scaling");
        Call scale rooks with pawns endgame with our pawns:(NUM WHITE PAWNS (EVAL)) their pawns:(NUM BLACK PAWNS (EVAL)) their most advanced pawn rank:(most advanced black pawn rank (eval)) our king rank:(WhiteKingRank (eval)) their king rank:(BlackKingRank (eval)) their most advanced pawn file:(most advanced black pawn file (eval)) our king file:(WhiteKingFile (eval)) our most advanced pawn rank:(most advanced white pawn rank (eval)) our passers:(num white passers (eval)) their passers:(num black passers (eval))((1 == 1));
        Call scale rooks with pawns endgame with our pawns:(NUM BLACK PAWNS (EVAL)) their pawns:(NUM WHITE PAWNS (EVAL)) their most advanced pawn rank:((9 - most advanced white pawn rank (eval))) our king rank:((9 - BlackKingRank (eval))) their king rank:((9 - WhiteKingRank (eval))) their most advanced pawn file:(most advanced white pawn file (eval)) our king file:(BlackKingFile (eval)) our most advanced pawn rank:((9 - most advanced black pawn rank (eval))) our passers:(num black passers (eval)) their passers:(num white passers (eval))((0 == 1));
    }
    Call scale down less than minor piece advantage endgame with perspective:((1 == 1)) our pawns:(NUM WHITE PAWNS (EVAL)) their pawns:(NUM BLACK PAWNS (EVAL)) our passers:(num white passers (eval)) their passers:(num black passers (eval)) our furthest passer:(most advanced white pawn rank (eval)) their furthest passer:(most advanced black pawn rank (eval)) (eval) our major pieces:(NUM WHITE MAJOR PIECES (EVAL)) our knights:(NUM WHITE KNIGHTS (EVAL)) our piece count:(NUM WHITE PIECES (NOT PAWNS) (EVAL)) our furthest passer file:(most advanced white pawn file (eval)) num our bishops:(NUM WHITE BISHOPS (EVAL)) our bishop color:(bishop color (eval)) our furthest passer prom square:(most advanced white pawn file (eval)) their king id:(blackKingID(eval)) our king id:(whiteKingID(eval)) their king rank:(BlackKingRank (eval));
    Call scale down less than minor piece advantage endgame with perspective:((0 == 1)) our pawns:(NUM BLACK PAWNS (EVAL)) their pawns:(NUM WHITE PAWNS (EVAL)) our passers:(num black passers (eval)) their passers:(num white passers (eval)) our furthest passer:((9 - most advanced black pawn rank (eval))) their furthest passer:((9 - most advanced white pawn rank (eval))) (eval) our major pieces:(NUM BLACK MAJOR PIECES (EVAL)) our knights:(NUM BLACK KNIGHTS (EVAL)) our piece count:(NUM BLACK PIECES (NOT PAWNS) (EVAL)) our furthest passer file:(most advanced black pawn file (eval)) num our bishops:(NUM BLACK BISHOPS (EVAL)) our bishop color:(bishop color (eval)) our furthest passer prom square:((56 + most advanced black pawn file (eval))) their king id:(whiteKingID(eval)) our king id:(blackKingID(eval)) their king rank:((9 - WhiteKingRank (eval)));
    Call scale down pawn flank endings;
    If (abs(PIECE EVAL (NO PAWNS)) < 50)
    {
        If ((NUM TOTAL PAWNS (EVAL) == 1) And ((NUM BLACK MINOR PIECES (EVAL) + NUM WHITE MINOR PIECES (EVAL)) > 0))
        {
            If (NUM BLACK PAWNS (EVAL) == 1)
            {
                Call // comment("(black has more mat.)");
                Call scale down pawn up late endgame with their most advanced passer rank:(most advanced black pawn rank (eval)) their most advanced passer file:(most advanced black pawn file (eval)) our king rank:(WhiteKingRank (eval)) our king file:(WhiteKingFile (eval)) their king rank:(BlackKingRank (eval));
            }
            Else
            {
                Call // comment("(white has more mat.)");
                Call scale down pawn up late endgame with their most advanced passer rank:((9 - most advanced white pawn rank (eval))) their most advanced passer file:(most advanced white pawn file (eval)) our king rank:(BlackKingRank (eval)) our king file:(BlackKingFile (eval)) their king rank:(WhiteKingRank (eval));
            }
        }
    }
    If (((NUM WHITE MAJOR PIECES (EVAL) + NUM BLACK MAJOR PIECES (EVAL)) == 0) And ((NUM WHITE KNIGHTS (EVAL) + NUM BLACK KNIGHTS (EVAL)) == 0))
    {
        If ((NUM WHITE BISHOPS (EVAL) == 1) And (NUM BLACK BISHOPS (EVAL) == 1))
        {
            If (Not ((WHITE BISHOP TYPE (EVAL) == BLACK BISHOP TYPE (EVAL))))
            {
                Call // comment("opposite colored bishop endings are very drawish");
                BOARD EVAL = Operator.Round((BOARD EVAL * 0.35));
                If (ABS PAWN DIFF (EVAL) < 2)
                {
                    Call // comment("very little pawns, very little imbalance");
                    If (NUM TOTAL PAWNS (EVAL) < 6)
                    {
                        Call scale down eval value:(0.8);
                    }
                    If (NUM TOTAL PAWNS (EVAL) < 2)
                    {
                        Call scale down eval value:(0.15);
                    }
                }
                Else
                {
                    If (ABS PAWN DIFF (EVAL) < 3)
                    {
                        Call // comment("very little pawns, little imbalance");
                        If ((NUM TOTAL PAWNS (EVAL) < 5) And ((num white passers (eval) - num black passers (eval)) < 2))
                        {
                            Call scale down eval value:(0.4);
                        }
                    }
                }
                If (num white passers (eval) > 2)
                {
                    BOARD EVAL += 75;
                }
                If (num black passers (eval) > 2)
                {
                    BOARD EVAL += -75;
                }
            }
        }
    }
    If (isEndgame? (for eval) == 1)
    {
        If (((NUM WHITE QUEENS (EVAL) + NUM BLACK QUEENS (EVAL)) == 2) Or ((((NUM BLACK QUEENS (EVAL) == 1) And ((NUM WHITE QUEENS (EVAL) == 0) And ((NUM WHITE MAJOR PIECES (EVAL) == 1) And ((NUM WHITE ROOKS (EVAL) == 1) And (NUM WHITE MINOR PIECES (EVAL) == 1))))) And (NUM WHITE PAWNS (EVAL) > NUM BLACK PAWNS (EVAL))) Or (((NUM WHITE QUEENS (EVAL) == 1) And ((NUM BLACK QUEENS (EVAL) == 0) And ((NUM BLACK MINOR PIECES (EVAL) == 1) And ((NUM BLACK ROOKS (EVAL) == 1) And (NUM BLACK MINOR PIECES (EVAL) == 1))))) And (NUM BLACK PAWNS (EVAL) > NUM WHITE PAWNS (EVAL)))))
        {
            Call // comment("queens can very very slightly make endings easier to draw");
            Call scale down eval value:(0.9);
            If (ABS PAWN DIFF (EVAL) < 2)
            {
                If ((NUM WHITE PIECES (NOT PAWNS) (EVAL) + NUM BLACK PIECES (NOT PAWNS) (EVAL)) < 5)
                {
                    Call scale down eval value:(0.9);
                    If ((NUM WHITE PIECES (NOT PAWNS) (EVAL) + NUM BLACK PIECES (NOT PAWNS) (EVAL)) == 2)
                    {
                        Call // comment("just queens on the board");
                        If ((NUM TOTAL PAWNS (EVAL) == 1) Or (((num white passers (eval) + num black passers (eval)) == 0) Or (((most advanced white pawn rank (eval) < 6) And (num white passers (eval) < 2)) Or ((most advanced black pawn rank (eval) > 3) And (num black passers (eval) < 2)))))
                        {
                            Call scale down eval value:(0.35);
                        }
                    }
                }
            }
        }
        If ((NUM BLACK ROOKS (EVAL) == 1) And (NUM WHITE ROOKS (EVAL) == 1))
        {
            Call // comment("rook endgames are very often draws");
            If (((NUM WHITE MAJOR PIECES (EVAL) + NUM BLACK MAJOR PIECES (EVAL)) == 2) And ((NUM WHITE MINOR PIECES (EVAL) + NUM BLACK MINOR PIECES (EVAL)) == 0))
            {
                Call scale down eval value:(0.9);
            }
            If (((NUM WHITE MAJOR PIECES (EVAL) + NUM BLACK MAJOR PIECES (EVAL)) == 2) And ((NUM WHITE MINOR PIECES (EVAL) + NUM BLACK MINOR PIECES (EVAL)) == 2))
            {
                Call scale down eval value:(0.95);
            }
        }
    }
}

Define PrepareCurrentKillerMoves with depth:(string depth) (warp=true)
{
    List.DeleteAll(CurrentKillerMoves);
    killerIdx = (((depth - 1) * 4) + 1);
    List.Add(CurrentKillerMoves, KillerMoves[killerIdx]);
    List.Add(CurrentKillerMoves, KillerMoves[(killerIdx + 1)]);
    List.Add(CurrentKillerMoves, KillerMoves[(killerIdx + 2)]);
    List.Add(CurrentKillerMoves, KillerMoves[(killerIdx + 3)]);
}

Define pv_table add best move:(string best move) depth:(string depth) (warp=true)
{
    Call write pv_val at depth:(depth) pv_depth:(depth) write:(best move);
    pv collection search idx = (depth + 1);
    Repeat (30)
    {
        If ((Not ((pv collection search idx < PV_length[(depth + 1)]))) Or (pv collection search idx > 29))
        {
            Call read pv_val at depth:((depth + 1)) pv_depth:(pv collection search idx);
            Call write pv_val at depth:(depth) pv_depth:(pv collection search idx) write:(pv_val_read_res);
            List.ReplaceItem(PV_length, depth, PV_length[(depth + 1)]);
            If (PV_length[(depth + 1)] == 0)
            {
                List.ReplaceItem(PV_length, depth, depth);
            }
            Stop(this script);
        }
        Call read pv_val at depth:((depth + 1)) pv_depth:(pv collection search idx);
        Call write pv_val at depth:(depth) pv_depth:(pv collection search idx) write:(pv_val_read_res);
        pv collection search idx += 1;
    }
}

Define queen movement with board position index:(string index) color of piece:(string color of piece) depth:(string depth) add to legal move list?:(string add to legal move list?) is quiet search?:(string is quiet search?) (warp=true)
{
    Call get distance to edge with index:(index) //  MOVE GEN;
    start square for moving pieces = index;
    color of piece = color of piece;
    moves for sliding pieces direction = 0;
    Repeat (8)
    {
        moves for sliding pieces direction += 1;
        Call loop for sliding pieces inner with depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?(is quiet search?) caller type:("Q");
    }
}

Define quicksort for move ordering (warp=true)
{
    List.DeleteAll(QuickSort Part Stack);
    Call quicksort impl(1)(List.Length(Moves Score Guess));
}

Define quicksort impl(string lowerBound)(string upperBound) (warp=true)
{
    lower (WD) = lowerBound;
    upper (WD) = upperBound;
    pivot (WD) = Moves Score Guess[floor(((lowerBound + upperBound) / 2))];
    Repeat Until (lower (WD) > upper (WD))
    {
        Repeat Until (Not ((Moves Score Guess[lower (WD)] < pivot (WD))))
        {
            lower (WD) += 1;
        }
        Repeat Until (Not ((Moves Score Guess[upper (WD)] > pivot (WD))))
        {
            upper (WD) += -1;
        }
        If (Not ((lower (WD) > upper (WD))))
        {
            tempSwap (WD) = Moves Score Guess[lower (WD)];
            tempSwap2 = Moves for Ordering (Temp For Sorting)[lower (WD)];
            List.ReplaceItem(Moves Score Guess, lower (WD), Moves Score Guess[upper (WD)]);
            List.ReplaceItem(Moves for Ordering (Temp For Sorting), lower (WD), Moves for Ordering (Temp For Sorting)[upper (WD)]);
            List.ReplaceItem(Moves for Ordering (Temp For Sorting), upper (WD), tempSwap2);
            List.ReplaceItem(Moves Score Guess, upper (WD), tempSwap (WD));
            lower (WD) += 1;
            upper (WD) += -1;
        }
    }
    If (lowerBound < upper (WD))
    {
        List.Add(QuickSort Part Stack, upper (WD));
        Call quicksort impl(lowerBound)(upper (WD));
        lower (WD) = QuickSort Part Stack[List.Length(QuickSort Part Stack)];
        List.DeleteItem(QuickSort Part Stack, List.Length(QuickSort Part Stack));
    }
    If (lower (WD) < upperBound)
    {
        Call quicksort impl(lower (WD))(upperBound);
    }
}

Define quiet search with depth:(string q-search depth) max depth:(string max q-search depth) q-search started depth:(string start depth) (q-search / quiescence search) (warp=true)
{
    GameState: = 1;
    startsInCheck? (var) = 0;
    List.ReplaceItem(BoardAttackedBySideToMoveSnapshot, q-search depth, "none");
    List.ReplaceItem(BoardAttackedBySideToMovePieceSnapshot, q-search depth, "none");
    List.ReplaceItem(BoardAttackedBySideToMovePieceSnapshot 2, q-search depth, "none");
    List.ReplaceItem(Large Positional in Static Eval at Depth, q-search depth, 0);
    List.ReplaceItem(PV_length, q-search depth, 0);
    List.ReplaceItem(Real Search Depth For Move, q-search depth, -1);
    List.ReplaceItem(Search Node State:, q-search depth, "start (q)");
    List.ReplaceItem(STATIC EVAL AT DEPTH, q-search depth, "");
    List.ReplaceItem(Board Hash At Depth, q-search depth, "");
    List.ReplaceItem(Hash Move, q-search depth, "????");
    List.ReplaceItem(Moves Index, q-search depth, 0);
    List.ReplaceItem(WD_EnPassantTarget, (q-search depth + 1), "null move");
    List.ReplaceItem(MinEval, q-search depth, "Infinity");
    List.ReplaceItem(MaxEval, q-search depth, "-Infinity");
    List.ReplaceItem(Best Move, q-search depth, "???");
    List.ReplaceItem(BestMoveIndex, q-search depth, 1);
    List.ReplaceItem(StartsInCheck?, q-search depth, 0);
    List.ReplaceItem(Fully Legal Move Gen?, q-search depth, "no move gen");
    If ((q-search depth % 2) == 1)
    {
        List.ReplaceItem(MinMax Results, q-search depth, "Infinity");
        List.ReplaceItem(OP KING ID AT DEPTH, q-search depth, WHITE KING ID (UPDATED));
    }
    Else
    {
        List.ReplaceItem(MinMax Results, q-search depth, "-Infinity");
        List.ReplaceItem(OP KING ID AT DEPTH, q-search depth, BLACK KING ID (UPDATED));
    }
    Call // comment("if opponent captured our king on the last move, we must have made an illegal move");
    If (targetPieces[(q-search depth - 1)] == 99999)
    {
        List.ReplaceItem(MinMax Results, q-search depth, (-9999999 + q-search depth));
        Stop(this script);
    }
    If (targetPieces[(q-search depth - 1)] == -99999)
    {
        List.ReplaceItem(MinMax Results, q-search depth, (9999999 - q-search depth));
        Stop(this script);
    }
    Call // comment("mate distance pruning");
    If (q-search depth > search starting depth)
    {
        If ((q-search depth % 2) == 1)
        {
            If (Alphas[q-search depth] > (-9999999 + q-search depth))
            {
                List.ReplaceItem(Alphas, q-search depth, Alphas[q-search depth]);
            }
            Else
            {
                List.ReplaceItem(Alphas, q-search depth, (-9999999 + q-search depth));
            }
            If (Betas[q-search depth] < (9999999 - (q-search depth + 1)))
            {
                List.ReplaceItem(Betas, q-search depth, Betas[q-search depth]);
            }
            Else
            {
                List.ReplaceItem(Betas, q-search depth, (9999999 - (q-search depth + 1)));
            }
            If (Not ((Alphas[q-search depth] < Betas[q-search depth])))
            {
                List.ReplaceItem(MinMax Results, q-search depth, Alphas[q-search depth]);
                Stop(this script);
            }
        }
        Else
        {
            If (Alphas[q-search depth] > (-9999999 + q-search depth))
            {
                List.ReplaceItem(Alphas, q-search depth, Alphas[q-search depth]);
            }
            Else
            {
                List.ReplaceItem(Alphas, q-search depth, (-9999999 + q-search depth));
            }
            If (Betas[q-search depth] < (9999999 - (q-search depth + 1)))
            {
                List.ReplaceItem(Betas, q-search depth, Betas[q-search depth]);
            }
            Else
            {
                List.ReplaceItem(Betas, q-search depth, (9999999 - (q-search depth + 1)));
            }
            If (Not ((Alphas[q-search depth] < Betas[q-search depth])))
            {
                List.ReplaceItem(MinMax Results, q-search depth, Alphas[q-search depth]);
                Stop(this script);
            }
        }
    }
    List.ReplaceItem(ScoreTypes, q-search depth, "E");
    If ((q-search depth % 2) == 1)
    {
        List.ReplaceItem(ScoreTypes, q-search depth, "B");
    }
    Else
    {
        List.ReplaceItem(ScoreTypes, q-search depth, "A");
    }
    List.ReplaceItem(Board Hash At Depth, q-search depth, Next Ply Board Hash[(q-search depth - 1)]);
    List.ReplaceItem(TTentryUsed?, q-search depth, "N/A");
    List.ReplaceItem(TTentryUsed (line), q-search depth, "N/A");
    Call repetition detection (in search) with depth:(q-search depth);
    If (eval is draw (repetition) == 1)
    {
        List.ReplaceItem(MinMax Results, q-search depth, CPU CONTEMPT VALUE);
        List.ReplaceItem(Search Node State:, q-search depth, "repetition exit (q)");
        Stop(this script);
    }
    Call TTprobeNode with board hash:(Board Hash At Depth[q-search depth]) depth:(q-search depth);
    If (TTprobeRes (WD) == 1)
    {
        List.ReplaceItem(Hash Move, q-search depth, TTprobeBestMoveRes);
        List.ReplaceItem(BoardAttackedBySideToMoveSnapshot, q-search depth, TTprobeNodeBoardAttacked);
        List.ReplaceItem(BoardAttackedBySideToMovePieceSnapshot, q-search depth, TTprobeNodeBoardAttackedSource1);
        List.ReplaceItem(BoardAttackedBySideToMovePieceSnapshot 2, q-search depth, TTprobeNodeBoardAttackedSource2);
    }
    If ((TTprobeRes (WD) == 1) And (TTprobeHorizonRes == -1))
    {
        If ((TTprobeNodeType == "E") Or (((TTprobeNodeType == "A") And (Not ((TTprobeNodeScoreRes > Alphas[q-search depth])))) Or ((TTprobeNodeType == "B") And (Not ((TTprobeNodeScoreRes < Betas[q-search depth]))))))
        {
            If ((Not (((q-search depth - TTprobeNodeQSstartDepth) > (q-search depth - start depth)))) Or ((q-search depth - start depth) > 2))
            {
                If (abs(TTprobeNodeScoreRes) > 9990000)
                {
                    If (TTprobeNodeScoreRes > 0)
                    {
                        List.ReplaceItem(MinMax Results, q-search depth, (TTprobeNodeScoreRes - (q-search depth * 1)));
                    }
                    Else
                    {
                        List.ReplaceItem(MinMax Results, q-search depth, (TTprobeNodeScoreRes + (q-search depth * 1)));
                    }
                }
                Else
                {
                    List.ReplaceItem(MinMax Results, q-search depth, TTprobeNodeScoreRes);
                }
                TTentryUsed? = 1;
                List.ReplaceItem(TTentryUsed?, q-search depth, Operator.Join(Operator.Join(Operator.Join(Operator.Join(Operator.Join(Operator.Join(Operator.Join(TTprobeNodeType, Operator.Join(" (q-srch) TT hrz: ", TTprobeHorizonRes)), " hrz: "), -1), " dpt: "), q-search depth), " TT dpt / max: "), Operator.Join(Operator.Join(TTprobeNodeDepth, Operator.Join(" | ", TTprobeNodeMaxDepth (WD))), Operator.Join(Operator.Join(" TT ID idx: ", TTprobeNodeIDidx (WD)), Operator.Join(Operator.Join(" TT age: ", TTprobeNodeAgeRes), Operator.Join(" QS start: ", TTprobeNodeQSstartDepth))))));
                List.ReplaceItem(TTentryUsed (line), q-search depth, TTprobeNodeLine (WD));
                List.ReplaceItem(Search Node State:, q-search depth, "TT entry used exit (q)");
                Stop(this script);
            }
        }
    }
    If (PutsInCheck?[(q-search depth - 1)] == 1)
    {
        List.ReplaceItem(StartsInCheck?, q-search depth, 1);
    }
    If (q-search depth < max q-search depth)
    {
        Call gen checks in q-search with depth:(q-search depth) q-search start:(start depth);
        Call // comment("Main difference between fully legal moves and pseudo-legal move gen is stalemate detection (not really needed in q-search)");
        Call // comment("and built-in checkmate detection, which comes pretty cheaply in q-search anyhow");
        If (StartsInCheck?[q-search depth] == 1)
        {
            Call get all legal moves from current position depth:(q-search depth) is quiet search?:(1) completely legal?(1) generate checks?(gen checks in q-search res);
            List.ReplaceItem(Fully Legal Move Gen?, q-search depth, 1);
        }
        Else
        {
            Call fast pseudo-legal move gen with depth:(q-search depth)((1 == 1))((gen checks in q-search res == 1))(((BoardAttackedBySideToMoveSnapshot[q-search depth] == "none") And ((q-search depth - start depth) < 2)));
            List.ReplaceItem(Fully Legal Move Gen?, q-search depth, 0);
        }
        If (opponent king hanging res (move gen) == 1)
        {
            If ((q-search depth % 2) == 1)
            {
                List.ReplaceItem(MinMax Results, q-search depth, (-9999999 + q-search depth));
            }
            Else
            {
                List.ReplaceItem(MinMax Results, q-search depth, (9999999 - q-search depth));
            }
            List.ReplaceItem(Search Node State:, q-search depth, "illegal king move d-1 exit (q)");
            Stop(this script);
        }
        Call move ordering with depth:(q-search depth) search this move first:("") include checks in ordering?(0);
    }
    List.ReplaceItem(StartsInCheck?, q-search depth, startsInCheck? (var));
    If (StartsInCheck?[q-search depth] == 0)
    {
        Call // comment("STAND-PAT CODE");
        Call // comment("//////////////////////////////////");
        Call // comment("lazy eval saves time by not calling the expensive eval function a positions which don't need it");
        Call // comment("disabled for now, as it doesn't save much time at all ~5%");
        BlackKingisAttacked (eval) = 0;
        WhiteKingIsAttacked (eval) = 0;
        If ((STATIC EVAL AT DEPTH[(q-search depth - 1)] == "") Or (1 == 1))
        {
            Call // comment("full / normal eval");
            Call evaluation of current position with depth:(q-search depth) force HCE:("") log debug:();
        }
        Else
        {
            Call lazy eval with depth:(q-search depth);
            If ((q-search depth % 2) == 1)
            {
                If (Betas[q-search depth] > (BOARD EVAL - (LAZY EVAL MARGIN + abs((BOARD EVAL - STATIC EVAL AT DEPTH[(q-search depth - 1)])))))
                {
                    Call evaluation of current position with depth:(q-search depth) force HCE:("") log debug:();
                }
            }
            Else
            {
                If (Alphas[q-search depth] < (BOARD EVAL + (LAZY EVAL MARGIN + abs((BOARD EVAL - STATIC EVAL AT DEPTH[(q-search depth - 1)])))))
                {
                    Call evaluation of current position with depth:(q-search depth) force HCE:("") log debug:();
                }
            }
        }
        If ((eval used HCE res == 1) And ((abs(Black King Attacked Val) + abs(White King Attacked Val)) > 300))
        {
            List.ReplaceItem(Large Positional in Static Eval at Depth, q-search depth, 1);
        }
        If ((((q-search depth % 2) == 1) And (BlackKingisAttacked (eval) == 0)) Or (((q-search depth % 2) == 0) And (WhiteKingIsAttacked (eval) == 0)))
        {
            Call // comment("our king is not attacked");
            List.ReplaceItem(STATIC EVAL AT DEPTH, q-search depth, BOARD EVAL);
            List.ReplaceItem(Stand-Pat, q-search depth, BOARD EVAL);
            List.ReplaceItem(MinMax Results, q-search depth, BOARD EVAL);
            If ((q-search depth % 2) == 1)
            {
                List.ReplaceItem(MinEval, q-search depth, BOARD EVAL);
                If ((Not ((BOARD EVAL > Alphas[q-search depth]))) Or (((BOARD EVAL - 1350) > Betas[q-search depth]) And (Large Positional in Static Eval at Depth[q-search depth] == 0)))
                {
                    List.ReplaceItem(MinMax Results, q-search depth, BOARD EVAL);
                    List.ReplaceItem(Search Node State:, q-search depth, Operator.Join("static eval cutoff (q) (b): ", BOARD EVAL));
                    Stop(this script);
                }
                If (BOARD EVAL < Betas[q-search depth])
                {
                    List.ReplaceItem(Betas, q-search depth, BOARD EVAL);
                }
            }
            Else
            {
                List.ReplaceItem(MaxEval, q-search depth, BOARD EVAL);
                If ((Not ((BOARD EVAL < Betas[q-search depth]))) Or (((BOARD EVAL + 1350) < Alphas[q-search depth]) And (Large Positional in Static Eval at Depth[q-search depth] == 0)))
                {
                    List.ReplaceItem(MinMax Results, q-search depth, BOARD EVAL);
                    List.ReplaceItem(Search Node State:, q-search depth, Operator.Join("static eval cutoff (q) (w): ", BOARD EVAL));
                    Stop(this script);
                }
                If (BOARD EVAL > Alphas[q-search depth])
                {
                    List.ReplaceItem(Alphas, q-search depth, BOARD EVAL);
                }
            }
        }
        Else
        {
            List.ReplaceItem(Fully Legal Move Gen?, q-search depth, 1);
            List.ReplaceItem(StartsInCheck?, q-search depth, 1);
            Call get all legal moves from current position depth:(q-search depth) is quiet search?:(1) completely legal?(1) generate checks?(gen checks in q-search res);
        }
    }
    List.ReplaceItem(MinMax Results, (q-search depth + 1), Stand-Pat[q-search depth]);
    If ((q-search depth == max q-search depth) Or (Moves Count[q-search depth] == 0))
    {
        If (q-search depth == max q-search depth)
        {
            Call ​​log​​(Operator.Join(Operator.Join("q-search max reached: ", max q-search depth), Operator.Join(Operator.Join(" // ID idx:", iterative deepening Idx), Operator.Join(" // q-search start:", start depth))));
            Call ​​log​​(Moves Played In Search);
        }
        If (GameState: == 1)
        {
            Call evaluation of current position with depth:(q-search depth) force HCE:("") log debug:();
            List.ReplaceItem(MinMax Results, q-search depth, BOARD EVAL);
            List.ReplaceItem(Search Node State:, q-search depth, "max depth or no moves cutoff (q)");
            quiet nodes evaluated += 1;
            Stop(this script);
        }
        If (Moves Count[q-search depth] == 0)
        {
            If (startsInCheck? (var) == 1)
            {
                If ((q-search depth % 2) == 1)
                {
                    BOARD EVAL = (9999999 - q-search depth);
                }
                Else
                {
                    BOARD EVAL = (-9999999 + q-search depth);
                }
                List.ReplaceItem(MinMax Results, q-search depth, BOARD EVAL);
                quiet nodes evaluated += 1;
            }
        }
    }
    Else
    {
        List.ReplaceItem(Moves Index, q-search depth, 0);
        Repeat (List.Length(ALL LEGAL MOVES FOR CPU CALCS))
        {
            List.ReplaceItem(Moves Index, q-search depth, (Moves Index[q-search depth] + 1));
            Call apply move with depth:(q-search depth) manual override:("") full search:();
            List.ReplaceItem(Alphas, (q-search depth + 1), Alphas[q-search depth]);
            List.ReplaceItem(Betas, (q-search depth + 1), Betas[q-search depth]);
            List.ReplaceItem(Search Node State:, (q-search depth + 1), "node not generated yet (q)");
            Call is bad capture? with depth:(q-search depth);
            If ((move type (for applying moves) == "promotion") Or ((StartsInCheck?[q-search depth] == 1) Or ((NOT PAWN MATERIAL (UPDATED) < 2200) Or ((PutsInCheck?[q-search depth] == 1) Or (Large Positional in Static Eval at Depth[q-search depth] == 1)))))
            {
                Call quiet search with depth:((q-search depth + 1)) max depth:(max q-search depth) q-search started depth:(start depth) (q-search / quiescence search);
            }
            Else
            {
                If (Not ((is bad capture? (q-search) == 1)))
                {
                    If ((q-search depth % 2) == 1)
                    {
                        If (Not ((((Stand-Pat[q-search depth] - abs((targetPieces[q-search depth] * 1.4))) - 350) < Betas[q-search depth])))
                        {
                            num delta pruned += 1;
                        }
                        Else
                        {
                            Call quiet search with depth:((q-search depth + 1)) max depth:(max q-search depth) q-search started depth:(start depth) (q-search / quiescence search);
                        }
                    }
                    Else
                    {
                        If (Not ((((Stand-Pat[q-search depth] + abs((targetPieces[q-search depth] * 1.4))) + 350) > Alphas[q-search depth])))
                        {
                            num delta pruned += 1;
                        }
                        Else
                        {
                            Call quiet search with depth:((q-search depth + 1)) max depth:(max q-search depth) q-search started depth:(start depth) (q-search / quiescence search);
                        }
                    }
                }
            }
            Eval/Score = MinMax Results[(q-search depth + 1)];
            Call revert moves with depth:(q-search depth) manual override:("");
            Call minmax time exhausted?;
            If (minmax time exhausted? == 1)
            {
                Stop(this script);
            }
            If ((q-search depth % 2) == 1)
            {
                If (Eval/Score < Betas[q-search depth])
                {
                    List.ReplaceItem(Betas, q-search depth, Eval/Score);
                    List.ReplaceItem(ScoreTypes, q-search depth, "E");
                }
                If (Eval/Score < MinEval[q-search depth])
                {
                    List.ReplaceItem(MinEval, q-search depth, Eval/Score);
                    List.ReplaceItem(MinMax Results, q-search depth, Eval/Score);
                    List.ReplaceItem(Best Move, q-search depth, current reverting move);
                    List.ReplaceItem(BestMoveIndex, q-search depth, Moves Index[q-search depth]);
                }
                If ((Betas[q-search depth] < Alphas[q-search depth]) Or (Betas[q-search depth] == Alphas[q-search depth]))
                {
                    Call TTstoreNode with board hash:(Board Hash At Depth[q-search depth]) depth:(q-search depth) score:(MinMax Results[q-search depth]) horizon:(-1) best move:(Best Move[q-search depth]) node type:("A") max depth:(max q-search depth) q-search start depth:(start depth) board atk:(BoardAttackedBySideToMoveSnapshot[q-search depth]) atk source:(BoardAttackedBySideToMovePieceSnapshot[q-search depth]) atk source 2:(BoardAttackedBySideToMovePieceSnapshot 2[q-search depth]);
                    branches pruned (quiet search) += 1;
                    BestMoveTotal# (q) (profiler) += 1;
                    BestMoveIdxSum (q) (profiler) += BestMoveIndex[q-search depth];
                    List.ReplaceItem(Search Node State:, q-search depth, "A/B pruning cutoff (q) (min)");
                    Stop(this script);
                }
            }
            Else
            {
                If (Eval/Score > Alphas[q-search depth])
                {
                    List.ReplaceItem(Alphas, q-search depth, Eval/Score);
                    List.ReplaceItem(ScoreTypes, q-search depth, "E");
                }
                If (Eval/Score > MaxEval[q-search depth])
                {
                    List.ReplaceItem(MaxEval, q-search depth, Eval/Score);
                    List.ReplaceItem(MinMax Results, q-search depth, Eval/Score);
                    List.ReplaceItem(Best Move, q-search depth, current reverting move);
                    List.ReplaceItem(BestMoveIndex, q-search depth, Moves Index[q-search depth]);
                }
                If ((Betas[q-search depth] < Alphas[q-search depth]) Or (Betas[q-search depth] == Alphas[q-search depth]))
                {
                    Call TTstoreNode with board hash:(Board Hash At Depth[q-search depth]) depth:(q-search depth) score:(MinMax Results[q-search depth]) horizon:(-1) best move:(Best Move[q-search depth]) node type:("B") max depth:(max q-search depth) q-search start depth:(start depth) board atk:(BoardAttackedBySideToMoveSnapshot[q-search depth]) atk source:(BoardAttackedBySideToMovePieceSnapshot[q-search depth]) atk source 2:(BoardAttackedBySideToMovePieceSnapshot 2[q-search depth]);
                    branches pruned (quiet search) += 1;
                    BestMoveTotal# (q) (profiler) += 1;
                    BestMoveIdxSum (q) (profiler) += BestMoveIndex[q-search depth];
                    List.ReplaceItem(Search Node State:, q-search depth, "A/B cutoff (q) (max)");
                    Stop(this script);
                }
            }
            Call minmax time exhausted?;
            If (minmax time exhausted? == 1)
            {
                Stop(this script);
            }
        }
        BestMoveTotal# (q) (profiler) += 1;
        BestMoveIdxSum (q) (profiler) += BestMoveIndex[q-search depth];
        Call TTstoreNode with board hash:(Board Hash At Depth[q-search depth]) depth:(q-search depth) score:(MinMax Results[q-search depth]) horizon:(-1) best move:(Best Move[q-search depth]) node type:(ScoreTypes[q-search depth]) max depth:(max q-search depth) q-search start depth:(start depth) board atk:(BoardAttackedBySideToMoveSnapshot[q-search depth]) atk source:(BoardAttackedBySideToMovePieceSnapshot[q-search depth]) atk source 2:(BoardAttackedBySideToMovePieceSnapshot 2[q-search depth]);
        List.ReplaceItem(Search Node State:, q-search depth, "finished all q-search code");
    }
}

Define read pv_val at depth:(string depth) pv_depth:(string pv_depth) (warp=true)
{
    pv_val_read_res = PV_moves[((30 * (depth - 1)) + pv_depth)];
}

Define read TT usage (very very slow) (warp=true)
{
    TT USAGE % = "???";
    TT USAGE FRACTION = "???";
    TT NUM FILLED = 0;
    counter for reading TT usage = 0;
    Repeat (List.Length(TTnodeHash))
    {
        counter for reading TT usage += 1;
        If (TTnodeHash[counter for reading TT usage] > "")
        {
            TT NUM FILLED += 1;
        }
    }
    TT USAGE % = ((TT NUM FILLED / List.Length(TTnodeHash)) * 100);
    TT USAGE FRACTION = Operator.Join(TT NUM FILLED, Operator.Join("/", List.Length(TTnodeHash)));
}

Define repetition detection (in search) with depth:(string depth) (warp=true)
{
    eval is draw (repetition) = 0;
    If (depth > search starting depth)
    {
        index of current board hash in rep table = List.IndexOf(REPETITION TABLE, Board Hash At Depth[depth]);
        If (index of current board hash in rep table > 0)
        {
            Call // comment("our entry exists in the transposition table");
            eval is draw (repetition) = 1;
            Stop(this script);
        }
    }
    rep. detection in search idx = depth;
    Repeat ((depth - search starting depth))
    {
        rep. detection in search idx += -1;
        If (Board Hash At Depth[depth] == Board Hash At Depth[rep. detection in search idx])
        {
            eval is draw (repetition) = 1;
            Stop(this script);
        }
    }
}

Define reset general project data (warp=true)
{
    last sure best move eval (ID) = 0;
    List.DeleteAll(GAME MOVES (SQUARES));
    List.DeleteAll(GAME MOVES);
    List.DeleteAll(GAME MOVES (PIECES MOVED));
    List.DeleteAll(GAME POSITION HASH);
    List.DeleteAll(FULL GAME DEBUG INFO);
    List.DeleteAll(GAME FEN);
    List.Add(FULL GAME DEBUG INFO, "Max Search Time: 0");
    List.Add(FULL GAME DEBUG INFO, "Avg. Best Move Idx: 0");
    List.Add(FULL GAME DEBUG INFO, "Avg. Q-Best Move Idx: 0");
    List.Hide(FULL GAME DEBUG INFO);
    List.Hide(EXPORT DATA);
    List.DeleteAll(CurrentKillerMoves);
    Repeat (4)
    {
        List.Add(CurrentKillerMoves, "");
    }
    List.DeleteAll(Pieces ID);
    List.Add(Pieces ID, 99999);
    List.Add(Pieces ID, 900);
    List.Add(Pieces ID, 500);
    List.Add(Pieces ID, 330);
    List.Add(Pieces ID, 320);
    List.Add(Pieces ID, 100);
    List.DeleteAll(Pieces ID FEN/PGN Name);
    List.Add(Pieces ID FEN/PGN Name, "k");
    List.Add(Pieces ID FEN/PGN Name, "q");
    List.Add(Pieces ID FEN/PGN Name, "r");
    List.Add(Pieces ID FEN/PGN Name, "b");
    List.Add(Pieces ID FEN/PGN Name, "n");
    List.Add(Pieces ID FEN/PGN Name, "p");
    List.DeleteAll(Pieces ID Names);
    List.Add(Pieces ID Names, "King");
    List.Add(Pieces ID Names, "Queen");
    List.Add(Pieces ID Names, "Rook");
    List.Add(Pieces ID Names, "Bishop");
    List.Add(Pieces ID Names, "Knight");
    List.Add(Pieces ID Names, "Pawn");
    List.DeleteAll(Pieces ID PGN/FEN Capital);
    List.Add(Pieces ID PGN/FEN Capital, "K");
    List.Add(Pieces ID PGN/FEN Capital, "Q");
    List.Add(Pieces ID PGN/FEN Capital, "R");
    List.Add(Pieces ID PGN/FEN Capital, "B");
    List.Add(Pieces ID PGN/FEN Capital, "N");
    List.Add(Pieces ID PGN/FEN Capital, "P");
    List.DeleteAll(Pieces ID to UCI Name);
    List.Add(Pieces ID to UCI Name, -99999);
    List.Add(Pieces ID to UCI Name, -900);
    List.Add(Pieces ID to UCI Name, -500);
    List.Add(Pieces ID to UCI Name, -330);
    List.Add(Pieces ID to UCI Name, -320);
    List.Add(Pieces ID to UCI Name, -100);
    List.Add(Pieces ID to UCI Name, 99999);
    List.Add(Pieces ID to UCI Name, 900);
    List.Add(Pieces ID to UCI Name, 500);
    List.Add(Pieces ID to UCI Name, 330);
    List.Add(Pieces ID to UCI Name, 320);
    List.Add(Pieces ID to UCI Name, 100);
    List.Add(Pieces ID to UCI Name, "k");
    List.Add(Pieces ID to UCI Name, "q");
    List.Add(Pieces ID to UCI Name, "r");
    List.Add(Pieces ID to UCI Name, "b");
    List.Add(Pieces ID to UCI Name, "n");
    List.Add(Pieces ID to UCI Name, "p");
    List.Add(Pieces ID to UCI Name, "K");
    List.Add(Pieces ID to UCI Name, "Q");
    List.Add(Pieces ID to UCI Name, "R");
    List.Add(Pieces ID to UCI Name, "B");
    List.Add(Pieces ID to UCI Name, "N");
    List.Add(Pieces ID to UCI Name, "P");
    List.DeleteAll(Day of Week);
    List.Add(Day of Week, "Sunday");
    List.Add(Day of Week, "Monday");
    List.Add(Day of Week, "Tuesday");
    List.Add(Day of Week, "Wednesday");
    List.Add(Day of Week, "Thursday");
    List.Add(Day of Week, "Friday");
    List.Add(Day of Week, "Saturday");
    List.DeleteAll(Alternate Piece ID);
    List.Add(Alternate Piece ID, 100);
    List.Add(Alternate Piece ID, 320);
    List.Add(Alternate Piece ID, 330);
    List.Add(Alternate Piece ID, 500);
    List.Add(Alternate Piece ID, 900);
    List.Add(Alternate Piece ID, 99999);
    List.Add(Alternate Piece ID, -100);
    List.Add(Alternate Piece ID, -320);
    List.Add(Alternate Piece ID, -330);
    List.Add(Alternate Piece ID, -500);
    List.Add(Alternate Piece ID, -900);
    List.Add(Alternate Piece ID, -99999);
    BlackKingSideCastle = 0090;
    BlackQueenSideCastle = 0091;
    WhiteKingSideCastle = 0092;
    WhiteQueenSideCastle = 0093;
    CurrentGameCode = "";
    WD_time for search = 0;
    time for search display = 0;
    MaxMoveSearchTime = 0;
    start time for search = Sensing.DaysSince2000();
    half move counter = 0;
    full move counter (WD) = 0;
    CALC STATE = "IDLE";
    Call clear info before move gen;
}

Define reset info for eval function (warp=true)
{
    piece count (eval) = 0;
    PIECE VALUE BONUS MIDDLEGAME (EVAL) = 0;
    PIECE VALUE BONUS ENDGAME (EVAL) = 0;
    BOARD EVAL = 0;
    TOTAL MATERIAL = 0;
    NUM TOTAL PAWNS (EVAL) = 0;
    ABS PAWN DIFF (EVAL) = 0;
    PIECE EVAL (NO PAWNS) = 0;
    WHITE MINOR PIECES DEVELOPED (EVAL) = 4;
    BLACK MINOR PIECES DEVELOPED (EVAL) = 4;
    PIECE MATERIAL (NO PAWNS) (EVAL) = 0;
    WHITE MATERIAL (NO PAWNS) = 0;
    BLACK MATERIAL (NO PAWNS) = 0;
    NUM BLACK PAWNS (EVAL) = 0;
    NUM WHITE PAWNS (EVAL) = 0;
    NUM BLACK BISHOPS (EVAL) = 0;
    NUM WHITE BISHOPS (EVAL) = 0;
    NUM BLACK KNIGHTS (EVAL) = 0;
    NUM WHITE KNIGHTS (EVAL) = 0;
    NUM BLACK QUEENS (EVAL) = 0;
    NUM WHITE QUEENS (EVAL) = 0;
    NUM BLACK ROOKS (EVAL) = 0;
    NUM WHITE ROOKS (EVAL) = 0;
    NUM BLACK MAJOR PIECES (EVAL) = 0;
    NUM WHITE MAJOR PIECES (EVAL) = 0;
    NUM BLACK MINOR PIECES (EVAL) = 0;
    NUM WHITE MINOR PIECES (EVAL) = 0;
    BLACK KING SIDE PAWNS (EVAL) = 0;
    BLACK QUEEN SIDE PAWNS (EVAL) = 0;
    WHITE KING SIDE PAWNS (EVAL) = 0;
    WHITE QUEEN SIDE PAWNS (EVAL) = 0;
    BLACK IN ENDGAME? (EVAL) = 0;
    WHITE IN ENDGAME? (EVAL) = 0;
    num white king attackers (eval) = 0;
    num black king attackers (eval) = 0;
    white king attacking force = 0;
    black king attacking force = 0;
    whiteKingID(eval) = "no king";
    blackKingID(eval) = "no king";
    Black PSTs Middle (eval) = 0;
    White PSTs Middle (eval) = 0;
    Black PSTs End (eval) = 0;
    White PSTs End (eval) = 0;
    king pawn tropism dist to black (eval) = 0;
    king pawn tropism dist to white (eval) = 0;
    king pawn tropism weights (eval) = 0;
    king pawn tropism total value (eval) = 0;
    is rook endgame? (eval) = 0;
    king passer proximity total (eval) = 0;
    most advanced white pawn rank (eval) = -999;
    most advanced black pawn rank (eval) = 999;
    most advanced white pawn file (eval) = 0;
    most advanced black pawn file (eval) = 0;
    WhiteKingPawnlessFlank (eval) = 0;
    BlackKingPawnlessFlank (eval) = 0;
    pawn blocked black (eval) = 0;
    pawn blocked white (eval) = 0;
    area counter black (eval) = 0;
    area counter white (eval) = 0;
    space weight black (eval) = 0;
    space weight white (eval) = 0;
    num fully blocked center pawns white (eval) = 0;
    num fully blocked center pawns black (eval) = 0;
    num light pawns WHITE (eval) = 0;
    num dark pawns WHITE (eval) = 0;
    num light pawns BLACK (eval) = 0;
    num dark pawns BLACK (eval) = 0;
    BlackQueenID(eval) = 0;
    WhiteQueenID(eval) = 0;
    MOBILITY mg (eval) = 0;
    MOBILITY eg (eval) = 0;
    flank attack black king counter (eval) = 0;
    flank attack white king counter (eval) = 0;
    NUM BLACK PIECES (NOT PAWNS) (EVAL) = 0;
    NUM WHITE PIECES (NOT PAWNS) (EVAL) = 0;
    num black king knight defenders (eval) = 0;
    num white king knight defenders (eval) = 0;
    num white passers (eval) = 0;
    num black passers (eval) = 0;
    num white king attacks (eval) = 0;
    num black king attacks (eval) = 0;
    king protector eg (eval) = 0;
    king protector mg (eval) = 0;
    BlackKingisAttacked (eval) = 0;
    WhiteKingIsAttacked (eval) = 0;
    pawn file average (eval) = 0;
    num white outside passers (eval) = 0;
    num black outside passers (eval) = 0;
    List.ReplaceItem(EVAL DEBUG LIST, 2, "");
    List.ReplaceItem(EVAL DEBUG LIST, 4, "");
    List.ReplaceItem(EVAL DEBUG LIST, 6, "");
    List.ReplaceItem(EVAL DEBUG LIST, 8, "");
    List.ReplaceItem(EVAL DEBUG LIST, 10, "");
    List.ReplaceItem(EVAL DEBUG LIST, 12, "");
    List.ReplaceItem(EVAL DEBUG LIST, 14, "");
    List.ReplaceItem(EVAL DEBUG LIST, 16, "");
    List.ReplaceItem(EVAL DEBUG LIST, 18, "");
    List.ReplaceItem(EVAL DEBUG LIST, 20, "");
    List.ReplaceItem(EVAL DEBUG LIST, 21, "");
    List.DeleteAll(Black Attacks (eval));
    List.DeleteAll(Black Attacks Source (eval));
    List.DeleteAll(White Attacks (eval));
    List.DeleteAll(White Attacks Source (eval));
    List.DeleteAll(Black King Ring (eval));
    List.DeleteAll(White King Ring (eval));
    List.DeleteAll(Squares With Rooks (eval));
    List.DeleteAll(blackPawn(ForEval));
    List.DeleteAll(whitePawn(ForEval));
    List.DeleteAll(Most Advanced Black Pawn);
    List.DeleteAll(Least Advanced White Pawn);
    List.DeleteAll(Most Advanced White Pawn);
    List.DeleteAll(Least Advanced Black Pawn);
    List.DeleteAll(Squares With Pieces (Eval));
    List.DeleteAll(Open File? (eval));
    List.DeleteAll(Black Rooks On File);
    List.DeleteAll(White Rooks on File);
    List.DeleteAll(Black Passers on File (eval));
    List.DeleteAll(White Passers on File (eval));
    List.DeleteAll(Black Pawn Attacks Square (eval));
    List.DeleteAll(White Pawn Attacks Square (eval));
    List.DeleteAll(Mobility Area Black);
    List.DeleteAll(Mobility Area White);
    List.DeleteAll(slider on queen threat black (eval));
    List.DeleteAll(slider on queen threat white (eval));
    List.DeleteAll(black king flank (eval));
    List.DeleteAll(white king flank (eval));
    List.DeleteAll(num black attacks on square (eval));
    List.DeleteAll(num white attacks on square (eval));
    List.DeleteAll(Squares with Pawns (eval));
    List.DeleteAll(White Checks (eval));
    List.DeleteAll(Black Checks (eval));
    List.DeleteAll(Black Queen Check Possible? (eval));
    List.DeleteAll(White Queen Check Possible? (eval));
    List.DeleteAll(Black Rook Check Possible? (eval));
    List.DeleteAll(White Rook Check Possible? (eval));
    List.DeleteAll(White Checks Source (eval));
    List.DeleteAll(Black Checks Source (eval));
    List.DeleteAll(White queen attacks on square (eval));
    List.DeleteAll(Black queen attacks on square (eval));
    List.DeleteAll(Black Queen Threat Squares (eval));
    List.DeleteAll(White Queen Threat Squares (eval));
    List.DeleteAll(Black Queen Threat Squares Source (eval));
    List.DeleteAll(White Queen Threat Squares Source (eval));
    List.DeleteAll(black area counter (eval));
    List.DeleteAll(white area counter (eval));
    List.DeleteAll(Piece is Hanging? (eval));
    Repeat (8)
    {
        List.Add(Most Advanced Black Pawn, 999);
        List.Add(Least Advanced White Pawn, 999);
        List.Add(Most Advanced White Pawn, -999);
        List.Add(Least Advanced Black Pawn, -999);
        List.Add(Open File? (eval), 1);
        List.Add(Black Rooks On File, 0);
        List.Add(White Rooks on File, 0);
        List.Add(Black Passers on File (eval), 0);
        List.Add(White Passers on File (eval), 0);
        List.Add(black king flank (eval), 0);
        List.Add(white king flank (eval), 0);
        Repeat (8)
        {
            List.Add(Black Pawn Attacks Square (eval), 0);
            List.Add(White Pawn Attacks Square (eval), 0);
            List.Add(Mobility Area Black, 1);
            List.Add(Mobility Area White, 1);
            List.Add(slider on queen threat black (eval), 0);
            List.Add(slider on queen threat white (eval), 0);
            List.Add(num black attacks on square (eval), 0);
            List.Add(num white attacks on square (eval), 0);
            List.Add(Black Queen Check Possible? (eval), 0);
            List.Add(White Queen Check Possible? (eval), 0);
            List.Add(Black Rook Check Possible? (eval), 0);
            List.Add(White Rook Check Possible? (eval), 0);
            List.Add(White queen attacks on square (eval), 0);
            List.Add(Black queen attacks on square (eval), 0);
            List.Add(black area counter (eval), 0);
            List.Add(white area counter (eval), 0);
            List.Add(Piece is Hanging? (eval), 0);
        }
    }
}

Define reset repetition table (warp=true)
{
    List.DeleteAll(REPETITION TABLE);
    List.DeleteAll(REPETITION TABLE SIDE TO MOVE);
    List.Add(REPETITION TABLE, STARTING POSITION HASH);
    List.Add(REPETITION TABLE SIDE TO MOVE, Operator.LetterOf("wb", (((GAME STARTING COLOR == "w") % 2) + 1)));
    counter to reset repetition table = (((LAST NOT REVERSIBLE MOVE - (full move counter at start (WD) - 1)) - 1) * 2);
    Repeat ((List.Length(GAME POSITION HASH) - counter to reset repetition table))
    {
        counter to reset repetition table += 1;
        List.Add(REPETITION TABLE, GAME POSITION HASH[counter to reset repetition table]);
        List.Add(REPETITION TABLE SIDE TO MOVE, Operator.LetterOf("wb", (((counter to reset repetition table + (GAME STARTING COLOR == "w")) % 2) + 1)));
    }
}

Define reset start data for search (warp=true)
{
    Call initialize engine with max real depth:(30) reset all data?(0);
    List.DeleteAll(Alphas);
    List.DeleteAll(Betas);
    Repeat (30)
    {
        List.Add(Alphas, ALPHA FOR ASPIRATION WINDOW);
        List.Add(Betas, BETA FOR ASPIRATION WINDOW);
    }
    List.DeleteAll(BEST MOVES (LOG));
    List.DeleteAll(BEST MOVES EVAL (LOG));
    List.ReplaceItem(WD_CastlingRights, 2, White CASTLING RIGHTS (DEPTH 0));
    List.ReplaceItem(WD_CastlingRights, 3, WD_CastlingRights[1]);
    # TT Hits = 0;
    # TT Attempt Writes = 0;
    # TT Overwrites = 0;
    # TT Successful Writes = 0;
    num null move pruned = 0;
    num tried null move = 0;
    num futility pruned = 0;
    num delta pruned = 0;
    total nodes: = 0;
    total q-search nodes: = 0;
    quiet nodes evaluated = 0;
    Total Moves Generated = 0;
    evaluated positions (WD) = 0;
    branches pruned (normal search) = 0;
    branches pruned (quiet search) = 0;
    BestMoveTotal#(Profiler) = 0;
    BestMoveIdxSum(Profiler) = 0;
    BestMoveTotal# (q) (profiler) = 0;
    BestMoveIdxSum (q) (profiler) = 0;
    Call evaluation of current position with depth:(((Who To Move? (WD) == "b") * 1)) force HCE:(1) log debug:();
    NUM BLACK PAWNS (UPDATED) = NUM BLACK PAWNS (EVAL);
    NUM WHITE PAWNS (UPDATED) = NUM WHITE PAWNS (EVAL);
    NUM BLACK KNIGHTS (UPDATED) = NUM BLACK KNIGHTS (EVAL);
    NUM WHITE KNIGHTS (UPDATED) = NUM WHITE KNIGHTS (EVAL);
    NUM BLACK BISHOPS (UPDATED) = NUM BLACK BISHOPS (EVAL);
    NUM WHITE BISHOPS (UPDATED) = NUM WHITE BISHOPS (EVAL);
    NUM BLACK ROOKS (UPDATED) = NUM BLACK ROOKS (EVAL);
    NUM WHITE ROOKS (UPDATED) = NUM WHITE ROOKS (EVAL);
    NUM BLACK QUEENS (UPDATED) = NUM BLACK QUEENS (EVAL);
    NUM WHITE QUEENS (UPDATED) = NUM WHITE QUEENS (EVAL);
    WHITE KING ID (UPDATED) = whiteKingID(eval);
    BLACK KING ID (UPDATED) = blackKingID(eval);
    If (search starting depth == 1)
    {
        List.ReplaceItem(OP KING ID AT DEPTH, search starting depth, WHITE KING ID (UPDATED));
        NOT USED ANYMORE - OP KING ID (FROM UPDATED) = WHITE KING ID (UPDATED);
    }
    Else
    {
        List.ReplaceItem(OP KING ID AT DEPTH, search starting depth, BLACK KING ID (UPDATED));
        NOT USED ANYMORE - OP KING ID (FROM UPDATED) = BLACK KING ID (UPDATED);
    }
    NOT PAWN MATERIAL (UPDATED) = (((NUM BLACK KNIGHTS (UPDATED) + NUM WHITE KNIGHTS (UPDATED)) * 320) + (((NUM BLACK BISHOPS (UPDATED) + NUM WHITE BISHOPS (UPDATED)) * 330) + (((NUM BLACK ROOKS (UPDATED) + NUM WHITE ROOKS (UPDATED)) * 500) + ((NUM BLACK QUEENS (UPDATED) + NUM WHITE QUEENS (UPDATED)) * 900))));
    MATERIAL BALANCE AT ROOT = PIECE EVAL (NO PAWNS);
    MATERIAL BALANCE (UPDATED) = MATERIAL BALANCE AT ROOT;
    WD_best move = 0000;
    Call get all legal moves from current position depth:(((CPU COLOR == "w") + 1)) is quiet search?:(0) completely legal?(1) generate checks?("");
    Call move ordering with depth:(((CPU COLOR == "w") + 1)) search this move first:(first search move) include checks in ordering?(1);
    Call reset repetition table;
    TTcurrentAge += 1;
    isSearching? = 1;
    minmax time exhausted? = 0;
    Call get time for search;
}

Define reset white CPU data (warp=true)
{
    List.DeleteAll(MovesDepth 1);
    List.Add(MovesDepth 1, 0000);
    List.ReplaceItem(Moves Count, 1, 1);
    List.ReplaceItem(Alphas, 1, ALPHA FOR ASPIRATION WINDOW);
    List.ReplaceItem(Betas, 1, BETA FOR ASPIRATION WINDOW);
}

Define revert moves with depth:(string depth) manual override:(string manual override) (warp=true)
{
    If (depth == 1)
    {
        If (CPU COLOR == "w")
        {
            Stop(this script);
        }
    }
    og piece on new square for reverting moves = targetPieces[depth];
    If (Not ((manual override == "")))
    {
        current reverting move = manual override;
    }
    Else
    {
        Call get current applying move with depth:(depth);
        current reverting move = current move (computer);
    }
    If (current reverting move > 100)
    {
        start square for reverting move = floor((current reverting move / 100));
        end square for reverting moves = floor((current reverting move % 100));
        Call change incrementally updated num pieces with value:(Current Board Position[end square for reverting moves]) change value by:(-1) square:("");
        Call change incrementally updated num pieces with value:(sourcePiece[depth]) change value by:(1) square:("");
        List.ReplaceItem(Current Board Position, start square for reverting move, sourcePiece[depth]);
        List.ReplaceItem(Current Board Position, end square for reverting moves, og piece on new square for reverting moves);
        start square piece for reverting move = Current Board Position[start square for reverting move];
        If (start square piece for reverting move == 99999)
        {
            WHITE KING ID (UPDATED) = start square for reverting move;
        }
        If (start square piece for reverting move == -99999)
        {
            BLACK KING ID (UPDATED) = start square for reverting move;
        }
        Call change incrementally updated num pieces with value:(og piece on new square for reverting moves) change value by:(1) square:("");
        If (start square piece for reverting move == 100)
        {
            If (end square for reverting moves == WD_EnPassantTarget[depth])
            {
                List.ReplaceItem(Current Board Position, (WD_EnPassantTarget[depth] + 8), -100);
                Call change incrementally updated num pieces with value:(-100) change value by:(1) square:("");
            }
        }
        If (start square piece for reverting move == -100)
        {
            If (end square for reverting moves == WD_EnPassantTarget[depth])
            {
                List.ReplaceItem(Current Board Position, (WD_EnPassantTarget[depth] - 8), 100);
                Call change incrementally updated num pieces with value:(100) change value by:(1) square:("");
            }
        }
        If (depth == 1)
        {
            List.ReplaceItem(WD_CastlingRights, 2, White CASTLING RIGHTS (DEPTH 0));
        }
    }
    Else
    {
        If (current reverting move == BlackKingSideCastle)
        {
            Call apply / revert move castling movement with king:(5) rook idx:(8) empties:(6)(7) multiplier:(-1)() king start:("") rook start:("");
            BLACK KING ID (UPDATED) = 5;
        }
        Else
        {
            If (current reverting move == BlackQueenSideCastle)
            {
                Call apply / revert move castling movement with king:(5) rook idx:(1) empties:(3)(4) multiplier:(-1)() king start:("") rook start:("");
                BLACK KING ID (UPDATED) = 5;
            }
            Else
            {
                If (current reverting move == WhiteKingSideCastle)
                {
                    Call apply / revert move castling movement with king:(61) rook idx:(64) empties:(62)(63) multiplier:(1)() king start:("") rook start:("");
                    WHITE KING ID (UPDATED) = 61;
                }
                Else
                {
                    If (current reverting move == WhiteQueenSideCastle)
                    {
                        Call apply / revert move castling movement with king:(61) rook idx:(57) empties:(59)(60) multiplier:(1)() king start:("") rook start:("");
                        WHITE KING ID (UPDATED) = 61;
                    }
                }
            }
        }
    }
}

Define rook movement with color:(string color) board index:(string board index) depth:(string depth) add to legal move list?:(string add to legal move list?) is quiet search?:(string is quiet search?) (warp=true)
{
    Call get distance to edge with index:(board index) //  MOVE GEN;
    start square for moving pieces = board index;
    color of piece = color;
    moves for sliding pieces direction = -1;
    Repeat (4)
    {
        moves for sliding pieces direction += 2;
        Call loop for sliding pieces inner with depth:(depth) add to legal move list?:(add to legal move list?) is quiet search?(is quiet search?) caller type:("R");
    }
}

Define round eval (for evaluation function) (warp=true)
{
    BOARD EVAL = (Operator.Round((BOARD EVAL * 10)) / 10);
}

Define rule for dataset extractor (warp=true)
{
    If (isEndgame? (for eval) == 1)
    {
        Stop(this script);
    }
    If ((BOARD EVAL > 350) And (PIECE VALUE BONUS TOTAL (EVAL) > 350))
    {
        Stop(this script);
    }
    If ((BOARD EVAL < -350) And (PIECE VALUE BONUS TOTAL (EVAL) < -350))
    {
        Stop(this script);
    }
    If ((NUM BLACK MINOR PIECES (EVAL) + (NUM BLACK MAJOR PIECES (EVAL) + (NUM WHITE MINOR PIECES (EVAL) + NUM WHITE MAJOR PIECES (EVAL)))) < 10)
    {
        Stop(this script);
    }
    If (Black King Shelter Val > 15)
    {
        If (PIECE VALUE BONUS TOTAL (EVAL) < 165)
        {
            List.Add(DATASET EXTRACT OUTPUT, DATASET EXTRACT INPUT[dataset extract with rule idx]);
        }
    }
    If (White King Shelter Val < -15)
    {
        If (PIECE VALUE BONUS TOTAL (EVAL) > -165)
        {
            List.Add(DATASET EXTRACT OUTPUT, DATASET EXTRACT INPUT[dataset extract with rule idx]);
        }
    }
    If ((abs(Black King Shelter Val) + abs(White King Attacked Val)) > 175)
    {
        If (((White King Shelter Val + White King Attacked Val) + (Black King Shelter Val + Black King Attacked Val)) > 0)
        {
            If (PIECE VALUE BONUS TOTAL (EVAL) < 165)
            {
                List.Add(DATASET EXTRACT OUTPUT, DATASET EXTRACT INPUT[dataset extract with rule idx]);
            }
        }
        Else
        {
            If (PIECE VALUE BONUS TOTAL (EVAL) > -165)
            {
                List.Add(DATASET EXTRACT OUTPUT, DATASET EXTRACT INPUT[dataset extract with rule idx]);
            }
        }
    }
}

Define rule of the square for eval with pawn sq:(string pawn sq) promotion sq:(string promotion sq) king sq:(string king sq) king to move?:(string king to move?) chasing king has pieces (not pawns):(string chasing king has pieces?) (warp=true)
{
    pawn can safely promote (for eval) = 0;
    If (isPawnPassed (for eval)? == 1)
    {
        If (chasing king has pieces? == 0)
        {
            If (Chebyshev Distance to Square[((64 * (pawn sq - 1)) + promotion sq)] < (Chebyshev Distance to Square[((64 * (king sq - 1)) + promotion sq)] - king to move?))
            {
                pawn can safely promote (for eval) = 1;
            }
            If (5 < (Chebyshev Distance to Square[((64 * (king sq - 1)) + promotion sq)] - king to move?))
            {
                pawn can safely promote (for eval) = 1;
            }
        }
    }
}

Define save current board state (book finder) (warp=true)
{
    List.DeleteAll(saved board state (book finder));
    Repeat (64)
    {
        List.Add(saved board state (book finder), Current Board Position[(List.Length(saved board state (book finder)) + 1)]);
    }
}

Define scale down board for < minor piece winning eval with val:(string scale down val)(bool white perspective) (eval) (warp=true)
{
    If white perspective
    {
        If (PIECE EVAL (NO PAWNS) > 250)
        {
            BOARD EVAL = Operator.Round((BOARD EVAL * (1 - ((1 - scale down val) / 2))));
        }
        Else
        {
            BOARD EVAL = Operator.Round((BOARD EVAL * scale down val));
        }
    }
    Else
    {
        If (PIECE EVAL (NO PAWNS) < -250)
        {
            BOARD EVAL = Operator.Round((BOARD EVAL * (1 - ((1 - scale down val) / 2))));
        }
        Else
        {
            BOARD EVAL = Operator.Round((BOARD EVAL * scale down val));
        }
    }
}

Define scale down eval value:(string val) (warp=true)
{
    BOARD EVAL = Operator.Round((BOARD EVAL * val));
}

Define scale down less than minor piece advantage endgame with perspective:(bool white perspective?) our pawns:(string our pawns) their pawns:(string their pawns) our passers:(string our passers) their passers:(string their passers) our furthest passer:(string our furthest passer) their furthest passer:(string their furthest passer) (eval) our major pieces:(string our major pieces) our knights:(string our knights) our piece count:(string our piece count) our furthest passer file:(string our furthest passer file) num our bishops:(string num our bishops) our bishop color:(string our bishop color) our furthest passer prom square:(string our furthest passer prom square) their king id:(string their king id) our king id:(string our king id) their king rank:(string their king rank) (warp=true)
{
    If (PIECE MATERIAL (NO PAWNS) (EVAL) > 3000)
    {
        Stop(this script);
    }
    possible to win only up exchange (eval) = 1;
    If (((PIECE EVAL (NO PAWNS) > 50) And white perspective?) Or ((PIECE EVAL (NO PAWNS) < -50) And (Not (white perspective?))))
    {
        Call // comment("We have more non-pawn material, but it's not enough to force a win on it's own");
        If (((PIECE EVAL (NO PAWNS) < 400) And white perspective?) Or ((PIECE EVAL (NO PAWNS) > -400) And (Not (white perspective?))))
        {
            If white perspective?
            {
                If ((PIECE EVAL (NO PAWNS) > 250) And ((NUM BLACK MAJOR PIECES (EVAL) + NUM BLACK MINOR PIECES (EVAL)) == 0))
                {
                    possible to win only up exchange (eval) = 0;
                    If ((our passers > 1) And ((their pawns - our pawns) < 3))
                    {
                        BOARD EVAL += 100;
                    }
                    If ((their pawns - our pawns) > 2)
                    {
                        Call scale down board for < minor piece winning eval with val:(0.5)(white perspective?) (eval);
                        BOARD EVAL += -50;
                    }
                }
            }
            Else
            {
                If ((PIECE EVAL (NO PAWNS) < -250) And ((NUM WHITE MAJOR PIECES (EVAL) + NUM WHITE MINOR PIECES (EVAL)) == 0))
                {
                    possible to win only up exchange (eval) = 0;
                    If ((our passers > 1) And ((their pawns - our pawns) < 3))
                    {
                        BOARD EVAL += -100;
                    }
                    If ((their pawns - our pawns) > 2)
                    {
                        Call scale down board for < minor piece winning eval with val:(0.5)(white perspective?) (eval);
                        BOARD EVAL += 50;
                    }
                }
            }
            Call // comment("check for pawn conditions");
            If (our pawns == 1)
            {
                If ((num our bishops == 1) And (our piece count == 1))
                {
                    If ((our furthest passer file == 1) Or (our furthest passer file == 8))
                    {
                        If (Not ((Square Color[our furthest passer prom square] == our bishop color)))
                        {
                            Call get chebyshev distance from square:(our furthest passer prom square) to square 2:(their king id);
                            their distance from our prom square - poss. to win (eval) = distance from square to square;
                            Call get chebyshev distance from square:(our furthest passer prom square) to square 2:(our king id);
                            If ((their distance from our prom square - poss. to win (eval) < 3) Or (their distance from our prom square - poss. to win (eval) < distance from square to square))
                            {
                                If (Not ((their king rank < our furthest passer)))
                                {
                                    Call scale down eval value:(0.01);
                                    BOARD EVAL += CPU CONTEMPT VALUE;
                                    If (their passers > 1)
                                    {
                                        BOARD EVAL += (-50 * ((white perspective? - 0.5) * 2));
                                    }
                                }
                            }
                        }
                    }
                }
                If ((our knights == 2) And (our piece count == 2))
                {
                    Call scale down board for < minor piece winning eval with val:(0.2)(white perspective?) (eval);
                }
                If ((their pawns - our pawns) > 1)
                {
                    If (our passers == 0)
                    {
                        Call scale down board for < minor piece winning eval with val:(0.35)(white perspective?) (eval);
                    }
                }
                Else
                {
                    If ((their pawns - our pawns) > 1)
                    {
                        Call scale down board for < minor piece winning eval with val:(0.65)(white perspective?) (eval);
                        If ((NUM BLACK QUEENS (EVAL) + NUM WHITE QUEENS (EVAL)) == 2)
                        {
                            Call scale down board for < minor piece winning eval with val:(0.65)(white perspective?) (eval);
                        }
                    }
                }
            }
            Else
            {
                If (our pawns == 2)
                {
                    If ((their pawns - our pawns) > 0)
                    {
                        If ((our passers == 0) And (our furthest passer < 6))
                        {
                            Call scale down board for < minor piece winning eval with val:(0.4)(white perspective?) (eval);
                            If (our furthest passer < 5)
                            {
                                Call scale down board for < minor piece winning eval with val:(0.35)(white perspective?) (eval);
                            }
                        }
                    }
                }
                Else
                {
                    If (our pawns == 0)
                    {
                        If (their pawns > 1)
                        {
                            Call // comment("is we have insufficient material to mate, but they still have pawns, give them a bonus");
                            Call scale down eval value:(0.3);
                            If (our major pieces == 0)
                            {
                                If white perspective?
                                {
                                    BOARD EVAL += -175;
                                }
                                Else
                                {
                                    BOARD EVAL += 175;
                                }
                            }
                            Else
                            {
                                If white perspective?
                                {
                                    BOARD EVAL += -125;
                                }
                                Else
                                {
                                    BOARD EVAL += 125;
                                }
                            }
                        }
                        Else
                        {
                            Call scale down eval value:(0.1);
                            If (their pawns == 0)
                            {
                                Call scale down eval value:(0.25);
                            }
                        }
                        If (our major pieces == 0)
                        {
                            If white perspective?
                            {
                                BOARD EVAL += -100;
                            }
                            Else
                            {
                                BOARD EVAL += 100;
                            }
                        }
                    }
                    Else
                    {
                        If (possible to win only up exchange (eval) == 1)
                        {
                            If (our pawns < their pawns)
                            {
                                If (our pawns < 4)
                                {
                                    Call // comment("is we have insufficient material to mate, but they still have pawns, give them a bonus");
                                    If (our passers == 0)
                                    {
                                        Call scale down board for < minor piece winning eval with val:(0.5)(white perspective?) (eval);
                                        If (our passers > 0)
                                        {
                                            If white perspective?
                                            {
                                                BOARD EVAL += 100;
                                            }
                                            Else
                                            {
                                                BOARD EVAL += -100;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

Define scale down pawn flank endings (warp=true)
{
    If ((abs(PIECE EVAL (NO PAWNS)) > 50) Or (PIECE MATERIAL (NO PAWNS) (EVAL) > 2500))
    {
        Stop(this script);
    }
    If (((most advanced black pawn rank (eval) < 5) And (whiteKingID(eval) < 3)) Or ((most advanced white pawn rank (eval) > 4) And (blackKingID(eval) > 6)))
    {
        Stop(this script);
    }
    If ((num black passers (eval) + num white passers (eval)) == 0)
    {
        Call // comment("at least 2 pawns on the board for this to be valid (KRP vs KR shouldn't be scaled too much)");
        If (abs((NUM BLACK PAWNS (EVAL) - NUM WHITE PAWNS (EVAL))) < 2)
        {
            Call // comment("maximum difference of the pawns is 1");
            If ((NUM WHITE PAWNS (EVAL) > NUM BLACK PAWNS (EVAL)) And (abs((BlackKingFile (eval) - pawn file average (eval))) > 3))
            {
                Stop(this script);
            }
            If ((NUM BLACK PAWNS (EVAL) > NUM WHITE PAWNS (EVAL)) And (abs((WhiteKingFile (eval) - pawn file average (eval))) > 3))
            {
                Stop(this script);
            }
            If (NUM TOTAL PAWNS (EVAL) == 3)
            {
                Call // comment("KRPP vs KRP can be a bit more difficult to hold compared to KRPPP vs KRPP");
                Call scale down eval value:(0.5);
                Stop(this script);
            }
            Else
            {
                If (NUM TOTAL PAWNS (EVAL) == 5)
                {
                    Call // comment("slightly easier to hold compared to 2v1");
                    Call scale down eval value:(0.6);
                    Stop(this script);
                }
                Else
                {
                    If (NUM TOTAL PAWNS (EVAL) < 7)
                    {
                        Call // comment("6 or less total pawns, on same side of board, max diff of 1");
                        Call scale down eval value:(0.3);
                        Stop(this script);
                    }
                    Else
                    {
                        If (NUM TOTAL PAWNS (EVAL) < 9)
                        {
                            Call // comment("8 or less total pawns, on same side of board, max diff of 1");
                            Call scale down eval value:(0.4);
                            Stop(this script);
                        }
                    }
                }
            }
        }
    }
}

Define scale down pawn up late endgame with their most advanced passer rank:(string their most advanced passer rank) their most advanced passer file:(string their most advanced passer file) our king rank:(string our king rank) our king file:(string our king file) their king rank:(string their king rank) (warp=true)
{
    If (their most advanced passer rank > 3)
    {
        Call scale down eval value:(0.3);
    }
    Else
    {
        If (their most advanced passer rank > (our king rank - 1))
        {
            Call scale down eval value:(0.6);
        }
    }
}

Define scale down rook vs minor (eval) (warp=true)
{
    If ((NUM BLACK PAWNS (EVAL) + NUM WHITE PAWNS (EVAL)) == 0)
    {
        If (((NUM WHITE MINOR PIECES (EVAL) == 1) And (NUM WHITE MAJOR PIECES (EVAL) == 0)) And ((NUM BLACK MINOR PIECES (EVAL) == 0) And ((NUM BLACK MAJOR PIECES (EVAL) == 1) And (NUM BLACK ROOKS (EVAL) == 1))))
        {
            Call // comment("KM vs KR (black has more mat.)");
            Call complicated drawn ending scaler helper((1 / 32))(whiteKingID(eval))(kings in opposition res (eval))(-50) (eval);
            Stop(this script);
        }
        If (((NUM BLACK MINOR PIECES (EVAL) == 1) And (NUM BLACK MAJOR PIECES (EVAL) == 0)) And ((NUM WHITE MINOR PIECES (EVAL) == 0) And ((NUM WHITE MAJOR PIECES (EVAL) == 1) And (NUM WHITE ROOKS (EVAL) == 1))))
        {
            Call // comment("KM vs KR (white has more mat.)");
            Call complicated drawn ending scaler helper((1 / 32))(blackKingID(eval))(kings in opposition res (eval))(50) (eval);
            Stop(this script);
        }
        If ((PIECE EVAL (NO PAWNS) < 0) And (PIECE EVAL (NO PAWNS) > -350))
        {
            Call // comment("KM vs KR (black has more mat.)");
            Call complicated drawn ending scaler helper((1 / 16))(whiteKingID(eval))(kings in opposition res (eval))(-50) (eval);
            Stop(this script);
        }
        If ((PIECE EVAL (NO PAWNS) > 0) And (PIECE EVAL (NO PAWNS) < 350))
        {
            Call // comment("KM vs KR (white has more mat.)");
            Call complicated drawn ending scaler helper((1 / 16))(blackKingID(eval))(kings in opposition res (eval))(50) (eval);
            Stop(this script);
        }
        If (abs(PIECE EVAL (NO PAWNS)) < 50)
        {
            Call // comment("Nearly Equal Material");
            If (kings in opposition res (eval) == 1)
            {
                If (WD_distance_to_closest_edge[blackKingID(eval)] == 0)
                {
                    Call complicated drawn ending scaler helper((1 / 16))(blackKingID(eval))(kings in opposition res (eval))(50) (eval);
                }
                If (WD_distance_to_closest_edge[whiteKingID(eval)] == 0)
                {
                    Call complicated drawn ending scaler helper((1 / 16))(whiteKingID(eval))(kings in opposition res (eval))(-50) (eval);
                }
            }
            Else
            {
                Call complicated drawn ending scaler helper((1 / 16))(0)(0)(0) (eval);
            }
            Stop(this script);
        }
    }
}

Define scale rooks with pawns endgame with our pawns:(string our pawns) their pawns:(string their pawns) their most advanced pawn rank:(string their most advanced pawn rank) our king rank:(string our king rank) their king rank:(string their king rank) their most advanced pawn file:(string their most advanced pawn file) our king file:(string our king file) our most advanced pawn rank:(string our most advanced pawn rank) our passers:(string our passers) their passers:(string their passers)(bool white?) (warp=true)
{
    If ((((our pawns == 0) Or ((our pawns == 1) And (our most advanced pawn rank < 6))) Or ((our pawns == their pawns) And (their pawns < 3))) And (their passers < 2))
    {
        If ((their pawns - our pawns) < 2)
        {
            If ((our king rank < their most advanced pawn rank) Or ((their most advanced pawn rank > 2) And (our king rank < (their king rank - 2))))
            {
                If (abs((our king file - their most advanced pawn file)) < 2)
                {
                    Call scale down eval value:(0.1);
                }
                Else
                {
                    If (our king rank < (their king rank - 3))
                    {
                        Call scale down eval value:(0.5);
                        If (abs((our king file - their most advanced pawn file)) < 3)
                        {
                            Call scale down eval value:(0.25);
                        }
                    }
                    Else
                    {
                        If (our king rank < (their king rank - 1))
                        {
                            Call scale down eval value:(0.75);
                            If (abs((our king file - their most advanced pawn file)) < 3)
                            {
                                Call scale down eval value:(0.5);
                            }
                        }
                    }
                }
            }
        }
        Else
        {
            If (their pawns == 2)
            {
                If (our king rank < their most advanced pawn rank)
                {
                    If (our king rank < their king rank)
                    {
                        Call scale down eval value:(0.65);
                    }
                }
            }
        }
    }
    If ((our pawns < 3) And (our passers == 0))
    {
        If (their passers > 0)
        {
            If ((their pawns - our pawns) > 1)
            {
                If (our most advanced pawn rank < 5)
                {
                    If white?
                    {
                        BOARD EVAL += -125;
                    }
                    Else
                    {
                        BOARD EVAL += 125;
                    }
                }
            }
        }
    }
    If ((our pawns == 1) And (their pawns == 1))
    {
        If ((our passers == 1) And (their passers == 1))
        {
            If (abs((our most advanced pawn rank - (9 - their most advanced pawn rank))) < 2)
            {
                If (our most advanced pawn rank < 7)
                {
                    If (their most advanced pawn rank > 2)
                    {
                        Call scale down eval value:(0.65);
                    }
                }
            }
        }
    }
    If ((our pawns == 1) And (their passers > 1))
    {
        If (our most advanced pawn rank < 4)
        {
            If white?
            {
                BOARD EVAL += -125;
            }
            Else
            {
                BOARD EVAL += 125;
            }
        }
    }
}

Define search book (warp=true)
{
    List.DeleteAll(Books Found);
    List.DeleteAll(Books Found Type);
    WD_best move = 0000;
    usedBook = "???";
    If ((CurrentGameCode == "") And (Imported FEN Code: == ""))
    {
        WD_best move = Opening Book First Move[Operator.Random(1 , List.Length(Opening Book First Move))];
        If (CPU COLOR == "w")
        {
            WHITE CPU BEST MOVE = WD_best move;
        }
        usedBook = "[from first moves available]";
        Stop(this script);
    }
    Call WD book finder;
    If (WD_best move > 0000)
    {
        If (CPU COLOR == "w")
        {
            WHITE CPU BEST MOVE = WD_best move;
        }
        usedBook = "[full book search]";
        Stop(this script);
    }
    counter to find correct book move = 0;
    Repeat (List.Length(Neutral Opening Book))
    {
        counter to find correct book move += 1;
        Call limit book length:(Variable.Length(CurrentGameCode)) current line:(Neutral Opening Book[counter to find correct book move]);
        If (Not ((Operator.Join("a", Neutral Opening Book[counter to find correct book move]) == Operator.Join("a", CurrentGameCode))))
        {
            If (Operator.Join("a", limited book line) == Operator.Join("a", CurrentGameCode))
            {
                List.Add(Books Found, counter to find correct book move);
                List.Add(Books Found Type, "neutral");
            }
        }
    }
    If (CPU COLOR == "b")
    {
        counter to find correct book move = 0;
        Repeat (List.Length(Neutral Opening Book))
        {
            counter to find correct book move += 1;
            Call limit book length:(Variable.Length(CurrentGameCode)) current line:(Better for Black Opening Book[counter to find correct book move]);
            If (Not ((Operator.Join("a", Better for Black Opening Book[counter to find correct book move]) == Operator.Join("a", CurrentGameCode))))
            {
                If (Operator.Join("a", limited book line) == Operator.Join("a", CurrentGameCode))
                {
                    List.Add(Books Found, counter to find correct book move);
                    List.Add(Books Found Type, "black");
                }
            }
        }
    }
    If (CPU COLOR == "w")
    {
        counter to find correct book move = 0;
        Repeat (List.Length(Neutral Opening Book))
        {
            counter to find correct book move += 1;
            Call limit book length:(Variable.Length(CurrentGameCode)) current line:(Better for White Opening Book[counter to find correct book move]);
            If (Not ((Operator.Join("a", Better for White Opening Book[counter to find correct book move]) == Operator.Join("a", CurrentGameCode))))
            {
                If (Operator.Join("a", limited book line) == Operator.Join("a", CurrentGameCode))
                {
                    List.Add(Books Found, counter to find correct book move);
                    List.Add(Books Found Type, "white");
                }
            }
        }
    }
    If ((USE NN FOR EVAL? == 1) And (ALLOW BOOK IN NN MODE? == 0))
    {
        Call // comment("don't use opening book for NNUE games to verify performance");
        Call // comment("unless especially allowed");
        List.DeleteAll(Books Found);
    }
    Else
    {
        If ((List.Length(Books Found) > 0) And (loaded custom FEN? == 0))
        {
            Call // comment("found a book");
            usedBookPick = Operator.Random(1 , List.Length(Books Found));
            If (Books Found Type[usedBookPick] == "neutral")
            {
                usedBook = Neutral Opening Book[Books Found[usedBookPick]];
            }
            Else
            {
                If (Books Found Type[usedBookPick] == "black")
                {
                    usedBook = Better for Black Opening Book[Books Found[usedBookPick]];
                }
                Else
                {
                    usedBook = Better for White Opening Book[Books Found[usedBookPick]];
                }
            }
            length of current game code = Variable.Length(CurrentGameCode);
            WD_best move = Operator.Join(Operator.LetterOf(usedBook, (length of current game code + 1)), Operator.Join(Operator.LetterOf(usedBook, (length of current game code + 2)), Operator.Join(Operator.LetterOf(usedBook, (length of current game code + 3)), Operator.LetterOf(usedBook, (length of current game code + 4)))));
            If (CPU COLOR == "w")
            {
                WHITE CPU BEST MOVE = WD_best move;
            }
        }
    }
}

Define search extensions with depth:(string depth) num extensions:(string numExtensions) (warp=true)
{
    searchExtension = 0;
    If (depth < search starting depth)
    {
        Stop(this script);
    }
    If (depth < (iterative deepening Idx * 2))
    {
        If (SE extension res == 1)
        {
            searchExtension += 1;
        }
        If (Move Type (applying moves)[depth] == "capture")
        {
            If (abs(targetPieces[depth]) > 100)
            {
                If (NOT PAWN MATERIAL (UPDATED) == 0)
                {
                    Call // comment("Transition to pawn endgame");
                    If (numExtensions < 2)
                    {
                        If is compiled?
                        {
                            searchExtension += 2;
                        }
                        Else
                        {
                            searchExtension += 1;
                        }
                        Stop(this script);
                    }
                }
                Else
                {
                    If (NOT PAWN MATERIAL (UPDATED) < 1050)
                    {
                        Call // comment("Transition to simple endgame");
                        If (numExtensions < 1)
                        {
                            If is compiled?
                            {
                                searchExtension += 2;
                            }
                            Else
                            {
                                searchExtension += 1;
                            }
                            Stop(this script);
                        }
                    }
                }
            }
        }
        If (Moves Count[depth] == 1)
        {
            Call // comment("if you only have one move, it's a very forcing sequence, and it is useful to know what happens");
            If (numExtensions < 7)
            {
                searchExtension += 2;
                Stop(this script);
            }
        }
        If (Moves Count[depth] == 2)
        {
            Call // comment("if you only have one move, it's a very forcing sequence, and it is useful to know what happens");
            If (numExtensions < 3)
            {
                searchExtension += 1;
                Stop(this script);
            }
        }
        If (PutsInCheck?[depth] == 1)
        {
            If (numExtensions < 2)
            {
                Call // comment("extend if giving check, as it's a forcing sequence");
                searchExtension += 1;
                Stop(this script);
            }
        }
        If (Current Board Position[end square for applying moves] == 100)
        {
            Call // comment("pawn rank extensions");
            If (end square for applying moves < 17)
            {
                If (numExtensions < 7)
                {
                    searchExtension += 1;
                    Stop(this script);
                }
            }
            If (end square for applying moves < 25)
            {
                If (numExtensions < 1)
                {
                    searchExtension += 1;
                    Stop(this script);
                }
            }
        }
        If (Current Board Position[end square for applying moves] == -100)
        {
            Call // comment("pawn rank extensions");
            If (end square for applying moves > 48)
            {
                If (numExtensions < 7)
                {
                    searchExtension += 1;
                    Stop(this script);
                }
            }
            If (end square for applying moves > 40)
            {
                If (numExtensions < 1)
                {
                    searchExtension += 1;
                    Stop(this script);
                }
            }
        }
        If (Move Type (applying moves)[(depth - 1)] == "capture")
        {
            Call // comment("recapture extension");
            If (abs(targetPieces[depth]) > 0)
            {
                If (end square for applying moves == floor((Moves Played In Search[(depth - 1)] % 100)))
                {
                    If (abs((MATERIAL BALANCE (UPDATED) - MATERIAL BALANCE AT ROOT)) < 300)
                    {
                        If (numExtensions < 3)
                        {
                            searchExtension += 1;
                            Stop(this script);
                        }
                    }
                }
            }
        }
    }
}

Define search for iterative deepening with depth:(string depth) max depth:(string max depth) quiet search rounds:(string quiet search rounds) (warp=true)
{
    isIterativeDeepening? = 1;
    Call reset start data for search;
    If (CPU COLOR == "w")
    {
        Call reset white CPU data;
    }
    Call WD_NNUE reset accumulator info;
    Depth of Search = Operator.Join(max depth, Operator.Join("+", quiet search rounds));
    Call minmax depth:(depth) max depth:(max depth) rounds of quiet search?(quiet search rounds) numExtensions:(0) num SE:("");
}

Define set progress bar with depth:(string depth) (warp=true)
{
    Call set progress with a:((ceiling((((Sensing.DaysSince2000() - start time for search) * 86400) * 10)) / 10)) over b:((Operator.Round((TARGET THINK TIME * 10)) / 10));
}

Define set progress with a:(string a) over b:(string b) (warp=true)
{
    LOADING A = a;
    LOADING B = b;
    LOADING PERCENTAGE = Operator.Join(Operator.Join(a, "/"), b);
    Event.Broadcast("update progress bar internal");
    Control.Wait(0);
}

Define should futility prune move at depth(string depth) (warp=true)
{
    should futility prune? = 1;
    If ((Not ((Is Futility Pruned?[depth] == 1))) Or ((Not ((move type (for applying moves) == "quiet"))) Or ((Moves Index[depth] == 1) Or ((PutsInCheck?[depth] == 1) Or ((StartsInCheck?[depth] == 1) Or (Large Positional in Static Eval at Depth[depth] == 1))))))
    {
        should futility prune? = 0;
        Stop(this script);
    }
}

Define sigmoid function with x:(string x) (warp=true)
{
    sigmoidFuncRes = (1 / (1 + e ^((-1 * x))));
}

Define special bishop eval (warp=true)
{
    bishop color (eval) = Square Color[counter for evaluation];
    bishop on long diagonal (eval) = (1 * ((file from square index == rank from square index) Or (file from square index == (9 - rank from square index))));
    Call get mobility in direction delta rank:(1) delta file:(1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((1 == 1)) ignore rooks:() white perspective:((mobility stop pawn color (eval) == -1)) source is queen?();
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(1) delta file:(-1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((1 == 1)) ignore rooks:() white perspective:((mobility stop pawn color (eval) == -1)) source is queen?();
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(-1) delta file:(1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((1 == 1)) ignore rooks:() white perspective:((mobility stop pawn color (eval) == -1)) source is queen?();
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(-1) delta file:(-1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((1 == 1)) ignore rooks:() white perspective:((mobility stop pawn color (eval) == -1)) source is queen?();
    piece mobility counter (eval) += mobility in direction res;
    If (mobility slider on queen counter (eval) > 1)
    {
        mobility slider on queen counter (eval) = 1;
    }
    If (current piece (eval) == 330)
    {
        Call get chebyshev distance from square:(counter for evaluation) to square 2:(whiteKingID(eval));
        king protector eg (eval) += (-4.5 * distance from square to square);
        king protector mg (eval) += (-3 * distance from square to square);
        If (piece is attacker? (eval) == 0)
        {
            If (mobility check attacks their king ring (eval) > 0)
            {
                Call add piece as black king attacker with force:(35) (eval);
            }
        }
        If ((bishop on long diagonal (eval) == 1) And ((file from square index > 5) Or (file from square index < 4)))
        {
            If (bishop color (eval) == "light")
            {
                If ((Not ((Current Board Position[46] == 100))) And ((Not ((Current Board Position[37] == 100))) And ((Not ((Current Board Position[55] == 100))) Or (rank from square index > 1))))
                {
                    Call change board eval with mg term:(25) eg term:(0);
                }
            }
            Else
            {
                If ((Not ((Current Board Position[43] == 100))) And ((Not ((Current Board Position[36] == 100))) And ((Not ((Current Board Position[50] == 100))) Or (rank from square index > 1))))
                {
                    Call change board eval with mg term:(25) eg term:(0);
                }
            }
        }
        Call is piece pinned (eval)((1 == 1));
        If (piece is pinned res (eval) > 0)
        {
            piece mobility counter (eval) = floor((piece mobility counter (eval) / 12));
            mobility minor threat mg (eval) = floor((mobility minor threat mg (eval) / 12));
            mobility minor threat eg (eval) = floor((mobility minor threat eg (eval) / 12));
        }
        Call change board eval with mg term:(mobility minor threat mg (eval)) eg term:(mobility minor threat eg (eval));
        MOBILITY eg (eval) += __Bishop Mobility Bonus End[(piece mobility counter (eval) + 1)];
        MOBILITY mg (eval) += __Bishop Mobility Bonus[(piece mobility counter (eval) + 1)];
        If (bishop color (eval) == "light")
        {
            bishop colored pawns temp (eval) = num light pawns WHITE (eval);
        }
        Else
        {
            bishop colored pawns temp (eval) = num dark pawns WHITE (eval);
        }
        If (White Pawn Attacks Square (eval)[counter for evaluation] > 0)
        {
            bishop pawns malus temp (eval) = (-1 * (bishop colored pawns temp (eval) * num fully blocked center pawns white (eval)));
        }
        Else
        {
            bishop pawns malus temp (eval) = (-1 * (bishop colored pawns temp (eval) * (num fully blocked center pawns white (eval) + 1)));
        }
        Call change board eval with mg term:((bishop pawns malus temp (eval) * 1.5)) eg term:((bishop pawns malus temp (eval) * 3.5));
        If (counter for evaluation == 9)
        {
            If (Current Board Position[18] == -100)
            {
                BOARD EVAL += -125;
            }
        }
        If (counter for evaluation == 16)
        {
            If (Current Board Position[23] == -100)
            {
                BOARD EVAL += -125;
            }
        }
        Stop(this script);
    }
    If (current piece (eval) == -330)
    {
        Call get chebyshev distance from square:(counter for evaluation) to square 2:(blackKingID(eval));
        king protector eg (eval) += (4.5 * distance from square to square);
        king protector mg (eval) += (3 * distance from square to square);
        If (piece is attacker? (eval) == 0)
        {
            If (mobility check attacks their king ring (eval) > 0)
            {
                Call add piece as white king attacker with force:(35) (eval);
            }
        }
        If ((bishop on long diagonal (eval) == 1) And ((file from square index > 5) Or (file from square index < 4)))
        {
            If (bishop color (eval) == "dark")
            {
                If ((Not ((Current Board Position[22] == -100))) And ((Not ((Current Board Position[29] == -100))) And ((Not ((Current Board Position[15] == -100))) Or (rank from square index < 8))))
                {
                    Call change board eval with mg term:(-25) eg term:(0);
                }
            }
            Else
            {
                If ((Not ((Current Board Position[19] == -100))) And ((Not ((Current Board Position[28] == -100))) And ((Not ((Current Board Position[10] == -100))) Or (rank from square index < 8))))
                {
                    Call change board eval with mg term:(-25) eg term:(0);
                }
            }
        }
        Call is piece pinned (eval)((0 == 1));
        If (piece is pinned res (eval) > 0)
        {
            piece mobility counter (eval) = floor((piece mobility counter (eval) / 12));
            mobility minor threat mg (eval) = floor((mobility minor threat mg (eval) / 12));
            mobility minor threat eg (eval) = floor((mobility minor threat eg (eval) / 12));
        }
        Call change board eval with mg term:((mobility minor threat mg (eval) * -1)) eg term:((mobility minor threat eg (eval) * -1));
        MOBILITY eg (eval) += (0 - __Bishop Mobility Bonus End[(piece mobility counter (eval) + 1)]);
        MOBILITY mg (eval) += (0 - __Bishop Mobility Bonus[(piece mobility counter (eval) + 1)]);
        If (bishop color (eval) == "light")
        {
            bishop colored pawns temp (eval) = num light pawns BLACK (eval);
        }
        Else
        {
            bishop colored pawns temp (eval) = num dark pawns BLACK (eval);
        }
        If (Black Pawn Attacks Square (eval)[counter for evaluation] > 0)
        {
            bishop pawns malus temp (eval) = (1 * (bishop colored pawns temp (eval) * num fully blocked center pawns black (eval)));
        }
        Else
        {
            bishop pawns malus temp (eval) = (1 * (bishop colored pawns temp (eval) * (num fully blocked center pawns black (eval) + 1)));
        }
        Call change board eval with mg term:((bishop pawns malus temp (eval) * 1.5)) eg term:((bishop pawns malus temp (eval) * 3.5));
        If (counter for evaluation == 49)
        {
            If (Current Board Position[42] == 100)
            {
                BOARD EVAL += 125;
            }
        }
        If (counter for evaluation == 56)
        {
            If (Current Board Position[47] == 100)
            {
                BOARD EVAL += 125;
            }
        }
        Stop(this script);
    }
}

Define special knight eval (warp=true)
{
    knight reachable outposts (eval) = 0;
    knight attacks rook (eval) = 0;
    knight attacks queen (eval) = 0;
    knight attacks weak piece (eval) = 0;
    knight attacks their king ring (eval) = 0;
    knight is king defender (eval) = 0;
    Call check knight mobility with delta rank:(2) delta file:(1) white perspective?:((mobility stop pawn color (eval) == -1));
    piece mobility counter (eval) += mobility in direction res;
    Call check knight mobility with delta rank:(2) delta file:(-1) white perspective?:((mobility stop pawn color (eval) == -1));
    piece mobility counter (eval) += mobility in direction res;
    Call check knight mobility with delta rank:(-2) delta file:(1) white perspective?:((mobility stop pawn color (eval) == -1));
    piece mobility counter (eval) += mobility in direction res;
    Call check knight mobility with delta rank:(-2) delta file:(-1) white perspective?:((mobility stop pawn color (eval) == -1));
    piece mobility counter (eval) += mobility in direction res;
    Call check knight mobility with delta rank:(1) delta file:(2) white perspective?:((mobility stop pawn color (eval) == -1));
    piece mobility counter (eval) += mobility in direction res;
    Call check knight mobility with delta rank:(1) delta file:(-2) white perspective?:((mobility stop pawn color (eval) == -1));
    piece mobility counter (eval) += mobility in direction res;
    Call check knight mobility with delta rank:(-1) delta file:(2) white perspective?:((mobility stop pawn color (eval) == -1));
    piece mobility counter (eval) += mobility in direction res;
    Call check knight mobility with delta rank:(-1) delta file:(-2) white perspective?:((mobility stop pawn color (eval) == -1));
    piece mobility counter (eval) += mobility in direction res;
    If (current piece (eval) == 320)
    {
        Call get chebyshev distance from square:(counter for evaluation) to square 2:(whiteKingID(eval));
        king protector eg (eval) += (-4.5 * distance from square to square);
        king protector mg (eval) += (-4 * distance from square to square);
        Call is square outpost?(counter for evaluation)((1 == 1)) (eval);
        Call change board eval with mg term:((26 * (is square outpost res (eval) + (knight reachable outposts (eval) * 0.5)))) eg term:((18 * (is square outpost res (eval) + (knight reachable outposts (eval) * 0.5))));
        If (knight attacks their king ring (eval) > 0)
        {
            Call add piece as black king attacker with force:(75) (eval);
        }
        Call is piece pinned (eval)((1 == 1));
        If (piece is pinned res (eval) > 0)
        {
            piece mobility counter (eval) = 0;
            If (knight is king defender (eval) == 1)
            {
                knight is king defender (eval) = 0;
                num white king knight defenders (eval) += -1;
            }
        }
        MOBILITY mg (eval) += __Knight Mobility Bonus[(piece mobility counter (eval) + 1)];
        MOBILITY eg (eval) += __Knight Mobility Bonus End[(piece mobility counter (eval) + 1)];
        Call change board eval with mg term:((35 * (knight attacks rook (eval) + knight attacks queen (eval)))) eg term:((20 * (knight attacks rook (eval) + knight attacks queen (eval))));
        If (counter for evaluation == 43)
        {
            If (Current Board Position[51] == 100)
            {
                If (Current Board Position[36] == 100)
                {
                    If (Current Board Position[28] == -100)
                    {
                        If (Not ((Current Board Position[37] == 100)))
                        {
                            Call change board eval with mg term:(-15) eg term:(-5);
                        }
                    }
                }
            }
        }
        If (rank from square index > 7)
        {
            Call // comment("somewhat trapped knight");
            Call get chebyshev distance from square:(counter for evaluation) to square 2:(blackKingID(eval));
            If (distance from square to square < 3)
            {
                Call change board eval with mg term:(-15) eg term:(-20);
            }
        }
        Stop(this script);
    }
    If (current piece (eval) == -320)
    {
        Call get chebyshev distance from square:(counter for evaluation) to square 2:(blackKingID(eval));
        king protector eg (eval) += (4.5 * distance from square to square);
        king protector mg (eval) += (4 * distance from square to square);
        Call is square outpost?(counter for evaluation)((0 == 1)) (eval);
        Call change board eval with mg term:((-26 * (is square outpost res (eval) + (knight reachable outposts (eval) * 0.5)))) eg term:((-18 * (is square outpost res (eval) + (knight reachable outposts (eval) * 0.5))));
        If (knight attacks their king ring (eval) > 0)
        {
            Call add piece as white king attacker with force:(75) (eval);
        }
        Call is piece pinned (eval)((0 == 1));
        If (piece is pinned res (eval) > 0)
        {
            piece mobility counter (eval) = 0;
            If (knight is king defender (eval) == 1)
            {
                knight is king defender (eval) = 0;
                num black king knight defenders (eval) += -1;
            }
        }
        MOBILITY mg (eval) += (0 - __Knight Mobility Bonus[(piece mobility counter (eval) + 1)]);
        MOBILITY eg (eval) += (0 - __Knight Mobility Bonus End[(piece mobility counter (eval) + 1)]);
        Call change board eval with mg term:((-35 * (knight attacks rook (eval) + knight attacks queen (eval)))) eg term:((-20 * (knight attacks rook (eval) + knight attacks queen (eval))));
        If (counter for evaluation == 19)
        {
            If (Current Board Position[11] == -100)
            {
                If (Current Board Position[28] == -100)
                {
                    If (Current Board Position[36] == 100)
                    {
                        If (Not ((Current Board Position[29] == -100)))
                        {
                            Call change board eval with mg term:(15) eg term:(5);
                        }
                    }
                }
            }
        }
        If (rank from square index < 2)
        {
            Call // comment("somewhat trapped knight");
            Call get chebyshev distance from square:(counter for evaluation) to square 2:(whiteKingID(eval));
            If (distance from square to square < 3)
            {
                Call change board eval with mg term:(15) eg term:(20);
            }
        }
        Stop(this script);
    }
}

Define special no LMR conditions with depth:(string depth) move type:(string move type) (warp=true)
{
    specialNoLmrCond Res = 0;
    If (Not ((move type == "quiet")))
    {
        specialNoLmrCond Res = 1;
        Stop(this script);
    }
    If (sourcePiece[depth] == -100)
    {
        If ((Current Board Position[(end square for applying moves + 7)] > 100) And (Current Board Position[(end square for applying moves + 9)] > 100))
        {
            Call // comment("black pawn fork");
            Call get rank and file from square index:(end square for applying moves);
            If ((file from square index > 1) And (file from square index < 8))
            {
                specialNoLmrCond Res = 1;
                Stop(this script);
            }
        }
        If (end square for applying moves > 32)
        {
            Call // comment("past 4th rank");
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
    }
    If (sourcePiece[depth] == 100)
    {
        Call // comment("white pawn fork");
        If ((Current Board Position[(end square for applying moves - 7)] < -100) And (Current Board Position[(end square for applying moves - 9)] < -100))
        {
            If ((Not ((Current Board Position[(end square for applying moves - 7)] == ""))) And (Not ((Current Board Position[(end square for applying moves - 9)] == ""))))
            {
                Call get rank and file from square index:(end square for applying moves);
                If ((file from square index > 1) And (file from square index < 8))
                {
                    specialNoLmrCond Res = 1;
                    Stop(this script);
                }
            }
            If (end square for applying moves < 33)
            {
                Call // comment("past 4th rank");
                specialNoLmrCond Res = 1;
                Stop(this script);
            }
        }
    }
    If (sourcePiece[depth] == 330)
    {
        Call get square idx of init square:(end square for applying moves) delta rank:(1) delta file:(1);
        If ((square with delta rank and file res > 0) And (Current Board Position[square with delta rank and file res] == 900))
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
        Call get square idx of init square:(end square for applying moves) delta rank:(1) delta file:(-1);
        If ((square with delta rank and file res > 0) And (Current Board Position[square with delta rank and file res] == 900))
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
        Call get square idx of init square:(end square for applying moves) delta rank:(-1) delta file:(1);
        If ((square with delta rank and file res > 0) And (Current Board Position[square with delta rank and file res] == 900))
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
        Call get square idx of init square:(end square for applying moves) delta rank:(-1) delta file:(-1);
        If ((square with delta rank and file res > 0) And (Current Board Position[square with delta rank and file res] == 900))
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
    }
    If (sourcePiece[depth] == -330)
    {
        Call get square idx of init square:(end square for applying moves) delta rank:(1) delta file:(1);
        If ((square with delta rank and file res > 0) And (Current Board Position[square with delta rank and file res] == -900))
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
        Call get square idx of init square:(end square for applying moves) delta rank:(1) delta file:(-1);
        If ((square with delta rank and file res > 0) And (Current Board Position[square with delta rank and file res] == -900))
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
        Call get square idx of init square:(end square for applying moves) delta rank:(-1) delta file:(1);
        If ((square with delta rank and file res > 0) And (Current Board Position[square with delta rank and file res] == -900))
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
        Call get square idx of init square:(end square for applying moves) delta rank:(-1) delta file:(-1);
        If ((square with delta rank and file res > 0) And (Current Board Position[square with delta rank and file res] == -900))
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
    }
    If (abs(sourcePiece[depth]) == 99999)
    {
        If (NOT PAWN MATERIAL (UPDATED) < 800)
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
    }
    If (sourcePiece[depth] == 900)
    {
        Call get rank and file from square idx:(BLACK KING ID (UPDATED)) background function;
        Call get rank and file from square index:(end square for applying moves);
        If (abs((file from square index - file from square idx background)) < 2)
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
    }
    If (sourcePiece[depth] == -900)
    {
        Call get rank and file from square idx:(WHITE KING ID (UPDATED)) background function;
        Call get rank and file from square index:(end square for applying moves);
        If (abs((file from square index - file from square idx background)) < 2)
        {
            specialNoLmrCond Res = 1;
            Stop(this script);
        }
    }
}

Define special pawn eval (for eval) with idx:(string idx) depth:(string depth) (warp=true)
{
    isPawnPhalanx (eval) = 0;
    isPawnSupported (eval) = 0;
    isPawnPassed (for eval)? = 0;
    isRearDoubledPawn? (for eval) = 0;
    isPawnBackwards (eval) = 0;
    isPawnIsolated (eval) = 0;
    Call get rank and file from square index:(idx);
    If (current piece (eval) == 100)
    {
        Call // comment("WHITE PAWN");
        isPawnOpposed? (eval) = (1 * (rank from square index < Least Advanced Black Pawn[file from square index]));
        If (Most Advanced White Pawn[file from square index] == rank from square index)
        {
            Call is pawn passed? (eval);
            If (isPawnPassed (for eval)? == 1)
            {
                Call // comment("passed pawn");
                isPawnPassed (for eval)? = 1;
                num white passers (eval) += 1;
                List.ReplaceItem(White Passers on File (eval), file from square index, (White Passers on File (eval)[file from square index] + 1));
                Call change board eval with mg term:(_Passed Pawn Bonus[(9 - rank from square index)]) eg term:(_Endgame Passed Pawn Bonus[(9 - rank from square index)]);
                Call get passed file with(file from square index) (for eval);
                Call change board eval with mg term:((-6 * passed file res (eval))) eg term:((-4 * passed file res (eval)));
                If (((file from square index == 1) Or (file from square index == 8)) And (isEndgame? (for eval) == 1))
                {
                    BOARD EVAL += 15;
                }
                If (PIECE MATERIAL (NO PAWNS) (EVAL) == 0)
                {
                    Call // comment("passed pawns are super important in pawn endgames (being up just one passer can change a lot)");
                    If ((file from square index == 1) Or (file from square index == 8))
                    {
                        num white outside passers (eval) += 135;
                    }
                    BOARD EVAL += 50;
                    If (Not ((rank from square index < BlackKingRank (eval))))
                    {
                        BOARD EVAL += 50;
                    }
                }
                Call get chebyshev distance from square:((counter for evaluation - 8)) to square 2:(whiteKingID(eval));
                If (distance from square to square == 1)
                {
                    If (rank from square index == 7)
                    {
                        BOARD EVAL += 145;
                    }
                    If (rank from square index == 6)
                    {
                        BOARD EVAL += 105;
                    }
                    If (rank from square index == 5)
                    {
                        BOARD EVAL += 55;
                    }
                }
            }
        }
        Else
        {
            Call // comment("rear doubled pawn");
            isRearDoubledPawn? (for eval) = 1;
        }
        If ((Current Board Position[(counter for evaluation + 8)] == 100) And (White Pawn Attacks Square (eval)[counter for evaluation] == 0))
        {
            Call // comment("doubled pawn");
            Call change board eval with mg term:(-6) eg term:(-28);
            If (PIECE MATERIAL (NO PAWNS) (EVAL) == 0)
            {
                BOARD EVAL += -20;
            }
        }
        If (((Least Advanced White Pawn[(file from square index - 1)] > rank from square index) Or (file from square index == 1)) And ((Least Advanced White Pawn[(file from square index + 1)] > rank from square index) Or (file from square index == 8)))
        {
            Call // comment("backwards pawn");
            If (rank from square index < 7)
            {
                If (Current Board Position[(counter for evaluation - 8)] == -100)
                {
                    isPawnBackwards (eval) = 1;
                }
                If (rank from square index < 6)
                {
                    If ((Current Board Position[(counter for evaluation - 15)] == -100) And (file from square index < 8))
                    {
                        isPawnBackwards (eval) = 1;
                    }
                    If ((Current Board Position[(counter for evaluation - 17)] == -100) And (file from square index > 1))
                    {
                        isPawnBackwards (eval) = 1;
                    }
                }
            }
        }
        If (((Least Advanced White Pawn[(file from square index - 1)] == 999) Or (file from square index == 1)) And ((Least Advanced White Pawn[(file from square index + 1)] == 999) Or (file from square index == 8)))
        {
            Call // comment("isolated pawn");
            isPawnIsolated (eval) = 1;
        }
        Else
        {
            If (((Current Board Position[(counter for evaluation - 1)] == 100) And (file from square index > 1)) Or ((Current Board Position[(counter for evaluation + 1)] == 100) And (file from square index < 8)))
            {
                Call // comment("connected (side by side)");
                isPawnPhalanx (eval) = 1;
            }
            If (((Current Board Position[(counter for evaluation + 7)] == 100) And (file from square index > 1)) Or ((Current Board Position[(counter for evaluation + 9)] == 100) And (file from square index < 8)))
            {
                Call // comment("connected (chain)");
                isPawnSupported (eval) = 1;
            }
        }
        If ((isPawnIsolated (eval) == 1) And (isRearDoubledPawn? (for eval) == 1))
        {
            Call change board eval with mg term:(-12.5) eg term:(-28);
            If (PIECE MATERIAL (NO PAWNS) (EVAL) == 0)
            {
                BOARD EVAL += -35;
            }
        }
        Else
        {
            If (isPawnIsolated (eval) == 1)
            {
                Call change board eval with mg term:(-2.5) eg term:(-7.5);
            }
            Else
            {
                If (isPawnBackwards (eval) == 1)
                {
                    Call change board eval with mg term:(-4) eg term:(-12);
                }
            }
        }
        If ((isPawnPhalanx (eval) + isPawnSupported (eval)) > 0)
        {
            Call change board eval with mg term:(((ConnectedPawnBonus[rank from square index] * ((2 + isPawnPhalanx (eval)) - isPawnOpposed? (eval))) + (10 * isPawnSupported (eval)))) eg term:((((rank from square index - 3) / 4) * ((ConnectedPawnBonus[rank from square index] * ((2 + isPawnPhalanx (eval)) - isPawnOpposed? (eval))) + (10 * isPawnSupported (eval)))));
        }
        If ((rank from square index == 5) Or (rank from square index == 6))
        {
            If (Current Board Position[(counter for evaluation - 8)] == -100)
            {
                BOARD EVAL += -4.5;
            }
        }
        If (most advanced black pawn rank (eval) > 2)
        {
            Call rule of the square for eval with pawn sq:(idx) promotion sq:(Operator.Round(((idx - 0.1) % 8))) king sq:(blackKingID(eval)) king to move?:((1 * ((depth % 2) == 1))) chasing king has pieces (not pawns):((1 * ((NUM BLACK MINOR PIECES (EVAL) + NUM BLACK MAJOR PIECES (EVAL)) > 0)));
            If (pawn can safely promote (for eval) == 1)
            {
                BOARD EVAL += 1200;
            }
        }
        If (Least Advanced Black Pawn[file from square index] < (rank from square index + 1))
        {
            If ((isPawnBackwards (eval) + isPawnIsolated (eval)) > 0)
            {
                Call // comment("weak unopposed pawn (stockfish idea)");
                Call change board eval with mg term:(-6) eg term:(-12.5);
            }
        }
        If ((Current Board Position[(idx + 8)] == 320) Or (Current Board Position[(idx + 8)] == 330))
        {
            Call change board eval with mg term:(9) eg term:(2);
        }
        If (rank from square index == 2)
        {
            If (Current Board Position[(idx - 8)] == 330)
            {
                Call change board eval with mg term:(-9) eg term:(-2);
            }
        }
        If ((Current Board Position[(idx - 8)] == 320) Or (Current Board Position[(idx - 8)] == 330))
        {
            If ((file from square index > 3) And (file from square index < 6))
            {
                If (rank from square index < 4)
                {
                    Call change board eval with mg term:(-12) eg term:(-3.5);
                }
            }
        }
        If (file from square index < 8)
        {
            List.ReplaceItem(num white attacks on square (eval), (idx - 7), (num white attacks on square (eval)[(idx - 7)] + 1));
            Call try to add flank attack black king with square:((idx - 9));
        }
        If (file from square index > 1)
        {
            List.ReplaceItem(num white attacks on square (eval), (idx - 9), (num white attacks on square (eval)[(idx - 9)] + 1));
            Call try to add flank attack black king with square:((idx - 9));
        }
        Stop(this script);
    }
    If (current piece (eval) == -100)
    {
        Call // comment("BLACK PAWN");
        isPawnOpposed? (eval) = (1 * (rank from square index > Least Advanced White Pawn[file from square index]));
        If (Most Advanced Black Pawn[file from square index] == rank from square index)
        {
            Call is pawn passed? (eval);
            If (isPawnPassed (for eval)? == 1)
            {
                Call // comment("passed pawn");
                isPawnPassed (for eval)? = 1;
                num black passers (eval) += 1;
                List.ReplaceItem(Black Passers on File (eval), file from square index, (Black Passers on File (eval)[file from square index] + 1));
                Call change board eval with mg term:((-1 * _Passed Pawn Bonus[rank from square index])) eg term:((-1 * _Endgame Passed Pawn Bonus[rank from square index]));
                Call get passed file with(file from square index) (for eval);
                Call change board eval with mg term:((6 * passed file res (eval))) eg term:((4 * passed file res (eval)));
                If (((file from square index == 1) Or (file from square index == 8)) And (isEndgame? (for eval) == 1))
                {
                    BOARD EVAL += -15;
                }
                If (PIECE MATERIAL (NO PAWNS) (EVAL) == 0)
                {
                    Call // comment("passers are super important in pawn endgames");
                    If ((file from square index == 1) Or (file from square index == 8))
                    {
                        num black outside passers (eval) += 1;
                    }
                    BOARD EVAL += -50;
                    If (Not ((rank from square index > WhiteKingRank (eval))))
                    {
                        BOARD EVAL += -50;
                    }
                }
                Call get chebyshev distance from square:((counter for evaluation + 8)) to square 2:(blackKingID(eval));
                If (distance from square to square == 1)
                {
                    If (rank from square index == 2)
                    {
                        BOARD EVAL += -145;
                    }
                    If (rank from square index == 3)
                    {
                        BOARD EVAL += -105;
                    }
                    If (rank from square index == 4)
                    {
                        BOARD EVAL += -55;
                    }
                }
            }
        }
        Else
        {
            Call // comment("rear doubled pawn");
            isRearDoubledPawn? (for eval) = 1;
        }
        If ((Current Board Position[(counter for evaluation - 8)] == -100) And (Black Pawn Attacks Square (eval)[counter for evaluation] == 0))
        {
            Call // comment("doubled pawn");
            Call change board eval with mg term:(6) eg term:(26);
            If (PIECE MATERIAL (NO PAWNS) (EVAL) == 0)
            {
                BOARD EVAL += 20;
            }
        }
        If (((Least Advanced Black Pawn[(file from square index - 1)] < rank from square index) Or (file from square index == 1)) And ((Least Advanced Black Pawn[(file from square index + 1)] < rank from square index) Or (file from square index == 8)))
        {
            Call // comment("backwards pawn");
            If (rank from square index > 2)
            {
                If (Current Board Position[(counter for evaluation + 8)] == 100)
                {
                    isPawnBackwards (eval) = 1;
                }
                If (rank from square index > 3)
                {
                    If ((Current Board Position[(counter for evaluation + 17)] == 100) And (file from square index < 8))
                    {
                        isPawnBackwards (eval) = 1;
                    }
                    If ((Current Board Position[(counter for evaluation + 15)] == 100) And (file from square index > 1))
                    {
                        isPawnBackwards (eval) = 1;
                    }
                }
            }
        }
        If (((Most Advanced Black Pawn[(file from square index - 1)] == 999) Or (file from square index == 1)) And ((Most Advanced Black Pawn[(file from square index + 1)] == 999) Or (file from square index == 8)))
        {
            Call // comment("isolated pawn");
            isPawnIsolated (eval) = 1;
        }
        Else
        {
            If (((Current Board Position[(counter for evaluation - 1)] == -100) And (file from square index > 1)) Or ((Current Board Position[(counter for evaluation + 1)] == -100) And (file from square index < 8)))
            {
                Call // comment("connected (side by side)");
                isPawnPhalanx (eval) = 1;
            }
            If (((Current Board Position[(counter for evaluation - 9)] == -100) And (file from square index > 1)) Or ((Current Board Position[(counter for evaluation - 7)] == -100) And (file from square index < 8)))
            {
                Call // comment("connected (chain)");
                isPawnSupported (eval) = 1;
            }
        }
        If ((isPawnIsolated (eval) == 1) And (isRearDoubledPawn? (for eval) == 1))
        {
            Call change board eval with mg term:(12.5) eg term:(28);
            If (PIECE MATERIAL (NO PAWNS) (EVAL) == 0)
            {
                BOARD EVAL += 35;
            }
        }
        Else
        {
            If (isPawnIsolated (eval) == 1)
            {
                Call change board eval with mg term:(2.5) eg term:(7.5);
            }
            Else
            {
                If (isPawnBackwards (eval) == 1)
                {
                    Call change board eval with mg term:(4) eg term:(12);
                }
            }
        }
        If ((isPawnPhalanx (eval) + isPawnSupported (eval)) > 0)
        {
            Call change board eval with mg term:((-1 * ((ConnectedPawnBonus[(9 - rank from square index)] * ((2 + isPawnPhalanx (eval)) - isPawnOpposed? (eval))) + (10 * isPawnSupported (eval))))) eg term:(((((9 - rank from square index) - 3) / 4) * (-1 * ((ConnectedPawnBonus[(9 - rank from square index)] * ((2 + isPawnPhalanx (eval)) - isPawnOpposed? (eval))) + (10 * isPawnSupported (eval))))));
        }
        If ((rank from square index == 4) Or (rank from square index == 5))
        {
            If (Current Board Position[(counter for evaluation + 8)] == 100)
            {
                BOARD EVAL += 3.5;
            }
        }
        If (most advanced white pawn rank (eval) < 7)
        {
            Call rule of the square for eval with pawn sq:(idx) promotion sq:((56 + Operator.Round(((idx - 0.1) % 8)))) king sq:(whiteKingID(eval)) king to move?:((1 * ((depth % 2) == 0))) chasing king has pieces (not pawns):((1 * ((NUM WHITE MINOR PIECES (EVAL) + NUM WHITE MAJOR PIECES (EVAL)) > 0)));
            If (pawn can safely promote (for eval) == 1)
            {
                BOARD EVAL += -1200;
            }
        }
        If (Least Advanced White Pawn[file from square index] > (rank from square index - 1))
        {
            If ((isPawnBackwards (eval) + isPawnIsolated (eval)) > 0)
            {
                Call // comment("weak unopposed pawn (stockfish idea)");
                Call change board eval with mg term:(6) eg term:(12.5);
            }
        }
        If ((Current Board Position[(idx - 8)] == -320) Or (Current Board Position[(idx - 8)] == -330))
        {
            Call change board eval with mg term:(-9) eg term:(-2);
        }
        If (rank from square index == 7)
        {
            If (Current Board Position[(idx + 8)] == 330)
            {
                Call change board eval with mg term:(9) eg term:(2);
            }
        }
        If ((Current Board Position[(idx + 8)] == -320) Or (Current Board Position[(idx + 8)] == -330))
        {
            If ((file from square index > 3) And (file from square index < 6))
            {
                If (rank from square index > 5)
                {
                    Call change board eval with mg term:(12) eg term:(3.5);
                }
            }
        }
        If (file from square index > 1)
        {
            List.ReplaceItem(num black attacks on square (eval), (idx + 7), (num black attacks on square (eval)[(idx + 7)] + 1));
            Call try to add flank attack white king with square:((idx + 7));
        }
        If (file from square index < 8)
        {
            List.ReplaceItem(num black attacks on square (eval), (idx + 9), (num black attacks on square (eval)[(idx + 9)] + 1));
            Call try to add flank attack white king with square:((idx + 9));
        }
        Stop(this script);
    }
}

Define special pawn values (for eval) (warp=true)
{
    pawn multiplier value (for eval) = 1;
    If (isEndgame? (for eval) == 1)
    {
        If (PIECE MATERIAL (NO PAWNS) (EVAL) == 0)
        {
            Call // comment("scale pawn values up during pawn-only endgames");
            BOARD EVAL += (0.75 * ((NUM WHITE PAWNS (EVAL) - NUM BLACK PAWNS (EVAL)) * Scaled Piece Value (Endgame)[1]));
            Stop(this script);
        }
    }
}

Define special queen eval (warp=true)
{
    Call get mobility in direction delta rank:(1) delta file:(0) (max 7 mob.) start square:(counter for evaluation) ignore queens:((0 == 1)) ignore rooks:((0 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?((1 == 1));
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(-1) delta file:(0) (max 7 mob.) start square:(counter for evaluation) ignore queens:((0 == 1)) ignore rooks:((0 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?((1 == 1));
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(0) delta file:(1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((0 == 1)) ignore rooks:((0 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?((1 == 1));
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(0) delta file:(-1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((0 == 1)) ignore rooks:((0 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?((1 == 1));
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(1) delta file:(1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((0 == 1)) ignore rooks:((0 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?((1 == 1));
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(-1) delta file:(1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((0 == 1)) ignore rooks:((0 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?((1 == 1));
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(1) delta file:(-1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((0 == 1)) ignore rooks:((0 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?((1 == 1));
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(-1) delta file:(-1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((0 == 1)) ignore rooks:((0 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?((1 == 1));
    piece mobility counter (eval) += mobility in direction res;
    Call get rank and file from square index:(counter for evaluation);
    If (current piece (eval) == 900)
    {
        If (piece is attacker? (eval) == 0)
        {
            If (mobility check attacks their king ring (eval) > 0)
            {
                Call add piece as black king attacker with force:(20) (eval);
            }
        }
        Call is piece pinned (eval)((1 == 1));
        If (piece is pinned res (eval) > 0)
        {
            piece mobility counter (eval) = 0;
        }
        MOBILITY mg (eval) += __Queen Mobility Bonus[(piece mobility counter (eval) + 1)];
        MOBILITY eg (eval) += __Queen Mobility Bonus End[(piece mobility counter (eval) + 1)];
        Call change board eval with mg term:((-3 * Black Rooks On File[file from square index])) eg term:((-6 * Black Rooks On File[file from square index]));
        Call change board eval with mg term:((3 * White Rooks on File[file from square index])) eg term:((6 * White Rooks on File[file from square index]));
        If ((WHITE MINOR PIECES DEVELOPED (EVAL) < 3) And (Not ((file from square index == 4))))
        {
            BOARD EVAL += -25;
        }
        Stop(this script);
    }
    If (current piece (eval) == -900)
    {
        If (piece is attacker? (eval) == 0)
        {
            If (mobility check attacks their king ring (eval) > 0)
            {
                Call add piece as white king attacker with force:(20) (eval);
            }
        }
        Call is piece pinned (eval)((0 == 1));
        If (piece is pinned res (eval) > 0)
        {
            piece mobility counter (eval) = 0;
        }
        MOBILITY mg (eval) += (0 - __Queen Mobility Bonus[(piece mobility counter (eval) + 1)]);
        MOBILITY eg (eval) += (0 - __Queen Mobility Bonus End[(piece mobility counter (eval) + 1)]);
        Call change board eval with mg term:((-3 * Black Rooks On File[file from square index])) eg term:((-6 * Black Rooks On File[file from square index]));
        Call change board eval with mg term:((3 * White Rooks on File[file from square index])) eg term:((6 * White Rooks on File[file from square index]));
        If ((BLACK MINOR PIECES DEVELOPED (EVAL) < 3) And (Not ((file from square index == 4))))
        {
            BOARD EVAL += 25;
        }
        Stop(this script);
    }
}

Define special rook eval (warp=true)
{
    Call get mobility in direction delta rank:(1) delta file:(0) (max 7 mob.) start square:(counter for evaluation) ignore queens:((1 == 1)) ignore rooks:((1 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?();
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(-1) delta file:(0) (max 7 mob.) start square:(counter for evaluation) ignore queens:((1 == 1)) ignore rooks:((1 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?();
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(0) delta file:(1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((1 == 1)) ignore rooks:((1 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?();
    piece mobility counter (eval) += mobility in direction res;
    Call get mobility in direction delta rank:(0) delta file:(-1) (max 7 mob.) start square:(counter for evaluation) ignore queens:((1 == 1)) ignore rooks:((1 == 1)) white perspective:((mobility stop pawn color (eval) == -1)) source is queen?();
    piece mobility counter (eval) += mobility in direction res;
    If (current piece (eval) == 500)
    {
        Call // comment("white rook");
        If (abs((file from square index - blackKingID(eval))) < 2)
        {
            Call change board eval with mg term:(7.5) eg term:(0);
        }
        If (mobility check attacks their king ring (eval) > 0)
        {
            Call add piece as black king attacker with force:(50) (eval);
        }
        Call is piece pinned (eval)((1 == 1));
        If (piece is pinned res (eval) > 0)
        {
            piece mobility counter (eval) = floor((piece mobility counter (eval) / 12));
            mobility rook threat mg (eval) = floor((mobility rook threat mg (eval) / 12));
            mobility rook threat eg (eval) = floor((mobility rook threat eg (eval) / 12));
        }
        Call change board eval with mg term:(mobility rook threat mg (eval)) eg term:(mobility rook threat eg (eval));
        MOBILITY mg (eval) += __Rook Mobility Bonus[(piece mobility counter (eval) + 1)];
        MOBILITY eg (eval) += __Rook Mobility Bonus End[(piece mobility counter (eval) + 1)];
        If (((counter for evaluation == 61) And (Current Board Position[62] == 500)) Or ((counter for evaluation == 59) And (Current Board Position[57] == 500)))
        {
            Call // comment("rook boxing another rook in");
            Call // comment("not always super accurate, but better than nothing");
            BOARD EVAL += -20;
        }
        If (((Current Board Position[(counter for evaluation + 1)] == 500) And (file from square index < 8)) Or ((Current Board Position[(counter for evaluation + 2)] == 500) And (file from square index < 7)))
        {
            BOARD EVAL += -15;
        }
        If (abs(Most Advanced White Pawn[file from square index]) == 999)
        {
            Call // comment("semi-open file");
            Call change board eval with mg term:(10) eg term:(3.5);
            If (Open File? (eval)[file from square index] == 1)
            {
                Call // comment("open file");
                Call change board eval with mg term:(15) eg term:(11.5);
            }
        }
        Else
        {
            If (piece mobility counter (eval) < 4)
            {
                If ((WhiteKingFile (eval) > 4) And (file from square index > WhiteKingFile (eval)))
                {
                    trapped rook multiplier (eval) = (1 + (Not (((counter for evaluation == 64) And (whiteKingID(eval) == 61)))));
                    Call change board eval with mg term:((-27.5 * trapped rook multiplier (eval))) eg term:((-6.5 * trapped rook multiplier (eval)));
                }
                If ((WhiteKingFile (eval) < 5) And (file from square index < WhiteKingFile (eval)))
                {
                    trapped rook multiplier (eval) = (1 + (Not (((counter for evaluation == 57) And (whiteKingID(eval) == 61)))));
                    Call change board eval with mg term:((-27.5 * trapped rook multiplier (eval))) eg term:((-6.5 * trapped rook multiplier (eval)));
                }
            }
        }
        Stop(this script);
    }
    If (current piece (eval) == -500)
    {
        Call // comment("black rook");
        If (abs((file from square index - whiteKingID(eval))) < 2)
        {
            Call change board eval with mg term:(-7.5) eg term:(0);
        }
        If (mobility check attacks their king ring (eval) > 0)
        {
            Call add piece as white king attacker with force:(50) (eval);
        }
        Call is piece pinned (eval)((0 == 1));
        If (piece is pinned res (eval) > 0)
        {
            piece mobility counter (eval) = floor((piece mobility counter (eval) / 12));
            mobility rook threat mg (eval) = floor((mobility rook threat mg (eval) / 12));
            mobility rook threat eg (eval) = floor((mobility rook threat eg (eval) / 12));
        }
        Call change board eval with mg term:((-1 * mobility rook threat mg (eval))) eg term:((-1 * mobility rook threat eg (eval)));
        MOBILITY mg (eval) += (0 - __Rook Mobility Bonus[(piece mobility counter (eval) + 1)]);
        MOBILITY eg (eval) += (0 - __Rook Mobility Bonus End[(piece mobility counter (eval) + 1)]);
        If (((counter for evaluation == 3) And (Current Board Position[1] == -500)) Or ((counter for evaluation == 5) And (Current Board Position[6] == -500)))
        {
            Call // comment("rook boxing another rook in");
            Call // comment("not always super accurate, but better than nothing");
            BOARD EVAL += 20;
        }
        If (((Current Board Position[(counter for evaluation + 1)] == -500) And (file from square index < 8)) Or ((Current Board Position[(counter for evaluation + 2)] == -500) And (file from square index < 7)))
        {
            BOARD EVAL += 15;
        }
        If (abs(Most Advanced Black Pawn[file from square index]) == 999)
        {
            Call // comment("semi-open file");
            Call change board eval with mg term:(-10) eg term:(-3.5);
            If (Open File? (eval)[file from square index] == 1)
            {
                Call // comment("open file");
                Call change board eval with mg term:(-15) eg term:(-11.5);
            }
        }
        Else
        {
            If (piece mobility counter (eval) < 4)
            {
                If ((BlackKingFile (eval) > 4) And (file from square index > BlackKingFile (eval)))
                {
                    trapped rook multiplier (eval) = (1 + (Not (((counter for evaluation == 8) And (blackKingID(eval) == 5)))));
                    Call change board eval with mg term:((27.5 * trapped rook multiplier (eval))) eg term:((6.5 * trapped rook multiplier (eval)));
                }
                If ((BlackKingFile (eval) < 5) And (file from square index < BlackKingFile (eval)))
                {
                    trapped rook multiplier (eval) = (1 + (Not (((counter for evaluation == 1) And (blackKingID(eval) == 5)))));
                    Call change board eval with mg term:((27.5 * trapped rook multiplier (eval))) eg term:((6.5 * trapped rook multiplier (eval)));
                }
            }
        }
        Stop(this script);
    }
}

Define store killer move with depth:(string depth) move:(string move) (warp=true)
{
    killerMoveIdxSub = ((depth - 1) * 4);
    killerIdx = 1;
    Repeat Until ((KillerMoves[(killerMoveIdxSub + killerIdx)] == move) Or (killerIdx > 4))
    {
        killerIdx += 1;
    }
    If ((killerIdx == 1) Or (killerIdx > 4))
    {
        List.ReplaceItem(KillerMoves, (killerMoveIdxSub + 1), move);
    }
    Else
    {
        If (killerIdx < 4)
        {
            currentValue(killer) = KillerMoves[(killerMoveIdxSub + 1)];
            List.ReplaceItem(KillerMoves, (killerMoveIdxSub + (killerIdx + 1)), move);
            List.ReplaceItem(KillerMoves, (killerMoveIdxSub + killerIdx), currentValue(killer));
        }
    }
}

Define TOOL - DON'T USE | does piece type:(string piece type) on square:(string start square) check square:(string target square) TOOL USE THE OTHER FUNCTION INSTEAD, IT'S MUCH FASTER  |  ignore pieces(string ignore pieces) (warp=true)
{
    piece check square res (WD) = 0;
    If (abs(piece type) == 99999)
    {
        Stop(this script);
    }
    Call get rank and file from square index:(target square);
    file of target square for check gen = file from square index;
    rank of target square for check gen = rank from square index;
    Call get rank and file from square index:(start square);
    If ((abs(piece type) == 320) Or (abs(piece type) == 330))
    {
        If (Not ((((file from square index + rank from square index) % 2) == ((file of target square for check gen + rank of target square for check gen) % 2))))
        {
            If (abs(piece type) == 330)
            {
                Stop(this script);
            }
        }
        Else
        {
            If (abs(piece type) == 320)
            {
                Stop(this script);
            }
        }
    }
    If (piece type == 100)
    {
        If (Not (((rank of target square for check gen - rank from square index) == 1)))
        {
            Stop(this script);
        }
        If ((start square - 7) == target square)
        {
            If (file from square index < 8)
            {
                piece check square res (WD) = 1;
                Stop(this script);
            }
        }
        If ((start square - 9) == target square)
        {
            If (file from square index > 1)
            {
                piece check square res (WD) = 1;
                Stop(this script);
            }
        }
        Stop(this script);
    }
    If (piece type == -100)
    {
        If (Not (((rank of target square for check gen - rank from square index) == -1)))
        {
            Stop(this script);
        }
        If ((start square + 7) == target square)
        {
            If (file from square index > 1)
            {
                piece check square res (WD) = 1;
                Stop(this script);
            }
        }
        If ((start square + 9) == target square)
        {
            If (file from square index < 8)
            {
                piece check square res (WD) = 1;
                Stop(this script);
            }
        }
        Stop(this script);
    }
    If (abs(piece type) == 320)
    {
        If (abs((rank from square index - rank of target square for check gen)) == 2)
        {
            If (abs((file from square index - file of target square for check gen)) == 1)
            {
                piece check square res (WD) = 1;
                Stop(this script);
            }
        }
        If (abs((rank from square index - rank of target square for check gen)) == 1)
        {
            If (abs((file from square index - file of target square for check gen)) == 2)
            {
                piece check square res (WD) = 1;
                Stop(this script);
            }
        }
        Stop(this script);
    }
    Call get dir from square to square(start square)(target square);
    potential check direction (for check gen) = dir from square to square res;
    If (potential check direction (for check gen) == "")
    {
        Stop(this script);
    }
    If (abs(piece type) == 500)
    {
        If ((potential check direction (for check gen) % 2) == 0)
        {
            Stop(this script);
        }
    }
    If (abs(piece type) == 330)
    {
        If ((potential check direction (for check gen) % 2) == 1)
        {
            Stop(this script);
        }
    }
    Call get distance to edge with index:(start square) //  CHECK DETECTION;
    If (Distance To Each Edge (Check Detection)[potential check direction (for check gen)] == 0)
    {
        piece check square res (WD) = 0;
        Stop(this script);
    }
    temp square index to get potential check (for check gen) = start square;
    counter to get potential check (for check gen) = 0;
    Repeat (Distance To Each Edge (Check Detection)[potential check direction (for check gen)])
    {
        counter to get potential check (for check gen) += 1;
        temp square index to get potential check (for check gen) += direction offsets for sliding pieces[potential check direction (for check gen)];
        If (temp square index to get potential check (for check gen) == target square)
        {
            piece check square res (WD) = 1;
            Stop(this script);
        }
        Else
        {
            If (Not ((Current Board Position[temp square index to get potential check (for check gen)] == "")))
            {
                If (Not ((ignore pieces == 1)))
                {
                    piece check square res (WD) = 0;
                    Stop(this script);
                }
            }
        }
    }
}

Define try to add flank attack black king with square:(string square) (warp=true)
{
    Call get rank and file from square idx:(square) background function;
    If (num white attacks on square (eval)[square] < 3)
    {
        If (black king flank (eval)[file from square idx background] == 1)
        {
            If (rank from square idx background > 3)
            {
                flank attack black king counter (eval) += 1;
            }
        }
    }
}

Define try to add flank attack white king with square:(string square) (warp=true)
{
    Call get rank and file from square idx:(square) background function;
    If (num black attacks on square (eval)[square] < 3)
    {
        If (white king flank (eval)[file from square idx background] == 1)
        {
            If (rank from square idx background < 6)
            {
                flank attack white king counter (eval) += 1;
            }
        }
    }
}

Define TTprobeNodeImpl with board hash:(string board hash) (warp=true)
{
    hash bucket = ((board hash % (List.Length(TTnodeHash) - 3)) + 1);
    If (Not ((TTnodeHash[hash bucket] == board hash)))
    {
        hash bucket += 1;
        If (Not ((TTnodeHash[hash bucket] == board hash)))
        {
            hash bucket += 1;
            If (Not ((TTnodeHash[hash bucket] == board hash)))
            {
                TTprobeRes (WD) = 0;
                Stop(this script);
            }
        }
    }
    # TT Hits += 1;
    TTprobeRes (WD) = 1;
    If ((TTcurrentAge - TTnodeAge[hash bucket]) < 25)
    {
        List.ReplaceItem(TTnodeAge, hash bucket, TTcurrentAge);
    }
    TTprobeNodeScoreRes = TTnodeScore[hash bucket];
    TTprobeNodeAgeRes = TTnodeAge[hash bucket];
    TTprobeHorizonRes = TTnodeHorizon[hash bucket];
    TTprobeBestMoveRes = TTnodeBestMove[hash bucket];
    TTprobeNodeType = TTnodeType[hash bucket];
    TTprobeNodeDepth = TTnodeDepth[hash bucket];
    TTprobeNodeMaxDepth (WD) = TTnodeMaxDepth[hash bucket];
    TTprobeNodeLine (WD) = TTnodeLine[hash bucket];
    TTprobeNodeIDidx (WD) = TTnodeIDidx[hash bucket];
    TTprobeNodeQSstartDepth = TTnodeQSstartDepth[hash bucket];
    TTprobeNodeBoardAttacked = TTnodeBoardAttacked[hash bucket];
    TTprobeNodeBoardAttackedSource1 = TTnodeBoardAttackedSource[hash bucket];
    TTprobeNodeBoardAttackedSource2 = TTnodeBoardAttackedSource2[hash bucket];
}

Define TTprobeNode with board hash:(string board hash) depth:(string depth) (warp=true)
{
    Call TTprobeNodeImpl with board hash:((board hash + ((depth % 2) * floor((List.Length(TTnodeHash) / 2)))));
}

Define TTstoreNodeImpl with board hash:(string board hash) depth:(string depth) score:(string score) horizon:(string horizon) best move:(string best move) node type:(string node type) max depth:(string max depth) q-search start depth:(string qs start depth) board atk:(string board atk) atk source:(string atk source) atk source 2:(string atk source 2) (warp=true)
{
    # TT Attempt Writes += 1;
    hash bucket = ((board hash % (List.Length(TTnodeHash) - 3)) + 1);
    counter to get hash bucket = 1;
    Repeat Until (((TTnodeHash[hash bucket] == board hash) Or (TTnodeHash[hash bucket] == "")) Or (TTnodeAge[hash bucket] < TTcurrentAge))
    {
        If (counter to get hash bucket > 2)
        {
            Stop(this script);
        }
        counter to get hash bucket += 1;
        hash bucket += 1;
    }
    If (TTnodeAge[hash bucket] < TTcurrentAge)
    {
        If (Not (((TTnodeHash[hash bucket] == board hash) Or (TTnodeHash[hash bucket] == ""))))
        {
            # TT Overwrites += 1;
        }
    }
    If (TTnodeHash[hash bucket] == board hash)
    {
        If (horizon > TTnodeHorizon[hash bucket])
        {
            # TT Successful Writes += 1;
            List.ReplaceItem(TTnodeAge, hash bucket, TTcurrentAge);
            List.ReplaceItem(TTnodeScore, hash bucket, score);
            List.ReplaceItem(TTnodeDepth, hash bucket, depth);
            List.ReplaceItem(TTnodeHorizon, hash bucket, horizon);
            List.ReplaceItem(TTnodeBestMove, hash bucket, best move);
            List.ReplaceItem(TTnodeType, hash bucket, node type);
            List.ReplaceItem(TTnodeMaxDepth, hash bucket, max depth);
            List.ReplaceItem(TTnodeLine, hash bucket, Moves Played In Search);
            List.ReplaceItem(TTnodeIDidx, hash bucket, iterative deepening Idx);
            List.ReplaceItem(TTnodeQSstartDepth, hash bucket, qs start depth);
            List.ReplaceItem(TTnodeBoardAttacked, hash bucket, board atk);
            List.ReplaceItem(TTnodeBoardAttackedSource, hash bucket, atk source);
            List.ReplaceItem(TTnodeBoardAttackedSource2, hash bucket, atk source 2);
        }
    }
    Else
    {
        # TT Successful Writes += 1;
        List.ReplaceItem(TTnodeHash, hash bucket, board hash);
        List.ReplaceItem(TTnodeAge, hash bucket, TTcurrentAge);
        List.ReplaceItem(TTnodeScore, hash bucket, score);
        List.ReplaceItem(TTnodeDepth, hash bucket, depth);
        List.ReplaceItem(TTnodeHorizon, hash bucket, horizon);
        List.ReplaceItem(TTnodeBestMove, hash bucket, best move);
        List.ReplaceItem(TTnodeType, hash bucket, node type);
        List.ReplaceItem(TTnodeMaxDepth, hash bucket, max depth);
        List.ReplaceItem(TTnodeLine, hash bucket, Moves Played In Search);
        List.ReplaceItem(TTnodeIDidx, hash bucket, iterative deepening Idx);
        List.ReplaceItem(TTnodeQSstartDepth, hash bucket, qs start depth);
        List.ReplaceItem(TTnodeBoardAttacked, hash bucket, board atk);
        List.ReplaceItem(TTnodeBoardAttackedSource, hash bucket, atk source);
        List.ReplaceItem(TTnodeBoardAttackedSource2, hash bucket, atk source 2);
    }
}

Define TTstoreNode with board hash:(string board hash) depth:(string depth) score:(string score) horizon:(string horizon) best move:(string best move) node type:(string node type) max depth:(string max depth) q-search start depth:(string qs start depth) board atk:(string board atk) atk source:(string atk source) atk source 2:(string atk source 2) (warp=true)
{
    Call TTstoreNodeImpl with board hash:((board hash + ((depth % 2) * floor((List.Length(TTnodeHash) / 2))))) depth:(depth) score:(score) horizon:(horizon) best move:(best move) node type:(node type) max depth:(max depth) q-search start depth:(qs start depth) board atk:(board atk) atk source:(atk source) atk source 2:(atk source 2);
}

Define update actual board with move:(string move) color of moving piece:(string color) (warp=true)
{
    real board move application is capture? = 0;
    CurrentGameCode = Operator.Join(CurrentGameCode, move);
    List.Add(GAME MOVES, move);
    real board move application start = Operator.Join(Operator.LetterOf(move, 1), Operator.LetterOf(move, 2));
    real board move application target = Operator.Join(Operator.LetterOf(move, 3), Operator.LetterOf(move, 4));
    real board move application piece type = Current Board Position[real board move application start];
    If (color == "b")
    {
        List.ReplaceItem(WD_EnPassantTarget, 2, "");
        WHITE MOVE EN PASSANT TARGET = "";
        If (move < 100)
        {
            List.ReplaceItem(WD_CastlingRights, 1, 00);
            List.ReplaceItem(WD_CastlingRights, 3, 00);
        }
        If (real board move application start == 5)
        {
            List.ReplaceItem(WD_CastlingRights, 1, 00);
            List.ReplaceItem(WD_CastlingRights, 3, 00);
        }
        If (real board move application start == 1)
        {
            List.ReplaceItem(WD_CastlingRights, 1, Operator.Join(Operator.LetterOf(WD_CastlingRights[1], 1), 0));
            List.ReplaceItem(WD_CastlingRights, 3, WD_CastlingRights[1]);
        }
        If (real board move application start == 8)
        {
            List.ReplaceItem(WD_CastlingRights, 1, Operator.Join(0, Operator.LetterOf(WD_CastlingRights[1], 2)));
            List.ReplaceItem(WD_CastlingRights, 3, WD_CastlingRights[1]);
        }
        If (real board move application target == 57)
        {
            White CASTLING RIGHTS (DEPTH 0) = Operator.Join(Operator.LetterOf(White CASTLING RIGHTS (DEPTH 0), 1), 0);
            List.ReplaceItem(WD_CastlingRights, 2, White CASTLING RIGHTS (DEPTH 0));
        }
        If (real board move application target == 64)
        {
            White CASTLING RIGHTS (DEPTH 0) = Operator.Join(0, Operator.LetterOf(White CASTLING RIGHTS (DEPTH 0), 2));
            List.ReplaceItem(WD_CastlingRights, 2, White CASTLING RIGHTS (DEPTH 0));
        }
    }
    Else
    {
        List.ReplaceItem(WD_EnPassantTarget, 1, "");
        List.ReplaceItem(WD_EnPassantTarget, 3, "");
        If (move < 100)
        {
            White CASTLING RIGHTS (DEPTH 0) = 00;
            List.ReplaceItem(WD_CastlingRights, 2, 00);
        }
        If (real board move application start == 61)
        {
            White CASTLING RIGHTS (DEPTH 0) = 00;
            List.ReplaceItem(WD_CastlingRights, 2, 00);
        }
        If (real board move application start == 57)
        {
            White CASTLING RIGHTS (DEPTH 0) = Operator.Join(Operator.LetterOf(White CASTLING RIGHTS (DEPTH 0), 1), 0);
            List.ReplaceItem(WD_CastlingRights, 2, White CASTLING RIGHTS (DEPTH 0));
        }
        If (real board move application start == 64)
        {
            White CASTLING RIGHTS (DEPTH 0) = Operator.Join(0, Operator.LetterOf(White CASTLING RIGHTS (DEPTH 0), 2));
            List.ReplaceItem(WD_CastlingRights, 2, White CASTLING RIGHTS (DEPTH 0));
        }
        If (real board move application target == 1)
        {
            List.ReplaceItem(WD_CastlingRights, 1, Operator.Join(Operator.LetterOf(WD_CastlingRights[1], 1), 0));
            List.ReplaceItem(WD_CastlingRights, 3, WD_CastlingRights[1]);
        }
        If (real board move application target == 8)
        {
            List.ReplaceItem(WD_CastlingRights, 1, Operator.Join(0, Operator.LetterOf(WD_CastlingRights[1], 2)));
            List.ReplaceItem(WD_CastlingRights, 3, WD_CastlingRights[1]);
        }
    }
    If (move > 100)
    {
        List.Add(GAME MOVES (PIECES MOVED), Current Board Position[real board move application start]);
        List.Add(GAME MOVES (SQUARES), move);
        If (Not ((Current Board Position[real board move application target] == "")))
        {
            real board move application is capture? = 1;
        }
        List.ReplaceItem(Current Board Position, real board move application target, Current Board Position[real board move application start]);
        If (Current Board Position[real board move application start] == -100)
        {
            If (real board move application target > 56)
            {
                List.ReplaceItem(Current Board Position, computer move target, -900);
            }
            If (WD_EnPassantTarget[1] == computer move target)
            {
                List.ReplaceItem(Current Board Position, (WD_EnPassantTarget[1] - 8), "");
            }
            If ((real board move application target - real board move application start) == 16)
            {
                WHITE MOVE EN PASSANT TARGET = (real board move application start + 8);
                List.ReplaceItem(WD_EnPassantTarget, 2, (real board move application start + 8));
            }
        }
        If (Current Board Position[real board move application start] == 100)
        {
            If (real board move application target < 9)
            {
                List.ReplaceItem(Current Board Position, computer move target, 900);
            }
            If (WHITE MOVE EN PASSANT TARGET == real board move application target)
            {
                List.ReplaceItem(Current Board Position, (WHITE MOVE EN PASSANT TARGET + 8), "");
            }
            If ((real board move application start - real board move application target) == 16)
            {
                List.ReplaceItem(WD_EnPassantTarget, 1, (real board move application start - 8));
                List.ReplaceItem(WD_EnPassantTarget, 3, (real board move application start - 8));
            }
        }
        List.ReplaceItem(Current Board Position, real board move application start, "");
    }
    Else
    {
        List.Add(GAME MOVES (PIECES MOVED), "[castling]");
        If (color == "b")
        {
            If (move == BlackKingSideCastle)
            {
                List.Add(GAME MOVES (SQUARES), 0507);
                List.ReplaceItem(Current Board Position, 5, "");
                List.ReplaceItem(Current Board Position, 7, -99999);
                List.ReplaceItem(Current Board Position, 8, "");
                List.ReplaceItem(Current Board Position, 6, -500);
            }
            Else
            {
                If (move == BlackQueenSideCastle)
                {
                    List.Add(GAME MOVES (SQUARES), 0503);
                    List.ReplaceItem(Current Board Position, 5, "");
                    List.ReplaceItem(Current Board Position, 3, -99999);
                    List.ReplaceItem(Current Board Position, 1, "");
                    List.ReplaceItem(Current Board Position, 4, -500);
                }
            }
        }
        Else
        {
            If (move == WhiteKingSideCastle)
            {
                List.Add(GAME MOVES (SQUARES), 6163);
                List.ReplaceItem(Current Board Position, 61, "");
                List.ReplaceItem(Current Board Position, 63, 99999);
                List.ReplaceItem(Current Board Position, 64, "");
                List.ReplaceItem(Current Board Position, 62, 500);
            }
            Else
            {
                If (move == WhiteQueenSideCastle)
                {
                    List.Add(GAME MOVES (SQUARES), 6159);
                    List.ReplaceItem(Current Board Position, 61, "");
                    List.ReplaceItem(Current Board Position, 59, 99999);
                    List.ReplaceItem(Current Board Position, 57, "");
                    List.ReplaceItem(Current Board Position, 60, 500);
                }
            }
        }
    }
    real board move application start = "";
    Call make fen from position (board);
    List.Add(GAME FEN, FEN FROM CURRENT BOARD POS);
}

Define update CPU contempt value (warp=true)
{
    If (CPU COLOR == "w")
    {
        CPU CONTEMPT VALUE = WHITE CONTEMPT VALUE;
    }
    Else
    {
        CPU CONTEMPT VALUE = BLACK CONTEMPT VALUE;
    }
}

Define update export data with new txt:(string txt) (warp=true)
{
    List.ReplaceItem(EXPORT DATA, 4, Operator.Join(EXPORT DATA[4], txt));
}

Define update king pawn tropism info (warp=true)
{
    king pawn tropism current weight (eval) = 1;
    Call get manhattan distance from square:(counter for evaluation) to square 2:(blackKingID(eval));
    king pawn tropism dist to black (eval) += (distance from square to square * king pawn tropism current weight (eval));
    Call get manhattan distance from square:(counter for evaluation) to square 2:(whiteKingID(eval));
    king pawn tropism dist to white (eval) += (distance from square to square * king pawn tropism current weight (eval));
    king pawn tropism weights (eval) += king pawn tropism current weight (eval);
}

Define update king proximity to passer (eval) (warp=true)
{
    If (isPawnPassed (for eval)? == 0)
    {
        Stop(this script);
    }
    If (current piece (eval) == 100)
    {
        Call // comment("white");
        If (rank from square index < 4)
        {
            Stop(this script);
        }
        pawn weight (king passer proximity) = (((rank from square index - 1) * 5) - 13);
        Call get chebyshev distance from square:((counter for evaluation - 8)) to square 2:(blackKingID(eval));
        distance to king them (king passer proximity) = distance from square to square;
        If (distance to king us (king passer proximity) > 5)
        {
            distance to king us (king passer proximity) = 5;
        }
        king passer proximity total (eval) += (floor((distance to king them (king passer proximity) * (19 / 4))) * pawn weight (king passer proximity));
        Call get chebyshev distance from square:((counter for evaluation - 8)) to square 2:(whiteKingID(eval));
        distance to king us (king passer proximity) = distance from square to square;
        If (distance to king them (king passer proximity) > 5)
        {
            distance to king them (king passer proximity) = 5;
        }
        king passer proximity total (eval) += (0 - ((distance to king us (king passer proximity) * 2) * pawn weight (king passer proximity)));
        If (rank from square index < 7)
        {
            Call get chebyshev distance from square:((counter for evaluation - 16)) to square 2:(whiteKingID(eval));
            distance to king us (king passer proximity) = distance from square to square;
            If (distance to king us (king passer proximity) > 5)
            {
                distance to king us (king passer proximity) = 5;
            }
            king passer proximity total (eval) += (0 - (distance to king us (king passer proximity) * pawn weight (king passer proximity)));
        }
    }
    Else
    {
        Call // comment("black");
        If (rank from square index > 5)
        {
            Stop(this script);
        }
        pawn weight (king passer proximity) = (0 - ((((9 - rank from square index) - 1) * 5) - 13));
        Call get chebyshev distance from square:((counter for evaluation + 8)) to square 2:(whiteKingID(eval));
        distance to king them (king passer proximity) = distance from square to square;
        If (distance to king them (king passer proximity) > 5)
        {
            distance to king them (king passer proximity) = 5;
        }
        king passer proximity total (eval) += (floor((distance to king them (king passer proximity) * (19 / 4))) * pawn weight (king passer proximity));
        Call get chebyshev distance from square:((counter for evaluation + 8)) to square 2:(blackKingID(eval));
        distance to king us (king passer proximity) = distance from square to square;
        If (distance to king us (king passer proximity) > 5)
        {
            distance to king us (king passer proximity) = 5;
        }
        king passer proximity total (eval) += (0 - ((distance to king us (king passer proximity) * 2) * pawn weight (king passer proximity)));
        If (rank from square index > 2)
        {
            Call get chebyshev distance from square:((counter for evaluation + 16)) to square 2:(blackKingID(eval));
            distance to king us (king passer proximity) = distance from square to square;
            If (distance to king us (king passer proximity) > 5)
            {
                distance to king us (king passer proximity) = 5;
            }
            king passer proximity total (eval) += (0 - (distance to king us (king passer proximity) * pawn weight (king passer proximity)));
        }
    }
}

Define verify insufficient material draw (search) depth:(string depth) (warp=true)
{
    insufficient material draw res (search) = 0;
    If (depth > search starting depth)
    {
        If ((NUM BLACK ROOKS (UPDATED) + (NUM BLACK QUEENS (UPDATED) + (NUM WHITE ROOKS (UPDATED) + NUM WHITE QUEENS (UPDATED)))) == 0)
        {
            If ((NUM BLACK PAWNS (UPDATED) + NUM WHITE PAWNS (UPDATED)) == 0)
            {
                If (((NUM BLACK KNIGHTS (UPDATED) + NUM BLACK BISHOPS (UPDATED)) < 2) And ((NUM WHITE BISHOPS (UPDATED) + NUM WHITE KNIGHTS (UPDATED)) == 0))
                {
                    insufficient material draw res (search) = 1;
                }
                If (((NUM WHITE BISHOPS (UPDATED) + NUM WHITE KNIGHTS (UPDATED)) < 2) And ((NUM BLACK KNIGHTS (UPDATED) + NUM BLACK BISHOPS (UPDATED)) == 0))
                {
                    insufficient material draw res (search) = 1;
                }
            }
        }
    }
}

Define WD book finder (warp=true)
{
    WD_best move = 0000;
    Call createCurrentBoardHash with depth:((1 * (Who To Move? (WD) == "b")));
    current real position board hash (book finder) = currentBoardHash;
    Call save current board state (book finder);
    Call force set start position (book finder);
    Call createCurrentBoardHash with depth:(0);
    If (current real position board hash (book finder) == currentBoardHash)
    {
        Call // comment("we are at the start position");
        WD_best move = Opening Book First Move[Operator.Random(1 , List.Length(Opening Book First Move))];
        Call load board state (book finder);
        Stop(this script);
    }
    Call make book finder book;
    Repeat (List.Length(book finder current book))
    {
        Call force set start position (book finder);
        current book finder book line idx = Operator.Random(1 , List.Length(book finder current book));
        Call book finder look at line:(book finder current book[current book finder book line idx]);
        List.DeleteItem(book finder current book, current book finder book line idx);
        If (WD_best move > 0000)
        {
            Call load board state (book finder);
            Stop(this script);
        }
    }
    Call load board state (book finder);
}

Define WD_NNUE reset accumulator info (warp=true)
{
    Call // comment("accumulator size is the "NN size 1" aka, the input size (but not really, the "real" input is 768)");
    List.DeleteAll(WD_NNUE_AccInWeightsGradientsHelper);
    counter to reset NN accumulator = 0;
    Repeat (WD_NNUE_Hidden_Size)
    {
        counter to reset NN accumulator += 1;
        List.ReplaceItem(NN Val 1 (Accumulator), counter to reset NN accumulator, NN Bias 1 (Accumulator)[counter to reset NN accumulator]);
        List.ReplaceItem(NN Val 1 (Accumulator), (counter to reset NN accumulator + WD_NNUE_Hidden_Size), NN Bias 1 (Accumulator)[counter to reset NN accumulator]);
    }
    counter to reset NN accumulator = 0;
    Repeat (64)
    {
        counter to reset NN accumulator += 1;
        If (Not ((Current Board Position[counter to reset NN accumulator] == "")))
        {
            Call NN update accumulator with board idx(counter to reset NN accumulator) piece(Current Board Position[counter to reset NN accumulator]) addition?((1 == 1)) runtime usage?("");
        }
        List.ReplaceItem(WD_NNUE_PrevRefreshBoard, counter to reset NN accumulator, Current Board Position[counter to reset NN accumulator]);
    }
}

Define WD_NNUE_Accumulator_Add8 // acc idx:(string acc idx) weight idx:(string weight idx) (warp=true)
{
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 0), (NN Val 1 (Accumulator)[(acc idx + 0)] + NN ACC In Weights[(weight idx + 0)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 1), (NN Val 1 (Accumulator)[(acc idx + 1)] + NN ACC In Weights[(weight idx + 1)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 2), (NN Val 1 (Accumulator)[(acc idx + 2)] + NN ACC In Weights[(weight idx + 2)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 3), (NN Val 1 (Accumulator)[(acc idx + 3)] + NN ACC In Weights[(weight idx + 3)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 4), (NN Val 1 (Accumulator)[(acc idx + 4)] + NN ACC In Weights[(weight idx + 4)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 5), (NN Val 1 (Accumulator)[(acc idx + 5)] + NN ACC In Weights[(weight idx + 5)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 6), (NN Val 1 (Accumulator)[(acc idx + 6)] + NN ACC In Weights[(weight idx + 6)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 7), (NN Val 1 (Accumulator)[(acc idx + 7)] + NN ACC In Weights[(weight idx + 7)]));
}

Define WD_NNUE_Accumulator_Sub8 // acc idx:(string acc idx) weight idx:(string weight idx) (warp=true)
{
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 0), (NN Val 1 (Accumulator)[(acc idx + 0)] - NN ACC In Weights[(weight idx + 0)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 1), (NN Val 1 (Accumulator)[(acc idx + 1)] - NN ACC In Weights[(weight idx + 1)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 2), (NN Val 1 (Accumulator)[(acc idx + 2)] - NN ACC In Weights[(weight idx + 2)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 3), (NN Val 1 (Accumulator)[(acc idx + 3)] - NN ACC In Weights[(weight idx + 3)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 4), (NN Val 1 (Accumulator)[(acc idx + 4)] - NN ACC In Weights[(weight idx + 4)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 5), (NN Val 1 (Accumulator)[(acc idx + 5)] - NN ACC In Weights[(weight idx + 5)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 6), (NN Val 1 (Accumulator)[(acc idx + 6)] - NN ACC In Weights[(weight idx + 6)]));
    List.ReplaceItem(NN Val 1 (Accumulator), (acc idx + 7), (NN Val 1 (Accumulator)[(acc idx + 7)] - NN ACC In Weights[(weight idx + 7)]));
}

Define WD_NNUE_Chunk8(string accIdx1)(string weightIdx1)(string accIdx2)(string weightIdx2) (warp=true)
{
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx1 + 0)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx1 + 0)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx2 + 0)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx2 + 0)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx1 + 1)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx1 + 1)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx2 + 1)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx2 + 1)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx1 + 2)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx1 + 2)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx2 + 2)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx2 + 2)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx1 + 3)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx1 + 3)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx2 + 3)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx2 + 3)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx1 + 4)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx1 + 4)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx2 + 4)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx2 + 4)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx1 + 5)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx1 + 5)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx2 + 5)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx2 + 5)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx1 + 6)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx1 + 6)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx2 + 6)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx2 + 6)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx1 + 7)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx1 + 7)]);
    Call NNUE activation value:(NN Val 1 (Accumulator)[(accIdx2 + 7)]);
    WD_NNUE_output_res += (activation value res * NN Weights 1[(weightIdx2 + 7)]);
}

Define WD_NNUE_effeciently_update_acc (warp=true)
{
    WD_NNUE_runtime_accUpdate_idx = 0;
    Repeat (64)
    {
        WD_NNUE_runtime_accUpdate_idx += 1;
        If (Not ((WD_NNUE_PrevRefreshBoard[WD_NNUE_runtime_accUpdate_idx] == Current Board Position[WD_NNUE_runtime_accUpdate_idx])))
        {
            If (Not ((WD_NNUE_PrevRefreshBoard[WD_NNUE_runtime_accUpdate_idx] == "")))
            {
                Call // comment("if the previous refreshed position had a piece on this square, but it's different compared to the actual current board, remove it's effect on the accumulator");
                Call NN update accumulator with board idx(WD_NNUE_runtime_accUpdate_idx) piece(WD_NNUE_PrevRefreshBoard[WD_NNUE_runtime_accUpdate_idx]) addition?((0 == 1)) runtime usage?(1);
            }
            If (Not ((Current Board Position[WD_NNUE_runtime_accUpdate_idx] == "")))
            {
                Call // comment("however, if the current board does have a piece, and it's different from the previous refreshed position, add it's effect on the accumulator");
                Call NN update accumulator with board idx(WD_NNUE_runtime_accUpdate_idx) piece(Current Board Position[WD_NNUE_runtime_accUpdate_idx]) addition?((1 == 1)) runtime usage?(1);
            }
            List.ReplaceItem(WD_NNUE_PrevRefreshBoard, WD_NNUE_runtime_accUpdate_idx, Current Board Position[WD_NNUE_runtime_accUpdate_idx]);
        }
    }
}

Define WD_NNUE_Evaluate // Side To Move is Black?(string black to move?) // use efficient acc update:(string fast acc update) (warp=true)
{
    Call // comment("NN will be 768 "true" inputs (64 x 12)");
    Call // comment("layer 1 (accumulator, which gets updated from the "true inputs" which don't have their own storage) = 128");
    Call // comment("layer 2  = output");
    WD_NNUE_output_res = 0;
    If (Not ((fast acc update == 1)))
    {
        Call // comment("used during NN training to set up the accumulator, runtime will have a different approach");
        Call WD_NNUE reset accumulator info;
    }
    Else
    {
        Call // comment("used during runtime to set up the accumulator via gradual updates every time this function is called");
        Call WD_NNUE_effeciently_update_acc;
    }
    Call // comment("accumulator code instead of the "traditional" NN code");
    Call // comment("when using the accumulator, don't bother with setting the list data");
    List.ReplaceItem(NN Val 2, 1, 0);
    WD_NNUE_run_idx = 1;
    WD_NNUE_run_idxSub = ((black to move? * WD_NNUE_Hidden_Size) + 0);
    WD_NNUE_run_idxSub2 = (((1 - black to move?) * WD_NNUE_Hidden_Size) + 0);
    Repeat ((WD_NNUE_Hidden_Size / 8))
    {
        Call WD_NNUE_Chunk8((WD_NNUE_run_idxSub + WD_NNUE_run_idx))(WD_NNUE_run_idx)((WD_NNUE_run_idxSub2 + WD_NNUE_run_idx))((WD_NNUE_Hidden_Size + WD_NNUE_run_idx));
        WD_NNUE_run_idx += 8;
    }
    Call // comment("if using the accumulator in the network, this should be the final output (layers 3-4 unused) so stop the script");
    List.ReplaceItem(NN Val 2, 1, WD_NNUE_output_res);
}

Define White King Safety (warp=true)
{
    Shelter Pawns Kingside (eval) = 0;
    Shelter Pawns Queenside (eval) = 0;
    Shelter Pawns No Castle (eval) = 0;
    Shelter Val Kingside (eval) = "none";
    Shelter Val Queenside (eval) = "none";
    Shelter Val No Castle (eval) = 0;
    White King Shelter Val = 0;
    White King Attacked Val = 0;
    num white shield pawns = 0;
    Call get rank and file from square index:(whiteKingID(eval));
    If (rank from square index > 2)
    {
        White King Shelter Val += -100;
    }
    White King Attacked Val += (0 - Operator.Round(((white king attacking force * Power of Attack (with # of attackers)[num white king attackers (eval)]) * 0.5)));
    If (((Current Board Position[63] == 500) And (whiteKingID(eval) == 64)) Or ((Current Board Position[57] == 500) And (whiteKingID(eval) == 57)))
    {
        White King Attacked Val += -45;
    }
    If (((WhiteKingSide(ForEval) == "king") And (file from square index > 5)) Or (((whiteKingID(eval) == 61) And (Current Board Position[64] == 500)) And ((isEndgame? (for eval) == 0) Or ((Current Board Position[62] == "") And (Current Board Position[63] == "")))))
    {
        If ((whiteKingID(eval) == 61) And (Current Board Position[64] == 500))
        {
            king can pseudo-castle (eval) = 1;
        }
        If (whitePawn(ForEval)[54] == 1)
        {
            Shelter Val Kingside (eval) += PAWN SHIELD BONUS;
            num white shield pawns += 1;
        }
        Else
        {
            If (whitePawn(ForEval)[46] == 1)
            {
                Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * 0.75);
            }
            Else
            {
                If (whitePawn(ForEval)[38] == 1)
                {
                    Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * 0.15);
                }
                Else
                {
                    If (abs(Most Advanced White Pawn[6]) < 999)
                    {
                        Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * 0.05);
                    }
                    Else
                    {
                        Shelter Val Kingside (eval) += (NO PAWN SHIELD PENALTY * 1);
                    }
                }
            }
        }
        If ((whitePawn(ForEval)[55] == 1) Or (whitePawn(ForEval)[47] == 1))
        {
            If (whitePawn(ForEval)[55] == 1)
            {
                Shelter Val Kingside (eval) += PAWN SHIELD BONUS;
            }
            Else
            {
                Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * 0.35);
            }
            num white shield pawns += 1;
        }
        Else
        {
            If (abs(Most Advanced White Pawn[7]) == 999)
            {
                Shelter Val Kingside (eval) += (NO PAWN SHIELD PENALTY * 2);
            }
        }
        If (((whitePawn(ForEval)[56] == 1) Or (whitePawn(ForEval)[48] == 1)) And ((file from square index > 6) Or (king can pseudo-castle (eval) == 1)))
        {
            Shelter Val Kingside (eval) += PAWN SHIELD BONUS;
            num white shield pawns += 1;
        }
        Else
        {
            If (abs(Most Advanced White Pawn[6]) < 999)
            {
                Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * 0.5);
                If (whitePawn(ForEval)[40] == 1)
                {
                    Shelter Val Kingside (eval) += (PAWN SHIELD BONUS * 0.25);
                }
            }
            Else
            {
                Shelter Val Kingside (eval) += NO PAWN SHIELD PENALTY;
            }
        }
        If (Current Board Position[48] == -330)
        {
            If (Current Board Position[55] == 100)
            {
                Shelter Val Kingside (eval) += -50;
            }
            If (WhiteKingSide(ForEval) == "")
            {
                Shelter Val Kingside (eval) += -25;
            }
        }
    }
    If (((WhiteKingSide(ForEval) == "queen") And (file from square index < 4)) Or (((whiteKingID(eval) == 61) And (Current Board Position[57] == 500)) And (isEndgame? (for eval) == 0)))
    {
        If ((whiteKingID(eval) == 61) And (Current Board Position[57] == 500))
        {
            king can pseudo-castle (eval) = 1;
        }
        If ((whitePawn(ForEval)[49] == 1) Or ((whitePawn(ForEval)[41] == 1) Or (whitePawn(ForEval)[33] == 1)))
        {
            If (WhiteKingFile (eval) < 3)
            {
                num white shield pawns += 1;
                If ((whitePawn(ForEval)[49] == 1) Or (whitePawn(ForEval)[41] == 1))
                {
                    Shelter Val Queenside (eval) += PAWN SHIELD BONUS;
                }
                Else
                {
                    Shelter Val Queenside (eval) += (PAWN SHIELD BONUS * 0.25);
                }
            }
        }
        Else
        {
            Shelter Val Queenside (eval) += (NO PAWN SHIELD PENALTY * 1.25);
        }
        If ((whitePawn(ForEval)[50] == 1) Or (whitePawn(ForEval)[42] == 1))
        {
            Shelter Val Queenside (eval) += PAWN SHIELD BONUS;
            num white shield pawns += 1;
        }
        Else
        {
            Shelter Val Queenside (eval) += (NO PAWN SHIELD PENALTY * 1);
            Shelter Val Queenside (eval) += -25;
        }
        If ((whitePawn(ForEval)[51] == 1) Or (whitePawn(ForEval)[43] == 1))
        {
            If (whitePawn(ForEval)[51] == "")
            {
                Shelter Val Queenside (eval) += (PAWN SHIELD BONUS * 0.3);
            }
            Else
            {
                Shelter Val Queenside (eval) += PAWN SHIELD BONUS;
            }
            num white shield pawns += 1;
        }
        Else
        {
            Shelter Val Queenside (eval) += (NO PAWN SHIELD PENALTY * 0.5);
        }
        If ((whitePawn(ForEval)[50] == "") And (whitePawn(ForEval)[51] == ""))
        {
            Shelter Val Queenside (eval) += -15;
            If (whitePawn(ForEval)[49] == "")
            {
                Shelter Val Queenside (eval) += -55;
            }
        }
        If (Current Board Position[41] == -330)
        {
            Shelter Val Queenside (eval) += -50;
        }
    }
    If (abs(Least Advanced White Pawn[4]) == 999)
    {
        Shelter Val No Castle (eval) += -15;
        If (Open File? (eval)[4] == 1)
        {
            If ((whiteKingID(eval) == 61) And ((Current Board Position[62] == "") And (Current Board Position[63] == "")))
            {
                Shelter Val No Castle (eval) += 5;
            }
            Else
            {
                Shelter Val No Castle (eval) += -35;
            }
        }
    }
    If (abs(Least Advanced White Pawn[5]) == 999)
    {
        Shelter Val No Castle (eval) += -15;
        If (Open File? (eval)[4] == 1)
        {
            If ((whiteKingID(eval) == 61) And ((Current Board Position[62] == "") And (Current Board Position[63] == "")))
            {
                Shelter Val No Castle (eval) += 5;
            }
            Else
            {
                Shelter Val No Castle (eval) += -35;
            }
        }
    }
    White King Shelter Val = Shelter Val No Castle (eval);
    If ((Shelter Val Kingside (eval) > White King Shelter Val) And (Not ((Shelter Val Kingside (eval) == "none"))))
    {
        White King Shelter Val = Shelter Val Kingside (eval);
    }
    If ((Shelter Val Queenside (eval) > White King Shelter Val) And (Not ((Shelter Val Queenside (eval) == "none"))))
    {
        White King Shelter Val = Shelter Val Queenside (eval);
    }
    If (WhiteKingSide(ForEval) == "")
    {
        If ((abs(Least Advanced White Pawn[4]) == 999) And (abs(Least Advanced White Pawn[5]) == 999))
        {
            If (BLACK MATERIAL (NO PAWNS) > 2000)
            {
                If (num white king attackers (eval) > 2)
                {
                    White King Shelter Val += -125;
                }
                Else
                {
                    White King Shelter Val += -55;
                }
            }
        }
    }
}

Define white minor piece is developed?(string square) (warp=true)
{
    If ((Current Board Position[square] == 320) Or (Current Board Position[square] == 330))
    {
        If ((square == 58) Or ((square == 59) Or ((square == 62) Or (square == 63))))
        {
            WHITE MINOR PIECES DEVELOPED (EVAL) += -1;
        }
    }
}

Define write pv_val at depth:(string depth) pv_depth:(string pv_depth) write:(string write) (warp=true)
{
    List.ReplaceItem(PV_moves, ((30 * (depth - 1)) + pv_depth), write);
}


//----- Orphaned blocks -----------------------------------------------------------------------------------------------

Call read TT usage (very very slow);

Variable.Show(TT NUM FILLED);
Variable.Show(TT USAGE %);
Variable.Show(TT USAGE FRACTION);
Variable.Show(counter for reading TT usage);

Variable.Hide(TT NUM FILLED);
Variable.Hide(TT USAGE %);
Variable.Hide(TT USAGE FRACTION);
Variable.Hide(counter for reading TT usage);

If ((iterative deepening Idx == 2) And ((ALPHA FOR ASPIRATION WINDOW == "-Infinity") Or (1 == 1)))
{
    Call // comment("q-search debug data");
    If (Moves Played In Search[1] == 5455)
    {
        Call custom debug data with depth:(q-search depth) target depth:(2) message after depth:(Moves Played In Search) display current move:(MovesDepth 2[Moves Index[q-search depth]]) header message:("") max depth:(Operator.Join(max q-search depth, Operator.Join(Operator.Join(" // apply ext ", Apply Num Extensions At Depth[q-search depth]), Operator.Join(" // total ext ", 0)))) log after move #:("");
    }
}

piece type;

List.DeleteAll(DATASET EXTRACT OUTPUT);

Variable.Show(dataset extract with rule idx);
List.Show(DATASET EXTRACT INPUT);
List.Show(DATASET EXTRACT OUTPUT);

List.DeleteAll(DATASET EXTRACT INPUT);

Variable.Show(is KPK draw? (in search));

Call KPK special node code with depth:(0);

If ((iterative deepening Idx == 6) And ((ALPHA FOR ASPIRATION WINDOW == "-Infinity") Or (1 == 1)))
{
    Call // comment("full search debug data");
    Call custom debug data with depth:(depth) target depth:(2) message after depth:(Moves Played In Search) display current move:(MovesDepth 2[Moves Index[depth]]) header message:("") max depth:(Operator.Join(max depth, Operator.Join(Operator.Join(" // apply ext ", Apply Num Extensions At Depth[depth]), Operator.Join(" // total ext ", numExtensions)))) log after move #:("");
    If (Moves Played In Search[2] == 5015)
    {
        Call custom debug data with depth:(depth) target depth:(3) message after depth:(Moves Played In Search) display current move:(MovesDepth 3[Moves Index[depth]]) header message:("") max depth:(Operator.Join(max depth, Operator.Join(Operator.Join(" // apply ext ", Apply Num Extensions At Depth[depth]), Operator.Join(" // total ext ", numExtensions)))) log after move #:("");
    }
}

List.Show(Mobility Area Black);

List.Show(Neutral Opening Book);

line finder idx = 0;
Repeat (List.Length(Neutral Opening Book))
{
    line finder idx += 1;
    If (Operator.Join("a", 5337132151351228372821285236072263460634) == Operator.Join("a", Better for Black Opening Book[line finder idx]))
    {
        Call ​​log​​(line finder idx);
        Stop(this script);
    }
}

List.Show(Better for Black Opening Book);

Call ​​log​​(line);

Call benchmark movegen speed:(100000);
Variable.Show(benchmark movegen NPS);
Variable.Show(benchmark time for 10k);

Call ​​log​​(Moves Played In Search);
Call ​​log​​(depth);

If ((iterative deepening Idx == 6) And ((ALPHA FOR ASPIRATION WINDOW == "-Infinity") Or (1 == 1)))
{
    Call // comment("full search debug data");
    Call custom debug data with depth:(depth) target depth:(2) message after depth:(Moves Played In Search) display current move:(MovesDepth 2[Moves Index[depth]]) header message:("") max depth:(Operator.Join(max depth, Operator.Join(Operator.Join(" // apply ext ", Apply Num Extensions At Depth[depth]), Operator.Join(" // total ext ", numExtensions)))) log after move #:("");
    If (Moves Played In Search[2] == 5015)
    {
        Call custom debug data with depth:(depth) target depth:(3) message after depth:(Moves Played In Search) display current move:(MovesDepth 3[Moves Index[depth]]) header message:("") max depth:(Operator.Join(max depth, Operator.Join(Operator.Join(" // apply ext ", Apply Num Extensions At Depth[depth]), Operator.Join(" // total ext ", numExtensions)))) log after move #:("");
    }
}


//----- Costumes ------------------------------------------------------------------------------------------------------

ABCDEFGHIJKLMNOPQRSTUVWXYZ.svg
Green1.svg
Green2.svg
Piece Square.svg
White1.svg
White2.svg
